<?xml version="1.0" encoding="UTF-8"?>
<templateSet group="go">
  <template name="gin init" value="g := gin.New()        // Creates a new Gin router without the default logger
g.Use(gin.Recovery()) // Adds only the recovery middleware
gin.SetMode(gin.ReleaseMode)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin form set memory" value="// Set a lower memory limit for multipart forms (default is 32 MiB)
g.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin get embedded folders" value="//go:embed assets/* templates/*
var f embed.FS

// example: /public/assets/images/example.png
assets, _ := fs.Sub(f, &#34;assets&#34;)
g.StaticFS(&#34;/public&#34;, http.FS(assets))

g.GET(&#34;favicon.ico&#34;, func(c *gin.Context) {
    file, _ := f.ReadFile(&#34;assets/favicon.ico&#34;)
    c.Data(http.StatusOK, &#34;image/x-icon&#34;, file)
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin favicon" value="g.GET(&#34;favicon.ico&#34;, func(c *gin.Context) {
    file, _ := f.ReadFile(&#34;assets/favicon.ico&#34;)
    c.Data(http.StatusOK, &#34;image/x-icon&#34;, file)
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin handler html" value="g.GET(&#34;/&#34;, func(c *gin.Context) {
    c.HTML(http.StatusOK, &#34;index.tmpl&#34;, gin.H{
        &#34;title&#34;: &#34;Main website&#34;,
    })
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin basic auth on group" value="authorized := g.Group(&#34;/auth&#34;)
authorized.Use(gin.BasicAuth(gin.Accounts{
    &#34;foo&#34;:  &#34;bar&#34;,
    &#34;manu&#34;: &#34;123&#34;,
}))

authorized.GET(&#34;admin&#34;, func(c *gin.Context) {
    c.String(http.StatusOK, &#34;admin&#34;)
})

/* example curl for /admin with basicauth header
	   Zm9vOmJhcg== is base64(&#34;foo:bar&#34;)

		curl -X POST \
	  	http://localhost:8080/auth/admin \
	  	-H &#39;authorization: Basic Zm9vOmJhcg==&#39; \
	  	-H &#39;content-type: application/json&#39; \
	  	-d &#39;{&#34;value&#34;:&#34;bar&#34;}&#39;
	*/
	authorized.POST(&#34;admin&#34;, func(c *gin.Context) {
		user := c.MustGet(gin.AuthUserKey).(string)
		c.String(http.StatusOK, &#34;user: &#34;+user)
	})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin https" value="log.Fatal(autotls.RunWithContext(ctx, g, domain...))

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin handler POST save form" value="g.POST(&#34;/upload&#34;, func(c *gin.Context) {
    // single file
    file, _ := c.FormFile(&#34;file&#34;)
    log.Println(file.Filename)

    // Upload the file to specific dst.
    log.Println(c.SaveUploadedFile(file, &#34;./files/&#34;+file.Filename))

    c.String(http.StatusOK, fmt.Sprintf(&#34;&#39;%s&#39; uploaded!&#34;, file.Filename))
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin middleware (cookie validate example)" value="func CookieTool() gin.HandlerFunc {
  return func(c *gin.Context) {
    // Get cookie
    if cookie, err := c.Cookie(&#34;label&#34;); err == nil {
      if cookie == &#34;ok&#34; {
        c.Next()
        return
      }
    }

    // Cookie verification failed
    c.JSON(http.StatusForbidden, gin.H{&#34;error&#34;: &#34;Forbidden with no cookie&#34;})
    c.Abort()
  }
}

route.GET(&#34;/home&#34;, CookieTool(), func(c *gin.Context) {
c.JSON(200, gin.H{&#34;data&#34;: &#34;Your home page&#34;})
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin handler with middleware example" value="route.GET(&#34;/home&#34;, CookieTool(), func(c *gin.Context) {
    c.JSON(200, gin.H{&#34;data&#34;: &#34;Your home page&#34;})
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin validate custom and bind" value="// &#34;github.com/gin-gonic/gin/binding&#34;
// &#34;github.com/go-playground/validator/v10&#34;

// Booking contains binded and validated data.
type Booking struct {
	CheckIn  time.Time `form:&#34;check_in&#34; binding:&#34;required,bookabledate&#34; time_format:&#34;2006-01-02&#34;`
	CheckOut time.Time `form:&#34;check_out&#34; binding:&#34;required,gtfield=CheckIn&#34; time_format:&#34;2006-01-02&#34;`
}

var bookableDate validator.Func = func(fl validator.FieldLevel) bool {
	date, ok := fl.Field().Interface().(time.Time)
	if ok {
		today := time.Now()
		if today.After(date) {
			return false
		}
	}
	return true
}

if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
    v.RegisterValidation(&#34;bookabledate&#34;, bookableDate)
}

func getBookable(c *gin.Context) {
	var b Booking
	if err := c.ShouldBindWith(&amp;b, binding.Query); err == nil {
		c.JSON(http.StatusOK, gin.H{&#34;message&#34;: &#34;Booking dates are valid!&#34;})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{&#34;error&#34;: err.Error()})
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin bind file (upload)" value="type BindFile struct {
	Name  string                `form:&#34;name&#34; binding:&#34;required&#34;`
	Email string                `form:&#34;email&#34; binding:&#34;required&#34;`
	File  *multipart.FileHeader `form:&#34;file&#34; binding:&#34;required&#34;`
}

/*
&lt;h1&gt;Bind file with fields&lt;/h1&gt;
&lt;form action=&#34;/upload&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
    Name: &lt;input type=&#34;text&#34; name=&#34;name&#34;&gt;&lt;br&gt;
    Email: &lt;input type=&#34;email&#34; name=&#34;email&#34;&gt;&lt;br&gt;
    File: &lt;input type=&#34;file&#34; name=&#34;file&#34;&gt;&lt;br&gt;&lt;br&gt;
    &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt;
&lt;/form&gt;
*/

router.POST(&#34;/upload&#34;, func(c *gin.Context) {
    var bindFile BindFile

    // Bind file
    if err := c.ShouldBind(&amp;bindFile); err != nil {
        c.String(http.StatusBadRequest, fmt.Sprintf(&#34;err: %s&#34;, err.Error()))
        return
    }

    // Save uploaded file
    file := bindFile.File
    dst := filepath.Base(file.Filename)
    if err := c.SaveUploadedFile(file, dst); err != nil {
        c.String(http.StatusBadRequest, fmt.Sprintf(&#34;upload file err: %s&#34;, err.Error()))
        return
    }

    c.String(http.StatusOK, fmt.Sprintf(&#34;File %s uploaded successfully with fields name=%s and email=%s.&#34;, file.Filename, bindFile.Name, bindFile.Email))
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin push" value="if pusher := c.Writer.Pusher(); pusher != nil {
    // use pusher.Push() to do server push
    if err := pusher.Push(&#34;/assets/app.js&#34;, nil); err != nil {
        log.Printf(&#34;Failed to push: %v&#34;, err)
    }
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin multiple servers" value="package main

import (
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;time&#34;

	&#34;github.com/gin-gonic/gin&#34;
	&#34;golang.org/x/sync/errgroup&#34;
)

var errg errgroup.Group

func router01() http.Handler {
	e := gin.New()
	e.Use(gin.Recovery())
	e.GET(&#34;/&#34;, func(c *gin.Context) {
		c.JSON(
			http.StatusOK,
			gin.H{
				&#34;code&#34;:  http.StatusOK,
				&#34;error&#34;: &#34;Welcome server 01&#34;,
			},
		)
	})

	return e
}

func router02() http.Handler {
	e := gin.New()
	e.Use(gin.Recovery())
	e.GET(&#34;/&#34;, func(c *gin.Context) {
		c.JSON(
			http.StatusOK,
			gin.H{
				&#34;code&#34;:  http.StatusOK,
				&#34;error&#34;: &#34;Welcome server 02&#34;,
			},
		)
	})

	return e
}

func main() {
	server01 := &amp;http.Server{
		Addr:         &#34;:8080&#34;,
		Handler:      router01(),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	server02 := &amp;http.Server{
		Addr:         &#34;:8081&#34;,
		Handler:      router02(),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	errg.Go(func() error {
		return server01.ListenAndServe()
	})

	errg.Go(func() error {
		return server02.ListenAndServe()
	})

	if err := errg.Wait(); err != nil {
		log.Fatal(err)
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin middleware security" value="// Setup Security Headers
router.Use(func(c *gin.Context) {
    if c.Request.Host != expectedHost {
        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{&#34;error&#34;: &#34;Invalid host header&#34;})
        return
    }
    c.Header(&#34;X-Frame-Options&#34;, &#34;DENY&#34;)
    c.Header(&#34;Content-Security-Policy&#34;, &#34;default-src &#39;self&#39;; connect-src *; font-src *; script-src-elem * &#39;unsafe-inline&#39;; img-src * data:; style-src * &#39;unsafe-inline&#39;;&#34;)
    c.Header(&#34;X-XSS-Protection&#34;, &#34;1; mode=block&#34;)
    c.Header(&#34;Strict-Transport-Security&#34;, &#34;max-age=31536000; includeSubDomains; preload&#34;)
    c.Header(&#34;Referrer-Policy&#34;, &#34;strict-origin&#34;)
    c.Header(&#34;X-Content-Type-Options&#34;, &#34;nosniff&#34;)
    c.Header(&#34;Permissions-Policy&#34;, &#34;geolocation=(),midi=(),sync-xhr=(),microphone=(),camera=(),magnetometer=(),gyroscope=(),fullscreen=(self),payment=()&#34;)
    c.Next()
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin add func template" value="router.SetFuncMap(template.FuncMap{
    &#34;formatAsDate&#34;: formatAsDate,
})

func formatAsDate(t time.Time) string {
	year, month, day := t.Date()
	return fmt.Sprintf(&#34;%d%02d/%02d&#34;, year, month, day)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gin upload multiple filess" value="router.POST(&#34;/upload&#34;, func(c *gin.Context) {
    name := c.PostForm(&#34;name&#34;)
    email := c.PostForm(&#34;email&#34;)

    // Multipart form
    form, err := c.MultipartForm()
    if err != nil {
        c.String(http.StatusBadRequest, &#34;get form err: %s&#34;, err.Error())
        return
    }
    files := form.File[&#34;files&#34;]

    for _, file := range files {
        filename := filepath.Base(file.Filename)
        if err := c.SaveUploadedFile(file, filename); err != nil {
            c.String(http.StatusBadRequest, &#34;upload file err: %s&#34;, err.Error())
            return
        }
    }

    c.String(http.StatusOK, &#34;Uploaded successfully %d files with fields name=%s and email=%s.&#34;, len(files), name, email)
})

/*
&lt;h1&gt;Upload multiple files with fields&lt;/h1&gt;

&lt;form action=&#34;/upload&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
    Name: &lt;input type=&#34;text&#34; name=&#34;name&#34;&gt;&lt;br&gt;
    Email: &lt;input type=&#34;email&#34; name=&#34;email&#34;&gt;&lt;br&gt;
    Files: &lt;input type=&#34;file&#34; name=&#34;files&#34; multiple&gt;&lt;br&gt;&lt;br&gt;
    &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt;
&lt;/form&gt;
*/
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="binance connect" value="func binanceConnect() *bc.Client {
	apiKey := os.Getenv(&#34;BINANCE_PUBLIC&#34;)
	secretKey := os.Getenv(&#34;BINANCE_SECRET&#34;)
	baseURL := &#34;https://api.binance.com&#34;
	return bc.NewClient(apiKey, secretKey, baseURL)
}

func binanceConnectTest() *bc.Client {
	apiKey := os.Getenv(&#34;BINANCE_PUBLIC_TEST&#34;)
	secretKey := os.Getenv(&#34;BINANCE_SECRET_TEST&#34;)
	baseURL := &#34;https://testnet.binance.vision&#34;
	return bc.NewClient(apiKey, secretKey, baseURL)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="concurrency channel range and close" value="func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i &lt; n; i++ {
		c &lt;- x
		x, y = y, x+y
	}
	close(c)
}

func rangeEx() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
		fmt.Println(i)
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="concurrency channels tick and after" value="tick := time.Tick(100 * time.Millisecond)
boom := time.After(500 * time.Millisecond)
for {
    select {
    case &lt;-tick:
        fmt.Println(&#34;tick.&#34;)
    case &lt;-boom:
        fmt.Println(&#34;BOOM!&#34;)
        return
    default:
        fmt.Println(&#34;    .&#34;)
        time.Sleep(50 * time.Millisecond)
    }
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="concurrency channels semaphore balance" value="var (
	sema    = make(chan struct{}, 1) // a binary semaphore guarding balance
	balance int
)

func Deposit(amount int) {
	sema &lt;- struct{}{} // acquire token
	balance = balance + amount
	&lt;-sema // release token
}

func Balance() int {
	sema &lt;- struct{}{} // acquire token
	b := balance
	&lt;-sema // release token
	return b
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="concurrency rw mutex (RWMutex)" value="// sync.RWMutex is bad for performance. (Use sync.Map)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="concurrency sync mutex balance" value="var (
	mu      sync.Mutex // guards balance
	balance int
)

func Deposit(amount int) {
	mu.Lock()
	balance = balance + amount
	mu.Unlock()
}

func Balance() int {
	mu.Lock()
	b := balance
	mu.Unlock()
	return b
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="base64 encoding and decoding" value="// using encoder/ decoder
buffer := bytes.Buffer{}

// encode into the buffer
encoder := base64.NewEncoder(base64.StdEncoding, &amp;buffer)

if _, err := encoder.Write([]byte(&#34;encoding some other data&#34;)); err != nil {
    log.Fatalln(err)
}

// be sure to close
if err := encoder.Close(); err != nil {
    log.Fatalln(err)
}

fmt.Println(&#34;Using encoder and StdEncoding: &#34;, buffer.String())

// decoder 
decoder := base64.NewDecoder(base64.StdEncoding, &amp;buffer)
results, err := ioutil.ReadAll(decoder)
if err != nil {
    log.Fatalln(err)
}

fmt.Println(&#34;Using decoder and StdEncoding: &#34;, string(results))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="env get from file + config" value="import (
	&#34;github.com/joho/godotenv&#34;
	&#34;log&#34;
)

func init() {
	err := godotenv.Load()
	if err != nil {
		log.Fatalf(&#34;Error loading .env file&#34;)
	}
}

type config struct {
	baseURL   string
	httpPort  int
	basicAuth struct {
		username       string
		hashedPassword string
	}
	cookie struct {
		secretKey string
	}
	db struct {
		dsn         string
		automigrate bool
	}
	notifications struct {
		email string
	}
	session struct {
		secretKey    string
		oldSecretKey string
	}
	smtp struct {
		host     string
		port     int
		username string
		password string
		from     string
	}
}

var cfg config

cfg.baseURL = os.Getenv(&#34;BASE_URL&#34;)
cfg.httpPort = os.Getenv(&#34;HTTP_PORT&#34;) // Parse if integer
cfg.basicAuth.username = os.Getenv(&#34;BASIC_AUTH_USERNAME&#34;)
cfg.basicAuth.hashedPassword = os.Getenv(&#34;BASIC_AUTH_HASHED_PASSWORD&#34;)
cfg.cookie.secretKey = os.Getenv(&#34;COOKIE_SECRET_KEY&#34;)
cfg.db.dsn = os.Getenv(&#34;DB_DSN&#34;)
cfg.db.automigrate = os.Getenv(&#34;DB_AUTOMIGRATE&#34;) // Parse if boolean
cfg.notifications.email = os.Getenv(&#34;NOTIFICATIONS_EMAIL&#34;)
cfg.session.secretKey = os.Getenv(&#34;SESSION_SECRET_KEY&#34;)
cfg.session.oldSecretKey = os.Getenv(&#34;SESSION_OLD_SECRET_KEY&#34;)
cfg.smtp.host = os.Getenv(&#34;SMTP_HOST&#34;)
cfg.smtp.port = os.Getenv(&#34;SMTP_PORT&#34;) // Parse if integer
cfg.smtp.username = os.Getenv(&#34;SMTP_USERNAME&#34;)
cfg.smtp.password = os.Getenv(&#34;SMTP_PASSWORD&#34;)
cfg.smtp.from = os.Getenv(&#34;SMTP_FROM&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="env helpers" value="
func GetString(key, defaultValue string) string {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	}

	return value
}

func GetInt(key string, defaultValue int) int {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	}

	intValue, err := strconv.Atoi(value)
	if err != nil {
		panic(err)
	}

	return intValue
}

func GetBool(key string, defaultValue bool) bool {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	}

	boolValue, err := strconv.ParseBool(value)
	if err != nil {
		panic(err)
	}

	return boolValue
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="json decode" value="var m map[string]string
decoder := json.NewDecoder(file)
err = decoder.Decode(&amp;m)
if err != nil {
    log.Fatalln(&#34;Error decoding JSON to map:&#34;, err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="json encode" value="var m map[string]string
encoder := json.NewEncoder(file)
err = encoder.Encode(m)
if err != nil {
    log.Fatalln(&#34;Error encoding map to JSON:&#34;, err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="json marshal memory to json" value="type Employee struct {
	ID                            int
	FirstName, LastName, JobTitle string
}

emp := Employee{
    ID:        100,
    FirstName: &#34;Shiju&#34;,
    LastName:  &#34;Varghese&#34;,
    JobTitle:  &#34;Architect&#34;,
}

// Encoding to JSON
data, err := json.Marshal(emp)
if err != nil {
    fmt.Println(err.Error())
    return
}

jsonStr := string(data)
fmt.Println(&#34;The JSON data is:&#34;)
fmt.Println(jsonStr)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="json unmarshal json to memory" value="type Employee struct {
	ID                            int
	FirstName, LastName, JobTitle string
}

b := []byte(`{&#34;ID&#34;:101,&#34;FirstName&#34;:&#34;Irene&#34;,&#34;LastName&#34;:&#34;Rose&#34;,&#34;JobTitle&#34;:&#34;Developer&#34;}`)
var emp1 Employee
// Decoding JSON data to a value of struct type
err := json.Unmarshal(b, &amp;emp1)
if err != nil {
    fmt.Println(err.Error())
    return
}
fmt.Println(&#34;The Employee value is:&#34;)
fmt.Printf(&#34;ID:%d, Name:%s %s, JobTitle:%s&#34;, emp1.ID, emp1.FirstName, emp1.LastName, emp1.JobTitle)


" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="encrypt string" value="func encryptToken(email string, secretKey []byte) (string, error) {
	plaintext := []byte(email + &#34;|&#34; + time.Now().Add(1*time.Hour).Format(time.RFC3339))
	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return &#34;&#34;, err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="decrypt string" value="func decryptToken(token string, secretKey []byte) (string, error) {
	ciphertext, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return &#34;&#34;, err
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) &lt; nonceSize {
		return &#34;&#34;, fmt.Errorf(&#34;ciphertext too short&#34;)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return &#34;&#34;, err
	}

	parts := strings.SplitN(string(plaintext), &#34;|&#34;, 2)
	if len(parts) != 2 {
		return &#34;&#34;, fmt.Errorf(&#34;invalid token format&#34;)
	}

	expiry, err := time.Parse(time.RFC3339, parts[1])
	if err != nil {
		return &#34;&#34;, err
	}

	if time.Now().After(expiry) {
		return &#34;&#34;, fmt.Errorf(&#34;token has expired&#34;)
	}

	return parts[0], nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="encrypt int" value="func encryptTokenId(id uint, secretKey []byte) (string, error) {
	// Convert uint to string safely
	idStr := strconv.FormatUint(uint64(id), 10)
	plaintext := []byte(idStr + &#34;|&#34; + time.Now().Add(1*time.Hour).Format(time.RFC3339))

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, fmt.Errorf(&#34;cipher error: %w&#34;, err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, fmt.Errorf(&#34;GCM error: %w&#34;, err)
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return &#34;&#34;, fmt.Errorf(&#34;nonce error: %w&#34;, err)
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="decrypt int" value="func decryptTokenId(token string, secretKey []byte) (uint, error) {
	ciphertext, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return 0, fmt.Errorf(&#34;base64 decode error: %w&#34;, err)
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return 0, fmt.Errorf(&#34;cipher error: %w&#34;, err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return 0, fmt.Errorf(&#34;GCM error: %w&#34;, err)
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) &lt; nonceSize {
		return 0, fmt.Errorf(&#34;ciphertext too short&#34;)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return 0, fmt.Errorf(&#34;decryption failed: %w&#34;, err)
	}

	parts := strings.SplitN(string(plaintext), &#34;|&#34;, 2)
	if len(parts) != 2 {
		return 0, fmt.Errorf(&#34;invalid token format&#34;)
	}

	id64, err := strconv.ParseUint(parts[0], 10, 0)
	if err != nil {
		return 0, fmt.Errorf(&#34;invalid user ID: %w&#34;, err)
	}

	expiry, err := time.Parse(time.RFC3339, parts[1])
	if err != nil {
		return 0, fmt.Errorf(&#34;invalid timestamp: %w&#34;, err)
	}

	if time.Now().After(expiry) {
		return 0, fmt.Errorf(&#34;token expired&#34;)
	}

	return uint(id64), nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file exist not" value="if _, err := os.Stat(&#34;myfile.txt&#34;); errors.Is(err, fs.ErrNotExist) {
		fmt.Println(&#34;myfile.txt does not exist&#34;)
	}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file append" value="f, err := os.OpenFile(cssPath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
if err != nil {
    log.Fatal(err)
}
defer f.Close()

if _, err := f.Write([]byte(css)); err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="ile permissions" value="Use these attributes individually or combined with an OR (|) for second arg of OpenFile().

    e.g. os.O_CREATE|os.O_APPEND, os.O_CREATE|os.O_TRUNC|os.O_WRONLY

    os.O_RDONLY 	// Read only
    os.O_WRONLY 	// Write only
    os.O_RDWR 		// Read and write
    os.O_APPEND 	// Append to end of file
    os.O_CREATE 	// Create is none exist
    os.O_TRUNC 	    // Truncate file when opening

### ile permissions

    0	No permission	                                            ---
    1	Execute permission	                                        --x
    2	Write permission	                                        -w-
    3	Execute and write permission: 1 (execute) + 2 (write) = 3   -wx
    4	Read permission	                                            r--
    5	Read and execute permission: 4 (read) + 1 (execute) = 5	    r-x
    6	Read and write permission: 4 (read) + 2 (write) = 6	        rw-
    7	All permissions: 4 (read) + 2 (write) + 1 (execute) = 7	    rwx
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file change permission" value="// Change perrmissions using Linux style
err := os.Chmod(&#34;test.txt&#34;, 0777)
if err != nil {
    log.Println(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file copy content of file to another file" value="// Open original file
originalFile, err := os.Open(&#34;test.txt&#34;)
if err != nil {
    log.Fatal(err)
}
defer originalFile.Close()

// Create new file
newFile, err := os.Create(&#34;test_copy.txt&#34;)
if err != nil {
    log.Fatal(err)
}
defer newFile.Close()

// Copy the bytes to destination from source
bytesWritten, err := io.Copy(newFile, originalFile)
if err != nil {
    log.Fatal(err)
}
log.Printf(&#34;Copied %d bytes.&#34;, bytesWritten)

// Commit the file contents
// Flushes memory to disk
err = newFile.Sync()
if err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file copy from src to dst" value="// CopyFileFromSrcToDst copies pathSrcFile to pathDstFile
func CopyFileFromSrcToDst(pathSrcFile, pathDstFile string) error {
	// Open original file
	originalFile, err := os.Open(pathSrcFile)
	if err != nil {
		return err
	}
	defer originalFile.Close()

	// Create new file
	newFile, err := os.Create(pathDstFile)
	if err != nil {
		return err
	}
	defer newFile.Close()

	// Copy the bytes to destination from source
	bytesWritten, err := io.Copy(newFile, originalFile)
	if err != nil {
		return err
	}
	log.Printf(&#34;Copied %d bytes.&#34;, bytesWritten)

	// Commit the file contents
	// Flushes memory to disk
	err = newFile.Sync()
	if err != nil {
		return err
	}
	return nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file cross platform path" value="examplePath2 := filepath.FromSlash(&#34;dir/example&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file delete single" value="if err := os.Remove(&#34;file1.txt&#34;); err != nil {
  return err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file dir !exist" value="if _, err := os.Stat(&#34;dirPath&#34;); err != nil {
    fmt.Println(&#34;dirPath does not exist&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file dir exist" value="if info, err := os.Stat(&#34;mydir&#34;); err == nil &amp;&amp; info.IsDir() {
    fmt.Println(&#34;mydir exists and is a directory&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file embedding([]byte) and write" value="//go:embed reload.html
var reloadHtmlFile []byte

http.HandleFunc(&#34;/reload&#34;, func(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&#34;Content-Type&#34;, &#34;text/html&#34;)
    w.Write(reloadHtmlFile)
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file embedding(embed.FS) and static serve embedded directory" value="//go:embed public/*
var publicFiles embed.FS

// root folder
publicFiles, err := fs.Sub(publicFiles, &#34;public&#34;)
if err != nil {
    log.Fatal(err)
}

// public/favicon.ico
http.Handle(&#34;/public/&#34;, http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.FS(publicFiles))))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file exist" value="if info, err := os.Stat(&#34;go.mod&#34;); err == nil &amp;&amp; !info.IsDir() {
    fmt.Println(&#34;go.mod exists and is a file&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file link" value="// Create a hard link
// You will have two file names that point to the same contents
// Changing the contents of one will change the other
// Deleting/renaming one will not affect the other
err := os.Link(&#34;test.txt&#34;, &#34;test_also.txt&#34;)
if err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file open" value="file, err := os.Open(filePath)
if err != nil {
    log.Fatalln(&#34;Error opening file:&#34;, err)
}
defer file.Close()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file open (os)" value="file, err := os.OpenFile(&#34;test.txt&#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
if err != nil {
    log.Fatal(err)
}
defer file.Close()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file quick read (ioutil)" value="data, err := os.ReadFile(&#34;test.txt&#34;)
if err != nil {
    log.Fatal(err)
}

log.Printf(&#34;Data read: %s\n&#34;, data)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file read at least (os)" value="func FileReadAtLeastNbytes(pathFile string, minBytesToRead int) ([]byte, error) {
	// Open file for reading
	file, err := os.Open(pathFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	minBytes := minBytesToRead
	byteSlice := make([]byte, minBytesToRead*64)
	// io.ReadAtLeast() will return an error if it cannot
	// find at least minBytes to read. It will read as
	// many bytes as byteSlice can hold.
	_, err = io.ReadAtLeast(file, byteSlice, minBytes)
	if err != nil {
		return nil, err
	}
	return byteSlice, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file read exacty" value="// FileReadExactlyNbytes reads exactly numBytesToRead from pathFile
func FileReadExactlyNbytes(pathFile string, numBytesToRead int) ([]byte, error) {
	// Open file for reading
	file, err := os.Open(pathFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// The file.Read() function will happily read a tiny file in to a large
	// byte slice, but io.ReadFull() will return an
	// error if the file is smaller than the byte slice.
	byteSlice := make([]byte, numBytesToRead)
	_, err = io.ReadFull(file, byteSlice)
	if err != nil {
		return nil, err
	}
	return byteSlice, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file read with scanner (bufio)" value="input := bufio.NewScanner(os.Stdin)
for input.Scan() {
    //input.Text()
}
if err := input.Err(); err != nil {
    // TODO: scanner error
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file rename or remove" value="originalPath := &#34;test.txt&#34;
newPath := &#34;test2.txt&#34;
err := os.Rename(originalPath, newPath)
if err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file stat (os)" value="// Stat returns file info. It will return
// an error if there is no file.
fileInfo, err := os.Stat(&#34;test.txt&#34;)
if err != nil {
    log.Fatal(err)
}
fmt.Println(&#34;File name:&#34;, fileInfo.Name())
fmt.Println(&#34;Size in bytes:&#34;, fileInfo.Size())
fmt.Println(&#34;Permissions:&#34;, fileInfo.Mode())
fmt.Println(&#34;Last modified:&#34;, fileInfo.ModTime())
fmt.Println(&#34;Is Directory: &#34;, fileInfo.IsDir())
fmt.Printf(&#34;System interface type: %T\n&#34;, fileInfo.Sys())
fmt.Printf(&#34;System info: %+v\n\n&#34;, fileInfo.Sys())
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file temporary file" value="// Create a temp dir in the system default temp folder
tempDirPath, err := ioutil.TempDir(&#34;&#34;, &#34;myTempDir&#34;)
if err != nil {
    log.Fatal(err)
}
fmt.Println(&#34;Temp dir created:&#34;, tempDirPath)

// Create a file in new temp directory
tempFile, err := ioutil.TempFile(tempDirPath, &#34;myTempFile.txt&#34;)
if err != nil {
    log.Fatal(err)
}
fmt.Println(&#34;Temp file created:&#34;, tempFile.Name())

// ... do something with temp file/dir ...

// Close file
err = tempFile.Close()
if err != nil {
    log.Fatal(err)
}

// Delete the resources we created
err = os.Remove(tempFile.Name())
if err != nil {
    log.Fatal(err)
}
err = os.Remove(tempDirPath)
if err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file quick write" value="err := os.WriteFile($1$, $2$, 0644)
if err != nil {
    log.Fatal(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file write with validation" value="// FileWriteWithValidation writes content to filePath and validates that the writing was successful
func FileWriteWithValidation(f *os.File, content string) error {
	value := []byte(content)
	count, err := f.Write(value)
	if err != nil {
		return err
	}

	if count != len(value) {
		return errors.New(&#34;incorrect length returned from write&#34;)
	}
	return nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="dir walk (filepath)" value="var staticFiles []string
err = filepath.WalkDir(&#34;.&#34;, func(path string, d fs.DirEntry, err error) error {  
   if !d.IsDir() {  
      ext := filepath.Ext(d.Name())  
      if ext == &#34;.html&#34; || ext == &#34;.css&#34; || ext == &#34;.js&#34; {  
         // open html file  
         staticFiles = append(staticFiles, path)  
      }  
   }  
   return nil  
})  
  
if err != nil {  
   panic(err)  
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="file os path compatible" value="pathToEncrypt := filepath.ToSlash(*terminalPath)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="form init  decoder and validate" value="//&#34;github.com/go-playground/validator/v10&#34;
//&#34;github.com/gorilla/schema&#34;

// form processing
var decoder = schema.NewDecoder()
var validate = validator.New()

func init() {
	// This tells the decoder to silently ignore form valuesthat don&#39;t correspond to a struct field.
	decoder.IgnoreUnknownKeys(true)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="form decode and validate" value="if err := r.ParseForm(); err != nil {
    cookies.FlashSetWithRedirect(w, r, &#34;There was an error processing your request. Please try again.&#34;, &#34;/register&#34;)
    return
}

// Define an inline struct for signup, with validation tags.
var signupReq = struct {
    Email           string `schema:&#34;email&#34; validate:&#34;required,email&#34;`
    Password        string `schema:&#34;password&#34; validate:&#34;required,min=8&#34;`
    ConfirmPassword string `schema:&#34;confirm_password&#34; validate:&#34;eqfield=Password&#34;`
}{}

// Decode the form values.
if err := decoder.Decode(&amp;signupReq, r.PostForm); err != nil {
    cookies.FlashSetWithRedirect(w, r, &#34;Unexpected error. Please try again later.&#34;, &#34;/register&#34;)
    return
}

// Validate the fields.
if err := validate.Struct(signupReq); err != nil {
    friendlyErrors := []string{}
    // Loop through each validation error and translate it.
    for _, err := range err.(validator.ValidationErrors) {
        switch err.Field() {
        case &#34;Email&#34;:
            friendlyErrors = append(friendlyErrors, &#34;A valid email address is required.&#34;)
        case &#34;Password&#34;:
            friendlyErrors = append(friendlyErrors, &#34;Your password must be at least 8 characters long.&#34;)
        case &#34;ConfirmPassword&#34;:
            friendlyErrors = append(friendlyErrors, &#34;The confirmation password must match your password.&#34;)
        default:
            friendlyErrors = append(friendlyErrors, &#34;Invalid input for &#34;+err.Field()+&#34;.&#34;)
        }
    }
    cookies.FlashSetWithRedirect(w, r, strings.Join(friendlyErrors, &#34; &#34;), &#34;/register&#34;)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="form bcrypt compare passwords" value="// Verify the old password
if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(oldPassword)); err != nil {
    return errors.New(&#34;old password is incorrect&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm create" value="type Page struct {
	ID         uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name       string `gorm:&#34;index&#34;`
	URL        string
	HTML       []byte
	CategoryID uint
}

type Category struct {
	ID    uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name  string `gorm:&#34;index&#34;`
	Pages []Page
}

if err := d.DB.Create(&amp;category).Error; err != nil {
    log.Println(&#34;Error saving category:&#34;, err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm get all join" value="type Page struct {
	ID         uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name       string `gorm:&#34;index&#34;`
	URL        string
	HTML       []byte
	CategoryID uint
}

type Category struct {
	ID    uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name  string `gorm:&#34;index&#34;`
	Pages []Page
}

var categories []Category
// Retrieve the categories and their pages from the database
err := d.DB.Preload(&#34;Pages&#34;).Find(&amp;categories).Error
if err != nil {
    return nil, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm literal: ID" value="uint `gorm:&#34;primaryKey;autoIncrement&#34;`
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm init" value="// &#34;gorm.io/driver/sqlite&#34;
// &#34;gorm.io/gorm&#34;

type Page struct {
	ID         uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name       string `gorm:&#34;index&#34;`
	URL        string
	HTML       []byte
	CategoryID uint
}

type Category struct {
	ID    uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name  string `gorm:&#34;index&#34;`
	Pages []Page
}

type Database struct {
	DB *gorm.DB
}

func (d *Database) Connect() {
	var err error
	d.DB, err = gorm.Open(sqlite.Open(&#34;file:codestitch.db?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;), &amp;gorm.Config{})
	if err != nil {
		log.Fatalf(&#34;Failed to connect to SQLite database: %v&#34;, err)
	}

	// Drop existing tables to start fresh
	err = d.DB.Migrator().DropTable(&amp;Category{}, &amp;Page{})
	if err != nil {
		log.Fatalf(&#34;Failed to drop existing tables: %v&#34;, err)
	}

	// Migrate the schema automatically, create tables, etc.
	err = d.DB.AutoMigrate(&amp;Category{}, &amp;Page{})
	if err != nil {
		log.Fatalf(&#34;Failed to migrate database: %v&#34;, err)
	}

	fmt.Println(&#34;Connected to SQLite database:&#34;, &#34;codestitch.db&#34;)
}

func (d *Database) Close() {
	// SQLite doesn&#39;t require explicit closing with GORM.
	// The connection will be closed automatically when the program ends.
	// Retrieve the underlying SQL DB connection.
	db, err := d.DB.DB()
	if err != nil {
		log.Println(&#34;Error getting database connection:&#34;, err)
		return
	}

	// Attempt to close the connection.
	if err = db.Close(); err != nil {
		log.Println(&#34;Error closing database connection:&#34;, err)
	} else {
		fmt.Println(&#34;Database connection closed.&#34;)
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm transaction" value="type Page struct {
	ID         uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name       string `gorm:&#34;index&#34;`
	URL        string
	HTML       []byte
	CategoryID uint
}

type Category struct {
	ID    uint   `gorm:&#34;primaryKey;autoIncrement&#34;`
	Name  string `gorm:&#34;index&#34;`
	Pages []Page
}

for _, category := range categories {
    // Save category and its pages in a single transaction
    d.DB.Transaction(func(tx *gorm.DB) error {
        if err := tx.Create(&amp;category).Error; err != nil {
            return err
        }
        return nil
    })
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm literal: unique, not null" value="`gorm:&#34;unique;not null&#34;`
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm update value/values" value="if err := auth.Model(&amp;User{}).
    Where(&#34;id = ?&#34;, id).
    Update(&#34;verified&#34;, true).Error; err != nil {
    return err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm delete" value="if err = auth.Delete(&amp;User{}, userID).Error; err != nil {
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gor get struct by email" value="var user User
if err := auth.Where(&#34;email = ?&#34;, email).First(&amp;user).Error; err != nil {
    return err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm get struct by id" value="var user User
if err := auth.First(&amp;user, id).Error; err != nil {
    return &#34;&#34;, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm get all structs" value="if err = auth.Find(&amp;users).Error; err != nil {
    return nil, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="gorm create struct" value="if err := auth.Create(&amp;user).Error; err != nil {
    return User{}, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import bcrypt" value="&#34;golang.org/x/crypto/bcrypt&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import fsnotify" value="&#34;github.com/fsnotify/fsnotify&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import gorilla websocket" value="&#34;github.com/gorilla/websocket&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import gin" value="&#34;github.com/gin-gonic/gin&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import gin autotls https" value="&#34;github.com/gin-gonic/autotls&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import errgroup" value="&#34;golang.org/x/sync/errgroup&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import" value="bc &#34;github.com/binance/binance-connector-go&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import storm" value="&#34;github.com/asdine/storm/v3&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="import cache in memory" value="&#34;github.com/patrickmn/go-cache&#34;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="log set flags" value="log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="log slog with multiple writers and line number" value="// NewLog creates and returns a new slog.Logger instance along with a cleanup function.
// The cleanup must be called when the application is shutting down to close the log file.
func NewLog(production bool) (logger *slog.Logger, cleanup func(), err error) {
	var logFile *os.File
	logFile, err = os.OpenFile(&#34;app.log&#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return
	}

	cleanup = func() {
		if err := logFile.Close(); err != nil {
			log.Printf(&#34;Error closing log file: %v&#34;, err)
		}
	}

	opts := &amp;slog.HandlerOptions{
		Level:     slog.LevelDebug,
		AddSource: true, //  This line enables source info (file:line)
	}

	if production {
		logger = slog.New(slog.NewTextHandler(logFile, opts))
	} else {
		multiWriter := io.MultiWriter(os.Stdout, logFile)
		multiHandler := slog.NewTextHandler(multiWriter, opts)
		logger = slog.New(multiHandler)
	}
	return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="log to memory" value="// we&#39;ll configure the logger to write
// to a bytes.Buffer
buf := bytes.Buffer{}

// second argument is the prefix last argument is about options
// you combine them with a logical or.
logger := log.New(&amp;buf, &#34;logger: &#34;, log.Lshortfile|log.Ldate)
logger.Println(&#34;test&#34;)
logger.SetPrefix(&#34;new logger: &#34;)
logger.Printf(&#34;you can also add args(%v) and use Fatalln to log and crash&#34;, true)

fmt.Println(buf.String())
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="log with caller" value="func logWithCaller(msg string) {
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		log.Println(&#34;Failed to get caller info&#34;)
		return
	}
	funcName := runtime.FuncForPC(pc).Name()
	log.Printf(&#34;[%s:%d %s] %s\n&#34;, file, line, funcName, msg)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="log with multiple writers and line numbers" value="// NewLog creates and returns a new *log.Logger instance and a cleanup function.
// Logs are written to both app.log and stdout unless production is true.
func NewLog(production bool) (logger *log.Logger, cleanup func(), err error) {
	var logFile *os.File
	logFile, err = os.OpenFile(&#34;app.log&#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, nil, err
	}

	cleanup = func() {
		if cerr := logFile.Close(); cerr != nil {
			log.Printf(&#34;Error closing log file: %v&#34;, cerr)
		}
	}

	var writer io.Writer
	if production {
		writer = logFile
	} else {
		writer = io.MultiWriter(os.Stdout, logFile)
	}

	logger = log.New(writer, &#34;&#34;, log.Ldate|log.Ltime|log.Lshortfile) // adds timestamp + file:line
	return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware auth with context" value="&#34;github.com/golang-jwt/jwt&#34;

func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cookie, err := r.Cookie(&#34;jwt&#34;)
		if err != nil {
			ctx := context.WithValue(r.Context(), &#34;user_email&#34;, &#34;&#34;)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Parse and validate the JWT
		token, err := jwt.Parse(cookie.Value, func(token *jwt.Token) (interface{}, error) {
			return []byte(secretKey), nil
		})
		if err != nil || !token.Valid {
			ctx := context.WithValue(r.Context(), &#34;user_email&#34;, &#34;&#34;)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Extract the email from the JWT claims
		claims := token.Claims.(jwt.MapClaims)
		userEmail := claims[&#34;email&#34;].(string)

		// Attach the user email to the request context for use in handlers
		ctx := context.WithValue(r.Context(), &#34;user_email&#34;, userEmail)
		next.ServeHTTP(w, r.WithContext(ctx))
	}
}

http.HandleFunc(&#34;/&#34;, authMiddleware(homeHandler))

userEmail, ok := r.Context().Value(&#34;user_email&#34;).(string)
if !ok {
    http.Error(w, &#34;Unauthorized&#34;, http.StatusUnauthorized)
    return
}

data := map[string]interface{}{
    &#34;UserEmail&#34;: userEmail,
}

{{if .UserEmail}}
    &lt;p&gt;Welcome, {{.UserEmail}}!&lt;/p&gt;
{{else}}
    &lt;p&gt;Welcome, Guest!&lt;/p&gt;
{{end}}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware cache static files" value="package middleware

import &#34;net/http&#34;

func Cache(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&#34;Vary&#34;, &#34;Accept-Encoding&#34;)
		w.Header().Set(&#34;Cache-Control&#34;, &#34;public, max-age=7776000&#34;)
		next.ServeHTTP(w, r)
	})
}

http.Handle(&#34;/public/&#34;, middlewares.Cache(http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.Dir(&#34;static/public&#34;)))))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware gzip" value="type GzipMiddleware struct {
	Next http.Handler
}

type gzipResponseWriter struct {
	http.ResponseWriter
	io.Writer
}

type gzipPusherResponseWriter struct {
	gzipResponseWriter
	http.Pusher
}

func (gm *GzipMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if gm.Next == nil {
		gm.Next = http.DefaultServeMux
	}

	encodings := r.Header.Get(&#34;Accept-Encoding&#34;)
	if !strings.Contains(encodings, &#34;gzip&#34;) {
		gm.Next.ServeHTTP(w, r)
		return
	}
	w.Header().Add(&#34;Content-Encoding&#34;, &#34;gzip&#34;)
	gzipWriter := gzip.NewWriter(w)
	defer gzipWriter.Close()
	var rw http.ResponseWriter
	if pusher, ok := w.(http.Pusher); ok { // see if original writer implements server push
		rw = gzipPusherResponseWriter{
			gzipResponseWriter: gzipResponseWriter{
				ResponseWriter: w,
				Writer:         gzipWriter,
			},
			Pusher: pusher,
		}
	} else {
		rw = gzipResponseWriter{
			ResponseWriter: w,
			Writer:         gzipWriter,
		}
	}
	gm.Next.ServeHTTP(rw, r)
}

func (grw gzipResponseWriter) Write(data []byte) (int, error) {
	return grw.Writer.Write(data)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware handle (handler ServeHTTP) with chain" value="type HelloHandler struct{}

func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &#34;Hello!&#34;)
}

func log(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Printf(&#34;Handler called - %T\n&#34;, h)
		h.ServeHTTP(w, r)
	})
}

func protect(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// some code to make sure the user is authorized
		h.ServeHTTP(w, r)
	})
}

hello := HelloHandler{}
http.Handle(&#34;/hello&#34;, protect(log(hello)))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware handler func (HandlerFunc) with chain" value="func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &#34;Hello!&#34;)
}

func log(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		name := runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()
		fmt.Println(&#34;Handler function called - &#34; + name)
		h(w, r)
	}
}

http.HandleFunc(&#34;/hello&#34;, log(hello)) 
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware secure headers" value="// Custom middleware handler logs user agent
func addSecureHeaders(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add(&#34;Content-Security-Policy&#34;, &#34;default-src &#39;self&#39;&#34;)
		w.Header().Add(&#34;X-Frame-Options&#34;, &#34;SAMEORIGIN&#34;)
		w.Header().Add(&#34;X-XSS-Protection&#34;, &#34;1; mode=block&#34;)
		w.Header().Add(&#34;Strict-Transport-Security&#34;, &#34;max-age=10000, includeSubdomains; preload&#34;)
		w.Header().Add(&#34;X-Content-Type-Options&#34;, &#34;nosniff&#34;)
		h(w, r)
	}
}

http.HandleFunc(&#34;/&#34;, addSecureHeaders(index))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware recovery with  slog" value="func recoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				slog.Error(&#34;Panic recovered&#34;, &#34;error&#34;, err, &#34;path&#34;, r.URL.Path)
				http.Error(w, &#34;Internal Server Error&#34;, http.StatusInternalServerError)
			}
		}()
		next.ServeHTTP(w, r)
	})
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware gzip simple" value="type gzipResponseWriter struct {
	io.Writer
	http.ResponseWriter
}

func (w gzipResponseWriter) Write(b []byte) (int, error) {
	return w.Writer.Write(b)
}

func (w gzipResponseWriter) Header() http.Header {
	return w.ResponseWriter.Header()
}

func (w gzipResponseWriter) WriteHeader(statusCode int) {
	w.ResponseWriter.WriteHeader(statusCode)
}

func gzipMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !strings.Contains(r.Header.Get(&#34;Accept-Encoding&#34;), &#34;gzip&#34;) {
			next.ServeHTTP(w, r)
			return
		}
		w.Header().Set(&#34;Content-Encoding&#34;, &#34;gzip&#34;)
		gz := gzip.NewWriter(w)
		defer gz.Close()
		gzw := gzipResponseWriter{Writer: gz, ResponseWriter: w}
		next.ServeHTTP(gzw, r)
	})
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="crawl goquery get links" value="// &#34;github.com/PuerkitoBio/goquery&#34;

// extractLinks extracts the data-href attributes from the buttons with the specified class.
// button has classes: button-as-link get-code-btn
func extractLinks(page string) []string {
	// Use the goquery package to parse the HTML page
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(page))
	if err != nil {
		log.Fatalln(&#34;Error parsing HTML:&#34;, err)
	}

	// Create a slice to store the links
	var links []string

	// Find all buttons with the specified class and extract their data-href attributes
	doc.Find(&#34;button.button-as-link.get-code-btn&#34;).Each(func(i int, s *goquery.Selection) {
		if href, exists := s.Attr(&#34;data-href&#34;); exists {
			links = append(links, href)
		}
	})

	return links
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="crawl goquery nested example" value="/*

// &#34;github.com/PuerkitoBio/goquery&#34;

&lt;ul id=&#34;stitch-list&#34;&gt;
    &lt;li class=&#34;dropdown&#34;&gt;
        &lt;span class=&#34;category category_toggle&#34;&gt;E-Commerce&lt;/span&gt;
        &lt;ul class=&#34;child_list&#34;&gt;
            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/100&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(23)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/232&#34;&gt;Collections &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li class=&#34;dropdown&#34;&gt;
        &lt;span class=&#34;category category_toggle&#34;&gt;Buttons&lt;/span&gt;
        &lt;ul class=&#34;child_list&#34;&gt;
            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/22&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;

*/

doc, err := goquery.NewDocumentFromReader(bytes.NewReader(htmlFile))
if err != nil {
    log.Fatalln(&#34;Error loading HTML:&#34;, err)
}

doc.Find(&#34;li.dropdown&#34;).Each(func(i int, s *goquery.Selection) {
    name := s.Find(&#34;span.category_toggle&#34;).Text()
    fmt.Println(&#34;Element:&#34;, name)

    // Find sub-items
    s.Find(&#34;ul.child_list a&#34;).Each(func(j int, a *goquery.Selection) {
        href, exists := a.Attr(&#34;href&#34;)
        if exists {
            value := a.Find(&#34;span.cat-options&#34;).Text()
            fmt.Printf(&#34;  - Link: %s | Value: %s\n&#34;, href, value)
        }
    })
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="crawl html, scrap example" value="package main

import (
	&#34;fmt&#34;
	&#34;strings&#34;

	&#34;golang.org/x/net/html&#34;
)

// Structure to hold extracted data
type Item struct {
	Category string
	Links    []LinkInfo
}

type LinkInfo struct {
	Href  string
	Count string
}

func main() {
	htmlContent := `
	&lt;ul id=&#34;stitch-list&#34;&gt;
		&lt;li class=&#34;dropdown &#34;&gt;
			&lt;span class=&#34;category category_toggle&#34;&gt;E-Commerce&lt;/span&gt;
			&lt;ul class=&#34;child_list&#34;&gt;
				&lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/100&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(23)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/232&#34;&gt;Collections &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li class=&#34;dropdown &#34;&gt;
			&lt;span class=&#34;category category_toggle&#34;&gt;Buttons&lt;/span&gt;
			&lt;ul class=&#34;child_list&#34;&gt;
				&lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/22&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;`

	doc, err := html.Parse(strings.NewReader(htmlContent))
	if err != nil {
		fmt.Println(&#34;Error parsing HTML:&#34;, err)
		return
	}

	// Extract categories with links dynamically
	data := extractItems(doc, &#34;li&#34;, &#34;dropdown &#34;, &#34;span&#34;, &#34;category category_toggle&#34;, &#34;a&#34;, &#34;href&#34;, &#34;span&#34;, &#34;cat-options&#34;)

	// Print extracted data
	for _, item := range data {
		fmt.Println(&#34;Category:&#34;, item.Category)
		for _, link := range item.Links {
			fmt.Printf(&#34;  - URL: %s | Count: %s\n&#34;, link.Href, link.Count)
		}
	}
}

// extractItems extracts data based on provided HTML structure details
func extractItems(n *html.Node, parentTag, parentClass, categoryTag, categoryClass, linkTag, linkAttr, countTag, countClass string) []Item {
	var items []Item

	// Traverse and find elements
	var traverse func(*html.Node)
	traverse = func(n *html.Node) {
		if n.Type == html.ElementNode &amp;&amp; n.Data == parentTag {
			if getAttribute(n, &#34;class&#34;) == parentClass {
				category := extractTextByClass(n, categoryTag, categoryClass)
				links := extractLinks(n, linkTag, linkAttr, countTag, countClass)
				items = append(items, Item{Category: category, Links: links})
			}
		}
		// Recursively check child nodes
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			traverse(c)
		}
	}

	traverse(n)
	return items
}

// extractLinks finds all links and their counts within a section
func extractLinks(n *html.Node, linkTag, linkAttr, countTag, countClass string) []LinkInfo {
	var links []LinkInfo

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode &amp;&amp; c.Data == &#34;ul&#34; {
			for li := c.FirstChild; li != nil; li = li.NextSibling {
				if li.Type == html.ElementNode &amp;&amp; li.Data == &#34;li&#34; {
					href, count := extractLinkAndCount(li, linkTag, linkAttr, countTag, countClass)
					if href != &#34;&#34; &amp;&amp; count != &#34;&#34; {
						links = append(links, LinkInfo{Href: href, Count: count})
					}
				}
			}
		}
	}

	return links
}

// extractLinkAndCount extracts href and count values
func extractLinkAndCount(n *html.Node, linkTag, linkAttr, countTag, countClass string) (string, string) {
	var href, count string

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode &amp;&amp; c.Data == linkTag {
			href = getAttribute(c, linkAttr)
			count = extractTextByClass(c, countTag, countClass)
		}
	}

	return href, count
}

// extractTextByClass finds text within an element of a specific class
func extractTextByClass(n *html.Node, tag, class string) string {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode &amp;&amp; c.Data == tag {
			if getAttribute(c, &#34;class&#34;) == class {
				return getText(c)
			}
		}
	}
	return &#34;&#34;
}

// getAttribute returns the value of a given attribute
func getAttribute(n *html.Node, key string) string {
	for _, attr := range n.Attr {
		if attr.Key == key {
			return attr.Val
		}
	}
	return &#34;&#34;
}

// getText retrieves all text from a node
func getText(n *html.Node) string {
	if n.Type == html.TextNode {
		return strings.TrimSpace(n.Data)
	}

	var text string
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		text += getText(c)
	}
	return strings.TrimSpace(text)
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request url get parameter" value="// ?token=
r.URL.Query().Get(&#34;token&#34;),

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request get form value" value="email := r.FormValue(&#34;email&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer header etag" value="// Generate ETag for dynamic content
etag := generateETag(content)
w.Header().Set(&#34;ETag&#34;, etag)

// Compare with the ETag in the request
if match := r.Header.Get(&#34;If-None-Match&#34;); match != &#34;&#34; &amp;&amp; match == etag {
    w.WriteHeader(http.StatusNotModified)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request method post (not allow if not post)" value="if r.Method != http.MethodPost {
    w.Header().Set(&#34;Allow&#34;, &#34;POST&#34;)
    http.Error(w, &#34;Method Not Allowed&#34;, http.StatusMethodNotAllowed)
    return

}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request get url parametr as integer" value="parse url parameter as int (/ciao?id=1)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request base url path" value="//   / 			 =&gt; /
//   /ciao 		 =&gt; ciao
//   /ciao/Andrei   =&gt; Andrei
local := path.Base(r.URL.Path)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="request isAuth (is authenticated)" value="user, ok := r.Context().Value(&#34;auth&#34;).(User)
if !ok || !user.IsAuth {
    setFlash(w, flashCookie, &#34;Please login&#34;)
    http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer header no cahce" value="w.Header().Set(&#34;Cache-Control&#34;, &#34;no-cache, no-store, must-revalidate&#34;)
w.Header().Set(&#34;Pragma&#34;, &#34;no-cache&#34;)
w.Header().Set(&#34;Expires&#34;, &#34;0&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer header set html" value="w.Header().Set(&#34;Content-Type&#34;, &#34;text/html&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer header set redirect" value="w.Header().Set(&#34;Location&#34;, &#34;http://google.com&#34;)
w.WriteHeader(302)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer serve favicon" value="func handleFavicon(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, &#34;static/favicon.ico&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer serve file" value="w.Header().Set(&#34;Vary&#34;, &#34;Accept-Encoding&#34;)
w.Header().Set(&#34;Cache-Control&#34;, &#34;public, max-age=7776000&#34;)
http.ServeFile(w, r, &#34;manifest.json&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer write json" value="w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;)
post := &amp;Post{
    User:    &#34;Sau Sheong&#34;,
    Threads: []string{&#34;first&#34;, &#34;second&#34;, &#34;third&#34;},
}
json, _ := json.Marshal(post)
w.Write(json)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="handler example" value="func homeHandler(w http.ResponseWriter, r *http.Request) {
	renderHTMLAuthFlashCSRF(w, r, &#34;pages/index.html&#34;, nil)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="handler login" value="http.HandleFunc(&#34;/login&#34;, loginHandler)

func loginHandler(w http.ResponseWriter, r *http.Request) {
	flashMsg, _ := getFlash(w, r, flashCookie)
	if r.Method == http.MethodGet {
		tmpl := `
		&lt;!DOCTYPE html&gt;
		&lt;html&gt;
		&lt;head&gt;
			&lt;title&gt;Login&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
			&lt;h1&gt;Login&lt;/h1&gt;
			{{if .FlashMsg}}
				&lt;p style=&#34;color: green;&#34;&gt;{{.FlashMsg}}&lt;/p&gt;
			{{end}}
			&lt;a href=&#34;/login&#34;&gt;Login&lt;/a&gt;
			&lt;a href=&#34;/signup&#34;&gt;Signup&lt;/a&gt;
			&lt;a href=&#34;/logout&#34;&gt;Logout&lt;/a&gt;
			&lt;form action=&#34;/login&#34; method=&#34;post&#34;&gt;
				{{ .csrfField }}
				&lt;input type=&#34;email&#34; name=&#34;email&#34; placeholder=&#34;Email&#34; required&gt;
				&lt;input type=&#34;password&#34; name=&#34;password&#34; placeholder=&#34;Password&#34; required&gt;
				&lt;button type=&#34;submit&#34;&gt;Login&lt;/button&gt;
			&lt;/form&gt;
			&lt;a href=&#34;/change-password&#34;&gt;Forgot password?&lt;/a&gt;
		&lt;/body&gt;
		&lt;/html&gt;`

		data := map[string]interface{}{
			csrf.TemplateTag: csrf.TemplateField(r),
			&#34;FlashMsg&#34;:       flashMsg,
		}

		err := RenderTemplateInline(w, tmpl, data)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try letter&#34;, http.StatusInternalServerError)
		}
		return
	} else if r.Method == http.MethodPost {
		user := User{
			Email:    r.FormValue(&#34;email&#34;),
			Password: r.FormValue(&#34;password&#34;),
		}

		var hashedPassword string
		err := dbAuth.QueryRow(&#34;SELECT password FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;hashedPassword)
		if err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password)) != nil {
			setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
			http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
			return
		}

		// Create a JWT
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			&#34;email&#34;: user.Email,
			&#34;exp&#34;:   time.Now().Add(24 * 30 * time.Hour).Unix(),
		})

		// Sign the JWT with a secret key
		tokenString, err := token.SignedString([]byte(secretKey))
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		// Set the JWT in an HTTP-only cookie
		http.SetCookie(w, &amp;http.Cookie{
			Name:     &#34;jwt&#34;,
			Value:    tokenString,
			Expires:  time.Now().Add(24 * time.Hour),
			HttpOnly: true,
			Secure:   true, // Enable in production (HTTPS only)
		})
		setFlash(w, flashCookie, &#34;Login successful!&#34;)
		http.Redirect(w, r, &#34;/&#34;, http.StatusSeeOther)
	}
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="handler logout" value="http.HandleFunc(&#34;/logout&#34;, logoutHandler)

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	// Clear the JWT cookie by setting an expired cookie with the same name
	http.SetCookie(w, &amp;http.Cookie{
		Name:     &#34;jwt&#34;,
		Value:    &#34;&#34;,
		Expires:  time.Now().Add(-time.Hour), // Set the expiration time in the past
		HttpOnly: true,
		Secure:   true, // Enable in production (HTTPS only)
	})

	setFlash(w, flashCookie, &#34;You have been logged out.&#34;)
	http.Redirect(w, r, &#34;/&#34;, http.StatusSeeOther)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="handler password reset" value="&#34;github.com/domodwyer/mailyak/v3&#34;

const domain = &#34;http://localhost:8080&#34;

http.HandleFunc(&#34;/change-password&#34;, changePasswordHandler)
http.HandleFunc(&#34;/reset-password&#34;, resetPasswordHandler)

func changePasswordHandler(w http.ResponseWriter, r *http.Request) {
	flashMsg, _ := getFlash(w, r, flashCookie)

	if r.Method == http.MethodGet {
		tmpl := `
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Change Password&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Change Password&lt;/h1&gt;
			{{if .FlashMsg}}
                &lt;p style=&#34;color: green;&#34;&gt;{{.FlashMsg}}&lt;/p&gt;
            {{end}}
            &lt;a href=&#34;/login&#34;&gt;Login&lt;/a&gt;
            &lt;a href=&#34;/signup&#34;&gt;Signup&lt;/a&gt;
            &lt;a href=&#34;/logout&#34;&gt;Logout&lt;/a&gt;
            &lt;form action=&#34;/change-password&#34; method=&#34;post&#34;&gt;
                {{ .csrfField }}
                &lt;input type=&#34;email&#34; name=&#34;email&#34; placeholder=&#34;Email&#34; required&gt;
                &lt;button type=&#34;submit&#34;&gt;Change Password&lt;/button&gt;
            &lt;/form&gt;
        &lt;/body&gt;
        &lt;/html&gt;`

		data := map[string]interface{}{
			csrf.TemplateTag: csrf.TemplateField(r),
			&#34;FlashMsg&#34;:       flashMsg,
		}

		err := RenderTemplateInline(w, tmpl, data)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
		}
	} else if r.Method == http.MethodPost {
		email := r.FormValue(&#34;email&#34;)
		var exists bool
		err := dbAuth.QueryRow(&#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, email).Scan(&amp;exists)
		if err != nil || !exists {
			setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
			return
		}

		resetToken, err := encryptToken(email, []byte(secretKey))
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		// Send a password reset email
		resetLink := fmt.Sprintf(domain+&#34;/reset-password?token=%s&amp;email=%s&#34;, resetToken, email)
		//go sendResetEmail(email, resetLink)
		go sendResetPassword(email, resetLink)

		http.SetCookie(w, &amp;http.Cookie{
			Name:     &#34;reset_token&#34;,
			Value:    resetToken,
			Expires:  time.Now().Add(1 * time.Hour),
			HttpOnly: true,
			Secure:   true,
		})

		setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
		http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
	}
}

func resetPasswordHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		tmpl := `
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Reset Password&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Reset Password&lt;/h1&gt;
            {{if .FlashMsg}}
                &lt;p style=&#34;color: green;&#34;&gt;{{.FlashMsg}}&lt;/p&gt;
            {{end}}
            &lt;a href=&#34;/login&#34;&gt;Login&lt;/a&gt;
            &lt;a href=&#34;/signup&#34;&gt;Signup&lt;/a&gt;
            &lt;a href=&#34;/logout&#34;&gt;Logout&lt;/a&gt;
            &lt;form action=&#34;/reset-password&#34; method=&#34;post&#34;&gt;
				{{ .csrfField }}
                &lt;input type=&#34;hidden&#34; name=&#34;token&#34; value=&#34;{{.Token}}&#34;&gt;
                &lt;input type=&#34;password&#34; name=&#34;password&#34; placeholder=&#34;New Password&#34; required&gt;
                &lt;button type=&#34;submit&#34;&gt;Reset Password&lt;/button&gt;
            &lt;/form&gt;
        &lt;/body&gt;
        &lt;/html&gt;`
		flash, _ := getFlash(w, r, flashCookie)
		data := map[string]interface{}{
			csrf.TemplateTag: csrf.TemplateField(r),
			&#34;FlashMsg&#34;:       flash,
			&#34;Token&#34;:          r.URL.Query().Get(&#34;token&#34;),
		}

		if data[&#34;Token&#34;] == nil {
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
		}

		err := RenderTemplateInline(w, tmpl, data)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
		}
		return
	} else if r.Method == http.MethodPost {
		token := r.FormValue(&#34;token&#34;)
		newPassword := r.FormValue(&#34;password&#34;)

		email, err := decryptToken(token, []byte(secretKey))
		if err != nil {
			setFlash(w, flashCookie, &#34;Invalid or expired token&#34;)
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
			return
		}

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		_, err = dbAuth.Exec(&#34;UPDATE users SET password = ? WHERE email = ?&#34;, string(hashedPassword), email)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		setFlash(w, flashCookie, &#34;Password reset successful!&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
	}
}

func sendResetPassword(email, link string) error {
	// Create a new email - specify the SMTP host:port and auth (if needed)
	mail := mailyak.New(&#34;smtp.mail.me.com:587&#34;, smtp.PlainAuth(&#34;&#34;, &#34;andreinita@icloud.com&#34;, &#34;kqfp-sdar-bxzw-awfu&#34;, &#34;smtp.mail.me.com&#34;))

	mail.To(email)
	mail.From(&#34;andreinita@icloud.com&#34;)
	mail.FromName(&#34;Localhost&#34;)

	mail.Subject(&#34;Password Reset&#34;)

	// Or set the body using a string setter
	mail.Plain().Set(&#34;Click the link to reset your password: &#34; + link)

	// And you&#39;re done!
	if err := mail.Send(); err != nil {
		return err
	}
	return nil
}

func encryptToken(email string, secretKey []byte) (string, error) {
	plaintext := []byte(email + &#34;|&#34; + time.Now().Add(1*time.Hour).Format(time.RFC3339))
	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return &#34;&#34;, err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}

func decryptToken(token string, secretKey []byte) (string, error) {
	ciphertext, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return &#34;&#34;, err
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) &lt; nonceSize {
		return &#34;&#34;, fmt.Errorf(&#34;ciphertext too short&#34;)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return &#34;&#34;, err
	}

	parts := strings.SplitN(string(plaintext), &#34;|&#34;, 2)
	if len(parts) != 2 {
		return &#34;&#34;, fmt.Errorf(&#34;invalid token format&#34;)
	}

	expiry, err := time.Parse(time.RFC3339, parts[1])
	if err != nil {
		return &#34;&#34;, err
	}

	if time.Now().After(expiry) {
		return &#34;&#34;, fmt.Errorf(&#34;token has expired&#34;)
	}

	return parts[0], nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="handler signup" value="http.HandleFunc(&#34;/signup&#34;, signupHandler)

func signupHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		tmpl := `
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Signup&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Signup&lt;/h1&gt;
		&lt;a href=&#34;/login&#34;&gt;Login&lt;/a&gt;
		&lt;a href=&#34;/signup&#34;&gt;Signup&lt;/a&gt;
		&lt;a href=&#34;/logout&#34;&gt;Logout&lt;/a&gt;
		&lt;form action=&#34;/signup&#34; method=&#34;post&#34;&gt;
			{{ .csrfField }}
			&lt;input type=&#34;email&#34; name=&#34;email&#34; placeholder=&#34;Email&#34; required&gt;
			&lt;input type=&#34;password&#34; name=&#34;password&#34; placeholder=&#34;Password&#34; required&gt;
			&lt;button type=&#34;submit&#34;&gt;Signup&lt;/button&gt;
		&lt;/form&gt;
	&lt;/body&gt;
	&lt;/html&gt;`

		data := map[string]interface{}{
			csrf.TemplateTag: csrf.TemplateField(r),
		}

		err := RenderTemplateInline(w, tmpl, data)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try letter&#34;, http.StatusInternalServerError)
		}
		return
	} else if r.Method == http.MethodPost {
		user := User{
			Email:    r.FormValue(&#34;email&#34;),
			Password: r.FormValue(&#34;password&#34;),
		}

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		_, err = dbAuth.Exec(&#34;INSERT INTO users (email, password) VALUES (?, ?)&#34;, user.Email, string(hashedPassword))
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		setFlash(w, flashCookie, &#34;Account successfully created! Please login&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http csrf" value="const secretKey = &#34;&lt;!32trentadue!&gt;&lt;!treizecisidoi!&gt;&#34; // 32 characters as required by csrf

// Set up CSRF protection
CSRF := csrf.Protect(
    []byte(secretKey),  // Replace with a secure key
    csrf.Secure(false), // TODO: Set to true in production (HTTPS only)
)

// Graceful shutdown handling
server := http.Server{Addr: &#34;:8080&#34;}
server.Handler = CSRF(http.DefaultServeMux)

go func() {
    fmt.Println(&#34;Starting server @ http://localhost:8080&#34;)
    if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
        log.Fatalf(&#34;Server failed: %v&#34;, err)
    }
}()

stop := make(chan os.Signal, 1)
signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

&lt;-stop
log.Println(&#34;Shutting down server...&#34;)
if err := server.Close(); err != nil {
    log.Fatalf(&#34;Server shutdown error: %v&#34;, err)
}
log.Println(&#34;Server gracefully stopped.&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http get url" value="resp, err := http.Get(&#34;https://andrei.website&#34;)
if err != nil {
    // TODO
}
b, err := ioutil.ReadAll(resp.Body)
defer resp.Body.Close()
if err != nil {
    // TODO
}
fmt.Printf(&#34;%s&#34;, b)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http get url data with cookie and token from browser" value="var codestichUsername string
var codestichPassword string
var codestichSession string
var xsrfToken string
var scrapData = false

func init() {
	codestichUsername = os.Getenv(&#34;codestichUsername&#34;)
	if codestichUsername == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichUsername is not set&#34;)
	}

	codestichPassword = os.Getenv(&#34;codestichPassword&#34;)
	if codestichPassword == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichPassword is not set&#34;)
	}

	// Retrieve session and XSRF tokens from environment variables
	codestichSession = os.Getenv(&#34;codestich_session&#34;)
	if codestichSession == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestich_session is not set&#34;)
	}

	xsrfToken = os.Getenv(&#34;XSRF_TOKEN&#34;)
	if xsrfToken == &#34;&#34; {
		log.Fatal(&#34;Environment variable XSRF_TOKEN is not set&#34;)
	}
}

req, err := http.NewRequest(&#34;GET&#34;, pageLink, nil)
if err != nil {
    log.Fatalln(err)
}
// Manually set the Cookie header using the values retrieved from your browser.
// Depending on the site&#39;s requirements, you might need to include additional cookies.
cookieHeader := fmt.Sprintf(&#34;codestitch_session=%s; XSRF-TOKEN=%s&#34;, codestichSession, xsrfToken)
req.Header.Set(&#34;Cookie&#34;, cookieHeader)

// Set a typical browser User-Agent header.
req.Header.Set(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124&#34;)

// Optionally, add Referer and Origin headers if needed.
req.Header.Set(&#34;Referer&#34;, &#34;https://codestitch.app/login&#34;)
req.Header.Set(&#34;Origin&#34;, &#34;https://codestitch.app&#34;)

client := &amp;http.Client{}
resp, err := client.Do(req)
if err != nil {
    log.Fatalln(err)
}
defer resp.Body.Close()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http get url with password" value="username := &#34;your_username&#34;
password := &#34;your_password&#34;
auth := &#34;Basic &#34; + base64.StdEncoding.EncodeToString([]byte(username+&#34;:&#34;+password))

req, err := http.NewRequest(&#34;GET&#34;, pageLink, nil)
if err != nil {
    log.Fatalln(err)
}
req.Header.Add(&#34;Authorization&#34;, auth)

client := &amp;http.Client{}
resp, err := client.Do(req)
if err != nil {
    log.Fatalln(err)
}
defer resp.Body.Close()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http handle with handler (ServeHTTP)" value="type HelloHandler struct{}

func (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &#34;Hello!&#34;)
}

hello := HelloHandler{}
http.Handle(&#34;/hello&#34;, &amp;hello)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http handle with handlerfunc" value="type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&#34;$%.2f&#34;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	for item, price := range db {
		fmt.Fprintf(w, &#34;%s: %s\n&#34;, item, price)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&#34;item&#34;)
	price, ok := db[item]
	if !ok {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &#34;no such item: %q\n&#34;, item)
		return
	}
	fmt.Fprintf(w, &#34;%s\n&#34;, price)
}

db := database{&#34;shoes&#34;: 50, &#34;socks&#34;: 5}
http.Handle(&#34;/list&#34;, http.HandlerFunc(db.list))
http.Handle(&#34;/price&#34;, http.HandlerFunc(db.price))
log.Fatal(http.ListenAndServe(&#34;localhost:8000&#34;, nil))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http hanler (ServeHTTP)" value="type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&#34;$%.2f&#34;, d) }

type database map[string]dollars

//!+handler
func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case &#34;/list&#34;:
		for item, price := range db {
			fmt.Fprintf(w, &#34;%s: %s\n&#34;, item, price)
		}
	case &#34;/price&#34;:
		item := req.URL.Query().Get(&#34;item&#34;)
		price, ok := db[item]
		if !ok {
			w.WriteHeader(http.StatusNotFound) // 404
			fmt.Fprintf(w, &#34;no such item: %q\n&#34;, item)
			return
		}
		fmt.Fprintf(w, &#34;%s\n&#34;, price)
	default:
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &#34;no such page: %s\n&#34;, req.URL)
	}
}

db := database{&#34;shoes&#34;: 50, &#34;socks&#34;: 5}
log.Fatal(http.ListenAndServe(&#34;localhost:8000&#34;, db))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http https production" value="// production SSL: &#34;golang.org/x/crypto/acme/autocert&#34;
http.HandleFunc(&#34;/&#34;, home)

// production SSL
certManager := autocert.Manager{
    Prompt:     autocert.AcceptTOS,
    HostPolicy: autocert.HostWhitelist(fmt.Sprint(&#34;andrei.website&#34;)), // Your domain here
    Cache:      autocert.DirCache(&#34;certs&#34;),                             // Folder for storing certificates
}

// starting up the server
httpsServer := &amp;http.Server{
    Addr:           server.Config.PortSSL,
    TLSConfig:      &amp;tls.Config{GetCertificate: certManager.GetCertificate},
    //Handler:        new(middlewares.GzipMiddleware),
    ReadTimeout:    time.Duration(60 * int64(time.Second)),
    WriteTimeout:   time.Duration(60 * int64(time.Second)),
    MaxHeaderBytes: 1 &lt;&lt; 20,
}

go httpsServer.ListenAndServeTLS(&#34;&#34;, &#34;&#34;)
log.Fatalln(http.ListenAndServe(&#34;:http&#34;, certManager.HTTPHandler(nil)))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http https production and localhost (needs improvment)" value="package main

import (
	&#34;crypto/tls&#34;
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;os&#34;
	&#34;time&#34;

	&#34;github.com/andrei/_skeleton/middlewares&#34;
	&#34;github.com/andrei/_skeleton/routes&#34;
	&#34;github.com/andrei/_skeleton/server&#34;
	&#34;github.com/andrei/_skeleton/server/dev&#34;
	&#34;golang.org/x/crypto/acme/autocert&#34;
)

func init() {
	if server.Config.Dev.IsActive {
		if _, err := os.Stat(&#34;server/dev/cert.pem&#34;); os.IsNotExist(err) {
			// file does not exist
			dev.GenerateSSL4Dev()
			fmt.Println(&#34; SSL for localhost created&#34;)
			fmt.Println(&#34; Add server/dev/cert.pem to keychain certificates and always trust&#34;)
		}
	}
	fmt.Printf(&#34;Navigate to: http://%s\n&#34;, server.Config.Host)
}

func main() {

	// routes
	http.HandleFunc(&#34;/&#34;, routes.Home)
	//http.HandleFunc(&#34;/favicon.ico&#34;, routes.FaviconHandler)
	http.HandleFunc(&#34;/robots.txt&#34;, routes.RobotsText)

	// static files
	http.Handle(&#34;/public/&#34;, middlewares.Cache(http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.Dir(&#34;static/public&#34;)))))

	// localhost SSL
	if server.Config.Dev.IsActive {
		httpServer := &amp;http.Server{
			Addr:           server.Config.Port,
			Handler:        http.HandlerFunc(redirectToHTTPS),
			ReadTimeout:    time.Duration(60 * int64(time.Second)),
			WriteTimeout:   time.Duration(60 * int64(time.Second)),
			MaxHeaderBytes: 1 &lt;&lt; 20,
		}

		// starting up the server
		httpsServer := &amp;http.Server{
			Addr:           server.Config.PortSSL,
			Handler:        new(middlewares.GzipMiddleware),
			ReadTimeout:    time.Duration(60 * int64(time.Second)),
			WriteTimeout:   time.Duration(60 * int64(time.Second)),
			MaxHeaderBytes: 1 &lt;&lt; 20,
		}

		go httpsServer.ListenAndServeTLS(&#34;server/dev/cert.pem&#34;, &#34;server/dev/key.pem&#34;)
		log.Fatalln(httpServer.ListenAndServe())
	}

	// production SSL
	certManager := autocert.Manager{
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist(fmt.Sprint(server.Config.Host)), // Your domain here
		Cache:      autocert.DirCache(&#34;certs&#34;),                             // Folder for storing certificates
	}

	// starting up the server
	httpsServer := &amp;http.Server{
		Addr:           server.Config.PortSSL,
		TLSConfig:      &amp;tls.Config{GetCertificate: certManager.GetCertificate},
		Handler:        new(middlewares.GzipMiddleware),
		ReadTimeout:    time.Duration(60 * int64(time.Second)),
		WriteTimeout:   time.Duration(60 * int64(time.Second)),
		MaxHeaderBytes: 1 &lt;&lt; 20,
	}

	go httpsServer.ListenAndServeTLS(&#34;&#34;, &#34;&#34;)
	log.Fatalln(http.ListenAndServe(&#34;:http&#34;, certManager.HTTPHandler(nil)))
}

// redirectToHTTPS redirects HTTP connections to HTTPS on localhost
func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, &#34;https://&#34;+server.Config.Host+server.Config.PortSSL+r.RequestURI, http.StatusMovedPermanently)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http redirect to ssl" value="url := &#34;https://&#34; + r.Host + r.URL.String()
http.Redirect(w, r, url, http.StatusMovedPermanently)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http serve static from folder" value="http.Handle(&#34;/static&#34;, http.StripPrefix(&#34;/static/&#34;, http.FileServer(http.Dir(&#34;static&#34;))))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http serve static with embedd" value="//go:embed public/*
var publicFiles embed.FS

publicFiles, err := fs.Sub(publicFiles, &#34;public&#34;)
if err != nil {
    log.Fatal(err)
}

http.Handle(&#34;/public/&#34;, http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.FS(publicFiles))))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="http with graceful shutdown" value="/* index functionality */
http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
    // TODO
})

// Graceful shutdown handling
server := &amp;http.Server{Addr: &#34;:8000&#34;}

go func() {
    log.Println(&#34;Starting server on :8000&#34;)
    if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
        log.Fatalf(&#34;Server failed: %v&#34;, err)
    }
}()

stop := make(chan os.Signal, 1)
signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

&lt;-stop
log.Println(&#34;Shutting down server...&#34;)
if err := server.Close(); err != nil {
    log.Fatalf(&#34;Server shutdown error: %v&#34;, err)
}
log.Println(&#34;Server gracefully stopped.&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="htttp and https localhost" value="// localhost SSL
localhost := true

http.HandleFunc(&#34;/&#34;, home)

if localhost {
    httpServer := &amp;http.Server{
        Addr: &#34;:80&#34;,
        Handler:        http.HandlerFunc(redirectToHTTPS),
        ReadTimeout:    time.Duration(60 * int64(time.Second)),
        WriteTimeout:   time.Duration(60 * int64(time.Second)),
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }

    httpsServer := &amp;http.Server{
        Addr: &#34;:443&#34;,
        //Handler:        new(middlewares.GzipMiddleware),
        ReadTimeout:    time.Duration(60 * int64(time.Second)),
        WriteTimeout:   time.Duration(60 * int64(time.Second)),
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }

    go log.Fatalln(httpsServer.ListenAndServeTLS(&#34;cert.pem&#34;, &#34;key.pem&#34;))
    log.Fatalln(httpServer.ListenAndServe())
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="server get ip" value="func getIP() string {
	host, _ := os.Hostname()
	addrs, _ := net.LookupIP(host)
	ip := &#34;&#34;
	for _, addr := range addrs {
		if ipv4 := addr.To4(); ipv4 != nil {
			if ipv4.String() == &#34;127.0.0.1&#34; {
				continue
			}
			ip = ipv4.String()
			break
		}
	}
	return ip
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="url join" value="func joinURL(base, relative string) (string, error) {
	baseURL, err := url.Parse(base)
	if err != nil {
		return &#34;&#34;, fmt.Errorf(&#34;error parsing base URL: %v&#34;, err)
	}

	relativePath := strings.TrimSpace(relative)
	relativeURL, err := url.Parse(relativePath)
	if err != nil {
		return &#34;&#34;, fmt.Errorf(&#34;error parsing relative URL: %v&#34;, err)
	}

	finalURL := baseURL.ResolveReference(relativeURL)
	return finalURL.String(), nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="url parameter for no cache" value="dynamicURL := &#34;/content?&#34; + time.Now().UnixNano()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="context check if authenticated" value="user, ok := r.Context().Value(&#34;auth&#34;).(db.User)
if !ok || user.Email == &#34;&#34; {
    cookies.FlashSetWithRedirect(w, r, &#34;Please login&#34;, &#34;/login&#34;)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="cookie package" value="package cookies

import (
	&#34;crypto/aes&#34;
	&#34;crypto/cipher&#34;
	&#34;crypto/hmac&#34;
	&#34;crypto/rand&#34;
	&#34;crypto/sha256&#34;
	&#34;encoding/base64&#34;
	&#34;errors&#34;
	&#34;fmt&#34;
	&#34;io&#34;
	&#34;net/http&#34;
	&#34;strings&#34;
)

var (
	ErrValueTooLong = errors.New(&#34;cookie value too long&#34;)
	ErrInvalidValue = errors.New(&#34;invalid cookie value&#34;)
)

func Write(w http.ResponseWriter, cookie http.Cookie) error {
	cookie.Value = base64.URLEncoding.EncodeToString([]byte(cookie.Value))

	if len(cookie.String()) &gt; 4096 {
		return ErrValueTooLong
	}

	http.SetCookie(w, &amp;cookie)

	return nil
}

func Read(r *http.Request, name string) (string, error) {
	cookie, err := r.Cookie(name)
	if err != nil {
		return &#34;&#34;, err
	}

	value, err := base64.URLEncoding.DecodeString(cookie.Value)
	if err != nil {
		return &#34;&#34;, ErrInvalidValue
	}

	return string(value), nil
}

func WriteSigned(w http.ResponseWriter, cookie http.Cookie, secretKey string) error {
	mac := hmac.New(sha256.New, []byte(secretKey))
	mac.Write([]byte(cookie.Name))
	mac.Write([]byte(cookie.Value))
	signature := mac.Sum(nil)

	cookie.Value = string(signature) + cookie.Value

	return Write(w, cookie)
}

func ReadSigned(r *http.Request, name string, secretKey string) (string, error) {
	signedValue, err := Read(r, name)
	if err != nil {
		return &#34;&#34;, err
	}

	if len(signedValue) &lt; sha256.Size {
		return &#34;&#34;, ErrInvalidValue
	}

	signature := signedValue[:sha256.Size]
	value := signedValue[sha256.Size:]

	mac := hmac.New(sha256.New, []byte(secretKey))
	mac.Write([]byte(name))
	mac.Write([]byte(value))
	expectedSignature := mac.Sum(nil)

	if !hmac.Equal([]byte(signature), expectedSignature) {
		return &#34;&#34;, ErrInvalidValue
	}

	return value, nil
}

func WriteEncrypted(w http.ResponseWriter, cookie http.Cookie, secretKey string) error {
	block, err := aes.NewCipher([]byte(secretKey))
	if err != nil {
		return err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	_, err = io.ReadFull(rand.Reader, nonce)
	if err != nil {
		return err
	}

	plaintext := fmt.Sprintf(&#34;%s:%s&#34;, cookie.Name, cookie.Value)

	encryptedValue := aesGCM.Seal(nonce, nonce, []byte(plaintext), nil)

	cookie.Value = string(encryptedValue)

	return Write(w, cookie)
}

func ReadEncrypted(r *http.Request, name string, secretKey string) (string, error) {
	encryptedValue, err := Read(r, name)
	if err != nil {
		return &#34;&#34;, err
	}

	block, err := aes.NewCipher([]byte(secretKey))
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonceSize := aesGCM.NonceSize()

	if len(encryptedValue) &lt; nonceSize {
		return &#34;&#34;, ErrInvalidValue
	}

	nonce := encryptedValue[:nonceSize]
	ciphertext := encryptedValue[nonceSize:]

	plaintext, err := aesGCM.Open(nil, []byte(nonce), []byte(ciphertext), nil)
	if err != nil {
		return &#34;&#34;, ErrInvalidValue
	}

	expectedName, value, ok := strings.Cut(string(plaintext), &#34;:&#34;)
	if !ok {
		return &#34;&#34;, ErrInvalidValue
	}

	if expectedName != name {
		return &#34;&#34;, ErrInvalidValue
	}

	return value, nil
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="cookie set flash and get flash" value="const flashCookie = &#34;flash&#34;

// setFlash sets a flash message in a cookie
func setFlash(w http.ResponseWriter, name, value string) {
	c := &amp;http.Cookie{
		Name:     name,
		Value:    value,
		Path:     &#34;/&#34;,
		MaxAge:   1, // The cookie will be deleted after 1 second
		HttpOnly: true,
		Secure:   true,
	}
	http.SetCookie(w, c)
}

// getFlash retrieves and clears a flash message from a cookie
func getFlash(w http.ResponseWriter, r *http.Request, name string) (string, error) {
	c, err := r.Cookie(name)
	if err != nil {
		switch err {
		case http.ErrNoCookie:
			return &#34;&#34;, nil // No flash message
		default:
			return &#34;&#34;, err
		}
	}

	// Clear the cookie
	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Path:     &#34;/&#34;,
		MaxAge:   -1, // Delete the cookie
		HttpOnly: true,
		Secure:   true,
	})

	return c.Value, nil
}

setFlash(w, flashCookie, &#34;Invalid credentials&#34;)

flashMsg, _ := getFlash(w, r, flashCookie)

data := map[string]interface{}{
    &#34;FlashMsg&#34;:  flashMsg,
}

{{if .FlashMsg}}
    &lt;p style=&#34;color: green;&#34;&gt;{{.FlashMsg}}&lt;/p&gt;
{{end}}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="cookies and flash (package)" value="package cookies

import (
	&#34;encoding/base64&#34;
	&#34;net/http&#34;
	&#34;play/internals/config&#34;
	&#34;time&#34;
)

// Configurable settings (inject via config package or constants)
var (
	secureCookies bool
)

func init() {
	if config.Config.IsProd {
		secureCookies = true
	}
}

// Set sets a secure cookie with optional expiration.
func Set(w http.ResponseWriter, name, value string, expiry time.Time) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Value:    base64.URLEncoding.EncodeToString([]byte(value)),
		Path:     &#34;/&#34;,
		Domain:   config.Config.Domain,
		Expires:  expiry,
		Secure:   secureCookies,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	})
}

// Get retrieves a cookie by name without modifying it.
func Get(r *http.Request, name string) (*http.Cookie, error) {
	return r.Cookie(name)
}

func GetValue(r *http.Request, name string) (string, error) {
	cookie, err := r.Cookie(name)
	if err != nil {
		return &#34;&#34;, err
	}

	value, err := base64.URLEncoding.DecodeString(cookie.Value)
	if err != nil {
		return &#34;&#34;, err
	}

	return string(value), nil
}

// Delete removes a cookie immediately.
func Delete(w http.ResponseWriter, name string) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Path:     &#34;/&#34;,
		Domain:   config.Config.Domain,
		MaxAge:   -1,
		Secure:   secureCookies,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	})
}

// FlashSet sets a short-lived flash cookie.
func FlashSet(w http.ResponseWriter, name, value string) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Value:    base64.URLEncoding.EncodeToString([]byte(value)),
		Path:     &#34;/&#34;,
		Domain:   config.Config.Domain,
		MaxAge:   10,
		Secure:   secureCookies,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	})
}

// FlashGet retrieves a flash message and deletes it in the same request cycle.
func FlashGet(w http.ResponseWriter, r *http.Request, name string) (string, error) {
	cookie, err := r.Cookie(name)
	if err != nil {
		if err == http.ErrNoCookie {
			return &#34;&#34;, nil
		}
		return &#34;&#34;, err
	}

	// Immediately clear after reading
	Delete(w, name)

	value, err := base64.URLEncoding.DecodeString(cookie.Value)
	if err != nil {
		return &#34;&#34;, err
	}

	return string(value), nil
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="url get query parameter" value="r.URL.Query().Get(&#34;token&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="url extract path" value="r.RequestURI
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="writer serve favicon from embedded" value="mux.HandleFunc(&#34;/favicon.ico&#34;, func(w http.ResponseWriter, r *http.Request) {
file, readErr := f.ReadFile(&#34;assets/favicon.ico&#34;)
if readErr != nil {
    slog.Warn(&#34;Failed to read favicon.ico&#34;, &#34;error&#34;, readErr, &#34;path&#34;, r.URL.Path)
    http.NotFound(w, r)
    return
}
w.Header().Set(&#34;Content-Type&#34;, &#34;image/x-icon&#34;)
w.Write(file)
})
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet app" value="package main

import (
	&#34;database/sql&#34;
	_ &#34;embed&#34;
	&#34;fmt&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
	&#34;io&#34;
	&#34;log&#34;
	&#34;os&#34;
	&#34;time&#34;
)

const isProduction = false

var db *sql.DB
var logger *log.Logger

type Component struct {
	ID        int    `json:&#34;id&#34;`
	URL       string `json:&#34;url&#34;`
	Name      string `json:&#34;name&#34;`
	HTML      string `json:&#34;html&#34;`
	JS        string `json:&#34;js&#34;`
	CSS       string `json:&#34;css&#34;`
	Less      string `json:&#34;less&#34;`
	Sass      string `json:&#34;sass&#34;`
	CSSDark   string `json:&#34;css_dark&#34;`
	LessDark  string `json:&#34;less_dark&#34;`
	SassDark  string `json:&#34;sass_dark&#34;`
	CreatedAt string `json:&#34;created_at&#34;`
	UpdatedAt string `json:&#34;updated_at&#34;`
}

func initDB() {
	var err error
	db, err = sql.Open(&#34;sqlite3&#34;, &#34;file:codestich.db?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to open database: %v&#34;, err)
	}

	// Configure connection pool
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(25)
	db.SetConnMaxLifetime(5 * time.Minute)

	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS components (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			url TEXT UNIQUE NOT NULL,
			name TEXT NOT NULL,
			html TEXT NOT NULL,
			js TEXT NOT NULL,
			css TEXT NOT NULL,
			less TEXT NOT NULL,
			sass TEXT NOT NULL,
			css_dark TEXT NOT NULL,
			less_dark TEXT NOT NULL,
			sass_dark TEXT NOT NULL,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		);
	`)
	if err != nil {
		log.Fatal(err)
	}
}

func closeDB() {
	err := db.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(&#34;Closing database without errors&#34;)
}

func main() {
	// Open a file for logging
	file, err := os.OpenFile(&#34;logfile.log&#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf(&#34;Failed to open log file: %v&#34;, err)
	}
	defer file.Close()

	// Create a multi-writer to log to both file and stdout
	var multiWriter io.Writer
	if !isProduction {
		multiWriter = io.MultiWriter(file, os.Stdout)
	} else {
		multiWriter = file
	}

	// Create a new logger
	logger = log.New(multiWriter, &#34;&#34;, log.LstdFlags)

	initDB()
	defer closeDB()
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet boileprlate + auth system" value="package main

import (
	&#34;context&#34;
	&#34;crypto/aes&#34;
	&#34;crypto/cipher&#34;
	&#34;crypto/rand&#34;
	&#34;crypto/tls&#34;
	&#34;database/sql&#34;
	_ &#34;embed&#34;
	&#34;encoding/base64&#34;
	&#34;errors&#34;
	&#34;fmt&#34;
	&#34;github.com/NYTimes/gziphandler&#34;
	&#34;github.com/fsnotify/fsnotify&#34;
	&#34;github.com/gorilla/csrf&#34;
	&#34;github.com/gorilla/websocket&#34;
	&#34;golang.org/x/crypto/acme/autocert&#34;
	&#34;html/template&#34;
	&#34;io&#34;
	&#34;io/fs&#34;
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;net/smtp&#34;
	&#34;os&#34;
	&#34;os/signal&#34;
	&#34;path/filepath&#34;
	&#34;runtime&#34;
	&#34;strings&#34;
	&#34;sync&#34;
	&#34;syscall&#34;
	&#34;time&#34;
	&#34;unicode&#34;

	&#34;golang.org/x/crypto/bcrypt&#34;

	&#34;github.com/domodwyer/mailyak/v3&#34;
	&#34;github.com/golang-jwt/jwt&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
)

const isProduction = false
const domain = &#34;http://localhost:8080&#34;

// rate limit middleware
const rateLimitDuration = 1 * time.Minute // Time frame for rate limiting
const maxRequests = 100                   // Maximum number of requests per time frame

// rate limit signup
const rateLimitDurationSignup = 1 * time.Minute // Time frame for rate limiting
const maxRequestsSignup = 1                     // Maximum number of requests per time frame

const flashCookie = &#34;flash&#34;
const tokenCookieValidate = &#34;token_validate&#34;

const levelInfo = &#34;info&#34;
const levelWarning = &#34;warning&#34;
const levelError = &#34;error&#34;

var secretKey string
var smtpPass string
var smtpUser string

//go:embed reload.html
var reloadHtmlFile []byte

var dbAuth *sql.DB
var logger *log.Logger

// templates
var templates *template.Template
var templateDir = &#34;app/src&#34;
var templateFiles = make(map[string]bool)

// websocket
var upgrader = websocket.Upgrader{}
var connections = make(map[*websocket.Conn]bool)
var mu sync.Mutex

// rate limit middleware
var muRateLimit sync.Mutex
var rateLimitMap = make(map[string]int)

// signupRateLimitMax
var muSignupRateLimit sync.Mutex
var rateSignupLimitMap = make(map[string]int)

type User struct {
	Id        string    `json:&#34;id&#34;`
	IsAuth    bool      `json:&#34;isAuth&#34;`
	Email     string    `json:&#34;email&#34;`
	Password  string    `json:&#34;password&#34;`
	UserType  string    `json:&#34;user_type&#34;`
	Verified  bool      `json:&#34;verified&#34;`
	CreatedAt time.Time `json:&#34;created_at&#34;`
	UpdatedAt time.Time `json:&#34;updated_at&#34;`
}

func init() {
	// Attempt to load the secret key from the environment variable.
	secretKey = os.Getenv(&#34;secretKey&#34;)
	if secretKey == &#34;&#34; {
		log.Fatal(&#34;Environment variable secretKey is not set&#34;)
	}

	// Attempt to load the email password from the environment variable.
	smtpPass = os.Getenv(&#34;smtpPass&#34;)
	if smtpPass == &#34;&#34; {
		log.Fatal(&#34;Environment variable emailPassword is not set&#34;)
	}

	smtpUser = os.Getenv(&#34;smtpUser&#34;)
	if smtpUser == &#34;&#34; {
		log.Fatal(&#34;Environment variable emailPassword is not set&#34;)
	}

	fmt.Println(&#34;Successfully loaded secretKey and emailPassword from environment variables&#34;)
}

func watchDirectory(directory string) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	err = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			if err := watcher.Add(path); err != nil {
				log.Printf(&#34;Error watching directory: %s, %v&#34;, path, err)
			} else {
				fmt.Println(&#34;Watching:&#34;, path)
			}
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(&#34;Watching directory:&#34;, directory)
	for {
		select {
		case event, ok := &lt;-watcher.Events:
			if !ok {
				return
			}
			if event.Op&amp;(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 &amp;&amp; strings.HasSuffix(event.Name, &#34;.html&#34;) {
				fmt.Println(&#34;HTML file changed:&#34;, event.Name)
				if err := loadTemplates(); err != nil {
					log.Println(&#34;Failed to reload templates:&#34;, err)
				}
				notifyClients()
			}
			if event.Op&amp;fsnotify.Create == fsnotify.Create {
				fileInfo, err := os.Stat(event.Name)
				if err == nil &amp;&amp; fileInfo.IsDir() {
					watcher.Add(event.Name)
					fmt.Println(&#34;Added new directory to watch:&#34;, event.Name)
				}
			}
		case err, ok := &lt;-watcher.Errors:
			if !ok {
				return
			}
			log.Println(&#34;Error watching files:&#34;, err)
		}
	}
}

func renderHTML(w http.ResponseWriter, page string, data map[string]interface{}) {
	err := templates.ExecuteTemplate(w, page, data)
	if err != nil {
		logToFileWithCaller(levelError, err.Error())
		http.Error(w, &#34;Please try letter&#34;, http.StatusInternalServerError)
	}
}

// renderHTMLAuthFlashCSRF renders the html checking for authentication and flash cookie
func renderHTMLAuthFlashCSRF(w http.ResponseWriter, r *http.Request, page string, data map[string]interface{}) {
	if data == nil {
		data = make(map[string]interface{})
	}

	// Retrieve authentication details from the context
	user, ok := r.Context().Value(&#34;auth&#34;).(User)
	if !ok {
		http.Error(w, &#34;Unauthorized&#34;, http.StatusUnauthorized)
		return
	}

	flashMsg, _ := getFlash(w, r, flashCookie)

	data[&#34;UserEmail&#34;] = user.Email
	data[&#34;UserType&#34;] = user.UserType
	data[&#34;UserVerified&#34;] = user.Verified
	data[&#34;IsAuth&#34;] = user.IsAuth
	data[&#34;FlashMsg&#34;] = flashMsg
	data[csrf.TemplateTag] = csrf.TemplateField(r)

	err := templates.ExecuteTemplate(w, page, data)
	if err != nil {
		logToFileWithCaller(levelError, err.Error())
		http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
	}
}

func loadTemplates() error {
	tmpl := template.New(&#34;&#34;)

	err := filepath.WalkDir(templateDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) == &#34;.html&#34; {
			relPath, err := filepath.Rel(templateDir, path)
			if err != nil {
				return err
			}
			relPath = filepath.ToSlash(relPath) // Ensure cross-platform compatibility
			if strings.HasPrefix(relPath, &#34;pages/&#34;) {
				templateFiles[relPath] = true
			}
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			_, err = tmpl.New(relPath).Parse(string(content))
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		return err
	}
	templates = tmpl
	log.Println(&#34;Templates reloaded successfully.&#34;)
	return nil
}

func notifyClients() {
	mu.Lock()
	defer mu.Unlock()
	for conn := range connections {
		err := conn.WriteMessage(websocket.TextMessage, []byte(&#34;reload&#34;))
		if err != nil {
			log.Println(&#34;Deleting connection:&#34;, err)
			conn.Close()
			delete(connections, conn)
		}
	}
}

// CORS Middleware
func cors(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := domain
		if isProduction {
			origin = &#34;https://&#34; + strings.TrimPrefix(domain, &#34;http://&#34;)
		}
		w.Header().Set(&#34;Access-Control-Allow-Origin&#34;, origin)
		w.Header().Set(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;)
		if r.Method == &#34;OPTIONS&#34; {
			w.Header().Set(&#34;Access-Control-Allow-Methods&#34;, &#34;GET, POST, PUT, DELETE, OPTIONS&#34;)
			w.Header().Set(&#34;Access-Control-Allow-Headers&#34;, &#34;Content-Type, X-CSRF-Token&#34;)
			w.Header().Set(&#34;Access-Control-Max-Age&#34;, &#34;86400&#34;)
			w.WriteHeader(http.StatusNoContent)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func securityHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&#34;Strict-Transport-Security&#34;, &#34;max-age=63072000; includeSubDomains; preload&#34;)
		w.Header().Set(&#34;X-Content-Type-Options&#34;, &#34;nosniff&#34;)
		if isProduction {
			w.Header().Set(&#34;X-Frame-Options&#34;, &#34;DENY&#34;)
		}
		w.Header().Set(&#34;X-XSS-Protection&#34;, &#34;0&#34;) // Deprecated, modern browsers ignore it
		w.Header().Set(&#34;Content-Security-Policy&#34;, &#34;default-src &#39;self&#39;; style-src &#39;self&#39; &#39;unsafe-inline&#39;&#34;)
		w.Header().Set(&#34;Referrer-Policy&#34;, &#34;strict-origin-when-cross-origin&#34;)
		next.ServeHTTP(w, r)
	})
}

// Error Handling Middleware
func errorHandling(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()
		next.ServeHTTP(w, r)
	})
}

// Example Rate Limiting Middleware
func rateLimiting(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		muRateLimit.Lock()
		defer muRateLimit.Unlock()

		clientIP := r.RemoteAddr
		count, exists := rateLimitMap[clientIP]

		if exists &amp;&amp; count &gt;= maxRequests {
			http.Error(w, &#34;Rate limit exceeded. Please try again later.&#34;, http.StatusTooManyRequests)
			return
		}

		if !exists {
			go resetRateLimit(clientIP)
		}

		rateLimitMap[clientIP]++
		//fmt.Println(&#34;Rate Limit Logic: &#34;, clientIP, rateLimitMap[clientIP])
		next.ServeHTTP(w, r)
	})
}

func resetRateLimit(clientIP string) {
	time.Sleep(rateLimitDuration)
	muRateLimit.Lock()
	defer muRateLimit.Unlock()
	delete(rateLimitMap, clientIP)
}

func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cookie, err := r.Cookie(&#34;jwt&#34;)
		if err != nil {
			ctx := context.WithValue(r.Context(), &#34;auth&#34;, User{})
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Parse and validate the JWT
		token, err := jwt.Parse(cookie.Value, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf(&#34;invalid signing method&#34;)
			}
			return []byte(secretKey), nil
		})
		if err != nil || !token.Valid {
			ctx := context.WithValue(r.Context(), &#34;auth&#34;, User{})
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Extract claims from the JWT
		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			ctx := context.WithValue(r.Context(), &#34;auth&#34;, User{})
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Check expiration
		if exp, ok := claims[&#34;exp&#34;].(float64); ok &amp;&amp; time.Now().Unix() &gt; int64(exp) {
			ctx := context.WithValue(r.Context(), &#34;auth&#34;, User{})
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// Create User struct from claims
		authData := User{
			Email:    claims[&#34;email&#34;].(string),
			UserType: claims[&#34;user_type&#34;].(string),
			Verified: claims[&#34;verified&#34;].(bool),
			IsAuth:   claims[&#34;isAuth&#34;].(bool),
		}

		// Attach the auth data to the request context
		ctx := context.WithValue(r.Context(), &#34;auth&#34;, authData)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// Custom logger to include file and line number
func logToFileWithCaller(level string, msg string) {
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = &#34;unknown&#34;
		line = 0
	}
	logger.Printf(&#34;%s: %s [%s:%d]\n&#34;, level, msg, file, line)
}

func initAuthDB() {
	var err error
	dbAuth, err = sql.Open(&#34;sqlite3&#34;, &#34;file:auth.db?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to open database: %v&#34;, err)
	}

	// Configure connection pool
	dbAuth.SetMaxOpenConns(25)
	dbAuth.SetMaxIdleConns(25)
	dbAuth.SetConnMaxLifetime(5 * time.Minute)

	_, err = dbAuth.Exec(`
		CREATE TABLE IF NOT EXISTS users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email TEXT UNIQUE NOT NULL,
			password TEXT NOT NULL,
			user_type TEXT NOT NULL DEFAULT &#39;user&#39;, -- Can be &#39;admin&#39;, &#39;user&#39;, etc
			verified BOOLEAN NOT NULL DEFAULT 0,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		);
	`)
	if err != nil {
		log.Fatal(err)
	}
}

func closeAuthDB() {
	err := dbAuth.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(&#34;Closing database without errors&#34;)
}

func setCookie(w http.ResponseWriter, name, value string, expiry time.Time) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Value:    value,
		Expires:  expiry,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})
}

func getCookie(w http.ResponseWriter, r *http.Request, name string) (*http.Cookie, error) {
	cookie, err := r.Cookie(name)
	if err != nil {
		return nil, err
	}
	setCookie(w, name, &#34;&#34;, time.Now().Add(-1*time.Hour))
	return cookie, nil
}

// setFlash sets a flash message in a cookie
func setFlash(w http.ResponseWriter, name, value string) {
	c := &amp;http.Cookie{
		Name:     name,
		Value:    value,
		Path:     &#34;/&#34;,
		MaxAge:   10, // The cookie will be deleted after 10 seconds
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	}
	http.SetCookie(w, c)
}

// getFlash retrieves and clears a flash message from a cookie
func getFlash(w http.ResponseWriter, r *http.Request, name string) (string, error) {
	c, err := r.Cookie(name)
	if err != nil {
		switch err {
		case http.ErrNoCookie:
			return &#34;&#34;, nil // No flash message
		default:
			return &#34;&#34;, err
		}
	}

	http.SetCookie(w, &amp;http.Cookie{
		Name:     name,
		Path:     &#34;/&#34;,
		MaxAge:   -1, // Delete the cookie
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	return c.Value, nil
}

func encryptToken(email string, secretKey []byte) (string, error) {
	plaintext := []byte(email + &#34;|&#34; + time.Now().Add(1*time.Hour).Format(time.RFC3339))
	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return &#34;&#34;, err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}

func decryptToken(token string, secretKey []byte) (string, error) {
	ciphertext, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return &#34;&#34;, err
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) &lt; nonceSize {
		return &#34;&#34;, fmt.Errorf(&#34;ciphertext too short&#34;)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return &#34;&#34;, err
	}

	parts := strings.SplitN(string(plaintext), &#34;|&#34;, 2)
	if len(parts) != 2 {
		return &#34;&#34;, fmt.Errorf(&#34;invalid token format&#34;)
	}

	expiry, err := time.Parse(time.RFC3339, parts[1])
	if err != nil {
		return &#34;&#34;, err
	}

	if time.Now().After(expiry) {
		return &#34;&#34;, fmt.Errorf(&#34;token has expired&#34;)
	}

	return parts[0], nil
}

func verifyTokens(token1, token2 string) (string, error) {
	email1, err := decryptToken(token1, []byte(secretKey))
	if err != nil {
		return &#34;&#34;, err
	}

	email2, err := decryptToken(token2, []byte(secretKey))
	if err != nil {
		return &#34;&#34;, err
	}

	if email1 != email2 {
		return &#34;&#34;, errors.New(&#34;tokens don&#39;t match&#34;)
	}
	return email1, nil
}

func emailSendLink(email, link string) error {
	// Create a new email - specify the SMTP host:port and auth (if needed)
	mail := mailyak.New(&#34;smtp.mail.me.com:587&#34;, smtp.PlainAuth(&#34;&#34;, smtpUser, smtpPass, &#34;smtp.mail.me.com&#34;))

	mail.To(email)
	mail.From(smtpUser)
	mail.FromName(&#34;Localhost&#34;)

	mail.Subject(&#34;Password Reset&#34;)

	// Or set the body using a string setter
	mail.Plain().Set(&#34;Click the link to reset your password: &#34; + link)

	// And you&#39;re done!
	if err := mail.Send(); err != nil {
		return err
	}
	return nil
}

// verifyUserEmail sends a verification email: verifyUserEmail(w, user, &#34;/urlPath&#34;)
func verifyUserEmail(w http.ResponseWriter, email, urlPath string) error {
	resetToken, err := encryptToken(email, []byte(secretKey))
	if err != nil {
		logToFileWithCaller(levelError, err.Error())
		return err
	}

	// Send a password reset email
	resetLink := fmt.Sprintf(domain+urlPath+&#34;?token=%s&#34;, resetToken)
	setCookie(w, tokenCookieValidate, resetToken, time.Now().Add(1*time.Hour)) // TODO: insert to verification_tokens

	if isProduction {
		go func() {
			err = emailSendLink(email, resetLink)
			if err != nil {
				logToFileWithCaller(levelError, err.Error())
				setCookie(w, tokenCookieValidate, &#34;&#34;, time.Now().Add(-time.Hour))
			}
		}()
	} else {
		logToFileWithCaller(levelInfo, resetLink)
	}
	return err
}

func signupRateLimitMax(r *http.Request) {
	muSignupRateLimit.Lock()
	defer muSignupRateLimit.Unlock()

	clientIP := r.RemoteAddr
	_, exists := rateSignupLimitMap[clientIP]

	if !exists {
		go resetSignupRateLimit(clientIP)
	}

	rateSignupLimitMap[clientIP]++
}

func checkSignupRateLimit(r *http.Request) bool {
	muSignupRateLimit.Lock()
	defer muSignupRateLimit.Unlock()
	clientIP := r.RemoteAddr
	count, exists := rateSignupLimitMap[clientIP]
	if exists &amp;&amp; count &gt;= maxRequestsSignup {
		return true
	}
	return false
}

func resetSignupRateLimit(clientIP string) {
	time.Sleep(rateLimitDurationSignup)
	muSignupRateLimit.Lock()
	defer muSignupRateLimit.Unlock()
	delete(rateSignupLimitMap, clientIP)
}

func checkPasswordStrength(password string) bool {
	if len(password) &lt; 12 {
		return false
	}
	var hasUpper, hasLower, hasNumber, hasSpecial bool
	for _, r := range password {
		switch {
		case unicode.IsUpper(r):
			hasUpper = true
		case unicode.IsLower(r):
			hasLower = true
		case unicode.IsNumber(r):
			hasNumber = true
		case unicode.IsPunct(r) || unicode.IsSymbol(r):
			hasSpecial = true
		}
	}
	return hasUpper &amp;&amp; hasLower &amp;&amp; hasNumber &amp;&amp; hasSpecial
}

func main() {
	// Open a file for logging
	file, err := os.OpenFile(&#34;logfile.log&#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		log.Fatalf(&#34;Failed to open log file: %v&#34;, err)
	}
	defer file.Close()

	// Create a multi-writer to log to both file and stdout
	var multiWriter io.Writer
	if !isProduction {
		multiWriter = io.MultiWriter(file, os.Stdout)
	} else {
		multiWriter = file
	}

	// Create a new logger
	logger = log.New(multiWriter, &#34;&#34;, log.LstdFlags)

	initAuthDB()
	defer closeAuthDB()

	if err := loadTemplates(); err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.Handle(&#34;/public/&#34;, http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.Dir(&#34;./public&#34;))))
	mux.HandleFunc(&#34;/favicon.ico&#34;, func(w http.ResponseWriter, r *http.Request) { // avoid duplicate request
		http.ServeFile(w, r, &#34;./public/favicon.ico&#34;)
	})

	mux.HandleFunc(&#34;/&#34;, homeHandler)
	mux.HandleFunc(&#34;/login&#34;, loginHandler)
	mux.HandleFunc(&#34;/signup&#34;, signupHandler)
	mux.HandleFunc(&#34;/logout&#34;, logoutHandler)
	mux.HandleFunc(&#34;/change-password&#34;, changePasswordHandler)
	mux.HandleFunc(&#34;/reset-password&#34;, resetPasswordHandler)
	mux.HandleFunc(&#34;/delete-account&#34;, deleteAccountHandler)
	mux.HandleFunc(&#34;/confirm-account&#34;, confirmAccountHandler)
	mux.HandleFunc(&#34;/make-admin&#34;, makeAdminHandler)
	mux.HandleFunc(&#34;/users&#34;, getAllUsersHandler)

	mux.HandleFunc(&#34;/blog/&#34;, handleDynamic)

	var handler http.Handler = mux
	handler = gziphandler.GzipHandler(handler)
	handler = cors(handler)
	handler = securityHeaders(handler)
	handler = errorHandling(handler)
	//handler = rateLimiting(handler)
	handler = authMiddleware(handler)
	CSRF := csrf.Protect(
		[]byte(secretKey),
		csrf.Secure(isProduction),
	)
	handler = CSRF(handler)

	server := &amp;http.Server{
		Addr:           &#34;:8080&#34;,
		Handler:        handler,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   15 * time.Second,
		IdleTimeout:    60 * time.Second,
		MaxHeaderBytes: 1 &lt;&lt; 20, // 1MB
	}

	if !isProduction {
		go watchDirectory(templateDir)

		mux.HandleFunc(&#34;/ws&#34;, func(w http.ResponseWriter, r *http.Request) {
			upgrader.CheckOrigin = func(r *http.Request) bool { return true }
			conn, err := upgrader.Upgrade(w, r, nil)
			if err != nil {
				log.Println(&#34;WebSocket upgrade error:&#34;, err)
				return
			}

			mu.Lock()
			connections[conn] = true
			mu.Unlock()

			fmt.Println(&#34;New WebSocket connection&#34;)
		})

		mux.HandleFunc(&#34;/reload&#34;, func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set(&#34;Content-Type&#34;, &#34;text/html&#34;)
			w.Write(reloadHtmlFile)
		})

		go func() {
			log.Println(&#34;Starting server on :8080&#34;)
			if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
				log.Fatalf(&#34;Server failed: %v&#34;, err)
			}
		}()
	} else { // production
		// Set up autocert for Let&#39;s Encrypt
		m := autocert.Manager{
			Prompt:     autocert.AcceptTOS,
			HostPolicy: autocert.HostWhitelist(domain),
			Cache:      autocert.DirCache(&#34;/var/www/.cache&#34;), // Ensure this directory is writable
		}

		// Start HTTP server on port 80 for challenges and redirection
		go func() {
			http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) { // &#39;/&#39; is set on http (and not mux)
				target := &#34;https://&#34; + r.Host + r.URL.Path
				if r.URL.RawQuery != &#34;&#34; {
					target += &#34;?&#34; + r.URL.RawQuery
				}
				http.Redirect(w, r, target, http.StatusPermanentRedirect)
			})
			log.Fatal(http.ListenAndServe(&#34;:80&#34;, m.HTTPHandler(nil)))
		}()

		server.Addr = &#34;:443&#34;
		server.Handler = handler
		server.TLSConfig = &amp;tls.Config{GetCertificate: m.GetCertificate}

		go func() {
			log.Println(&#34;Starting secure server on :443&#34;)
			if err := server.ListenAndServeTLS(&#34;&#34;, &#34;&#34;); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
				log.Fatalf(&#34;Server failed: %v&#34;, err)
			}
		}()
	}

	// Graceful shutdown handling
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	&lt;-stop
	log.Println(&#34;Shutting down server...&#34;)
	if err := server.Close(); err != nil {
		log.Fatalf(&#34;Server shutdown error: %v&#34;, err)
	}
	log.Println(&#34;Server gracefully stopped.&#34;)
}

func handleDynamic(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, &#34;/&#34;)
	path = filepath.ToSlash(path) // Ensure cross-platform compatibility
	templateFile := fmt.Sprintf(&#34;pages/%s.html&#34;, path)

	if ok := templateFiles[templateFile]; !ok {
		if strings.HasSuffix(path, &#34;/&#34;) {
			path += &#34;index&#34; // route is like /blog/tennis/
		} else {
			path += &#34;/index&#34; // route is like /blog/tennis
		}
		templateFile = fmt.Sprintf(&#34;pages/%s.html&#34;, path)
	}

	renderHTMLAuthFlashCSRF(w, r, templateFile, nil)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	renderHTMLAuthFlashCSRF(w, r, &#34;pages/index.html&#34;, nil)
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/login.html&#34;, nil)
		return
	}

	if r.Method == http.MethodPost {
		user := User{
			Email:    r.FormValue(&#34;email&#34;),
			Password: r.FormValue(&#34;password&#34;),
		}

		var dbUser struct {
			Password string
			UserType string
			Verified bool
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		err := dbAuth.QueryRowContext(ctx, &#34;SELECT password, user_type, verified FROM users WHERE email = ?&#34;, user.Email).
			Scan(&amp;dbUser.Password, &amp;dbUser.UserType, &amp;dbUser.Verified)
		if err != nil || bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(user.Password)) != nil {
			setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
			http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
			return
		}

		// Check if account is verified
		if !dbUser.Verified {
			// Send verification email again
			if err = verifyUserEmail(w, user.Email, &#34;/confirm-account&#34;); err != nil {
				logToFileWithCaller(levelError, err.Error())
				http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
				return
			}
			setFlash(w, flashCookie, &#34;Account not verified. We&#39;ve sent a new verification email.&#34;)
			http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
			return
		}

		// Create a JWT with additional claims
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			&#34;email&#34;:     user.Email,
			&#34;user_type&#34;: dbUser.UserType,
			&#34;verified&#34;:  dbUser.Verified,
			&#34;isAuth&#34;:    true,
			&#34;iat&#34;:       time.Now().Unix(),                          // Issued at
			&#34;exp&#34;:       time.Now().Add(24 * 30 * time.Hour).Unix(), // Expiry (30 days)
			&#34;nbf&#34;:       time.Now().Unix(),                          // Not before
		})

		// Sign the JWT with a strong secret key
		tokenString, err := token.SignedString([]byte(secretKey))
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		// Set the JWT in a secure cookie
		setCookie(w, &#34;jwt&#34;, tokenString, time.Now().Add(24*time.Hour))
		setFlash(w, flashCookie, &#34;Login successful!&#34;)

		http.Redirect(w, r, &#34;/&#34;, http.StatusSeeOther)
	}
}

func signupHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/signup.html&#34;, nil)
		return
	} else if r.Method == http.MethodPost {
		if checkSignupRateLimit(r) {
			setFlash(w, flashCookie, &#34;Too many attempts to signup. Please try again after 24 hours.&#34;)
			http.Redirect(w, r, &#34;/signup&#34;, http.StatusSeeOther)
			return
		}

		user := User{
			Email:    r.FormValue(&#34;email&#34;),
			Password: r.FormValue(&#34;password&#34;),
		}

		// TODO: validate email

		if !checkPasswordStrength(user.Password) {
			setFlash(w, flashCookie, &#34;Password must be at least 8 characters long and contain at least one uppercase letter and one lowercase letter.&#34;)
			http.Redirect(w, r, &#34;/signup&#34;, http.StatusSeeOther)
			return
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		tx, err := dbAuth.BeginTx(ctx, nil)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		var exists bool
		err = tx.QueryRowContext(ctx, &#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;exists)
		if err != nil {
			tx.Rollback()
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		if exists {
			err = tx.QueryRowContext(ctx, &#34;SELECT verified FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;user.Verified)
			if err != nil {
				tx.Rollback()
				logToFileWithCaller(levelError, err.Error())
				http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
				return
			}
			if user.Verified {
				tx.Rollback()
				setFlash(w, flashCookie, &#34;Login! An account with the provided email address already exists.&#34;)
				http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
				return
			}
		}

		if !exists {
			hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
			if err != nil {
				tx.Rollback()
				logToFileWithCaller(levelError, err.Error())
				http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
				return
			}

			_, err = tx.ExecContext(ctx, &#34;INSERT INTO users (email, password) VALUES (?, ?)&#34;, user.Email, string(hashedPassword))
			if err != nil {
				tx.Rollback()
				logToFileWithCaller(levelError, err.Error())
				http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
				return
			}

			// TODO: insert into verification_tokens
		}

		if err = verifyUserEmail(w, user.Email, &#34;/confirm-account&#34;); err != nil {
			tx.Rollback()
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		err = tx.Commit()
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		signupRateLimitMax(r)

		setFlash(w, flashCookie, &#34;An activation email has been sent to your provided email address.&#34;)
		http.Redirect(w, r, &#34;/signup&#34;, http.StatusSeeOther)
	}
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	// Clear the JWT cookie by setting an expired cookie with the same name
	setCookie(w, &#34;jwt&#34;, &#34;&#34;, time.Now().Add(-time.Hour))
	setFlash(w, flashCookie, &#34;Successfully logout&#34;)
	http.Redirect(w, r, &#34;/&#34;, http.StatusSeeOther)
}

func changePasswordHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/change-password.html&#34;, nil)
		return
	} else if r.Method == http.MethodPost {
		email := r.FormValue(&#34;email&#34;)

		var exists bool
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		err := dbAuth.QueryRowContext(ctx, &#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, email).Scan(&amp;exists)
		if err != nil || !exists {
			setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
			return
		}

		if err = verifyUserEmail(w, email, &#34;/reset-password&#34;); err != nil {
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
		http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
	}
}

func resetPasswordHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		data := map[string]interface{}{
			&#34;Token&#34;: r.URL.Query().Get(&#34;token&#34;),
		}

		if data[&#34;Token&#34;] == nil {
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
		}

		renderHTMLAuthFlashCSRF(w, r, &#34;pages/reset-password.html&#34;, data)
		return
	} else if r.Method == http.MethodPost {
		token := r.FormValue(&#34;token&#34;)
		newPassword := r.FormValue(&#34;password&#34;)
		tokenFromCookie, err := getCookie(w, r, &#34;reset_token&#34;)
		if err != nil {
			setFlash(w, flashCookie, &#34;Invalid or expired token&#34;)
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
			return
		}

		email, err := verifyTokens(token, tokenFromCookie.Value)
		if err != nil || email == &#34;&#34; {
			setFlash(w, flashCookie, &#34;Invalid or expired token&#34;)
			http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
			return
		}

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err = dbAuth.ExecContext(ctx, &#34;UPDATE users SET password = ? WHERE email = ?&#34;, string(hashedPassword), email)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		setFlash(w, flashCookie, &#34;Password reset successful!&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
	}
}

func getAllUsersHandler(w http.ResponseWriter, r *http.Request) {
	user, ok := r.Context().Value(&#34;auth&#34;).(User)
	if !ok || !user.IsAuth {
		setFlash(w, flashCookie, &#34;Please login&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	rows, err := dbAuth.QueryContext(ctx, &#34;SELECT id, email, user_type FROM users&#34;)
	if err != nil {
		logToFileWithCaller(levelError, err.Error())
		http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var user User
		if err := rows.Scan(&amp;user.Id, &amp;user.Email, &amp;user.UserType); err != nil {
			logToFileWithCaller(levelError, err.Error())
			continue
		}
		users = append(users, user)
	}

	data := map[string]interface{}{
		&#34;users&#34;: users,
	}

	renderHTMLAuthFlashCSRF(w, r, &#34;pages/users.html&#34;, data)
}

func deleteAccountHandler(w http.ResponseWriter, r *http.Request) {
	user, ok := r.Context().Value(&#34;auth&#34;).(User)
	if !ok || !user.IsAuth {
		setFlash(w, flashCookie, &#34;Please login&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
		return
	}
	if r.Method == http.MethodGet {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/delete-user.html&#34;, nil)
		return
	} else if r.Method == http.MethodPost {
		email := r.FormValue(&#34;email&#34;)
		password := r.FormValue(&#34;password&#34;)
		emailFromContext := user.Email

		if email != emailFromContext {
			setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
			http.Redirect(w, r, &#34;/delete-account&#34;, http.StatusSeeOther)
			return
		}

		// check password with database password
		var hashedPassword string
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		err := dbAuth.QueryRowContext(ctx, &#34;SELECT password FROM users WHERE email = ?&#34;, email).Scan(&amp;hashedPassword)
		if err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) != nil {
			setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
			http.Redirect(w, r, &#34;/delete-account&#34;, http.StatusSeeOther)
			return
		}

		ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err = dbAuth.ExecContext(ctx, &#34;DELETE FROM users WHERE email = ?&#34;, email)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}

		setCookie(w, &#34;jwt&#34;, &#34;&#34;, time.Now().Add(-time.Hour))
		setFlash(w, flashCookie, &#34;User deleted successfully&#34;)

		http.Redirect(w, r, &#34;/&#34;, http.StatusSeeOther)
	}
}

func confirmAccountHandler(w http.ResponseWriter, r *http.Request) {
	tokenFromUrl := r.URL.Query().Get(&#34;token&#34;)
	tokenFromCookie, err := getCookie(w, r, tokenCookieValidate)
	if err != nil || tokenFromUrl == &#34;&#34; || tokenFromUrl != tokenFromCookie.Value {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/confirm-account.html&#34;, nil)
		return
	}

	email, err := verifyTokens(tokenFromUrl, tokenFromCookie.Value)
	if err != nil || email == &#34;&#34; {
		setFlash(w, flashCookie, &#34;Invalid or expired token. Please sign up again to get a new email with a confirmation link.&#34;)
		http.Redirect(w, r, &#34;/signup&#34;, http.StatusSeeOther)
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_, err = dbAuth.ExecContext(ctx, &#34;UPDATE users SET verified = ? WHERE email = ?&#34;, true, email)
	if err != nil {
		logToFileWithCaller(levelError, err.Error())
		http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
		return
	}

	renderHTMLAuthFlashCSRF(w, r, &#34;pages/confirm-account.html&#34;, nil)
}

func makeAdminHandler(w http.ResponseWriter, r *http.Request) {
	user, ok := r.Context().Value(&#34;auth&#34;).(User)
	if !ok || (!user.IsAuth &amp;&amp; user.UserType == &#34;admin&#34;) {
		setFlash(w, flashCookie, &#34;Please login&#34;)
		http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
		return
	}

	if r.Method == http.MethodGet {
		renderHTMLAuthFlashCSRF(w, r, &#34;pages/make-admin.html&#34;, nil)
		return
	} else if r.Method == http.MethodPost {
		email := r.FormValue(&#34;email&#34;)
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err := dbAuth.ExecContext(ctx, &#34;UPDATE users SET user_type = ? WHERE email = ?&#34;, &#34;admin&#34;, email)
		if err != nil {
			logToFileWithCaller(levelError, err.Error())
			http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
			return
		}
		setFlash(w, flashCookie, fmt.Sprintf(&#34;User %s is now an admin&#34;, email))
		http.Redirect(w, r, &#34;/users&#34;, http.StatusSeeOther)
	}
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet boilerplate" value="package main

import (
	&#34;bot/middlewares&#34;
	&#34;context&#34;
	_ &#34;embed&#34;
	&#34;errors&#34;
	&#34;fmt&#34;
	&#34;github.com/fsnotify/fsnotify&#34;
	&#34;github.com/gorilla/websocket&#34;
	&#34;html/template&#34;
	&#34;io&#34;
	&#34;io/fs&#34;
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;os&#34;
	&#34;os/signal&#34;
	&#34;path/filepath&#34;
	&#34;strings&#34;
	&#34;sync&#34;
	&#34;syscall&#34;
	&#34;time&#34;
)

//go:embed reload.html
var reloadHtmlFile []byte

// app
var logger *log.Logger
var templs *template.Template
var pages = make(map[string]bool)

// websocket
var upgrader = websocket.Upgrader{}
var connections = make(map[*websocket.Conn]bool)
var mu sync.Mutex

func init() {
	setupLog(false)
	parseTemplates()
}

func main() {
	// server
	mux := http.NewServeMux()
	mux.Handle(&#34;/public/&#34;, http.StripPrefix(&#34;/public/&#34;, http.FileServer(http.Dir(&#34;public&#34;))))
	mux.HandleFunc(&#34;/favicon.ico&#34;, func(w http.ResponseWriter, r *http.Request) { // avoid duplicate request
		http.ServeFile(w, r, &#34;public/favicon.ico&#34;)
	})

	mux.HandleFunc(&#34;/&#34;, home)
	mux.HandleFunc(&#34;/blog/&#34;, dynamic)

	reloadByWebSocket(mux)

	server := &amp;http.Server{
		Addr:           &#34;:8080&#34;,
		Handler:        middlewares.Recover(mux),
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   15 * time.Second,
		IdleTimeout:    60 * time.Second,
		MaxHeaderBytes: 1 &lt;&lt; 20, // 1MB
	}

	go func() {
		log.Println(&#34;Starting server on :8080&#34;)
		if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
			log.Fatalf(&#34;Server failed: %v&#34;, err)
		}
	}()

	gracefulShutdown(server)
}

func gracefulShutdown(server *http.Server) {
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	&lt;-stop
	log.Println(&#34;Shutting down server...&#34;)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf(&#34;Forced shutdown: %v&#34;, err)
	}
	log.Println(&#34;Server gracefully stopped.&#34;)
}

func watchDirectory(directory string) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	err = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			if err := watcher.Add(path); err != nil {
				log.Printf(&#34;Error watching directory: %s, %v&#34;, path, err)
			} else {
				fmt.Println(&#34;Watching:&#34;, path)
			}
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	eventCache := make(map[string]time.Time)

	for {
		select {
		case event, ok := &lt;-watcher.Events:
			if !ok {
				return
			}
			if event.Op&amp;(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 &amp;&amp; strings.HasSuffix(event.Name, &#34;.html&#34;) {
				now := time.Now()
				if lastEventTime, exists := eventCache[&#34;reload&#34;]; exists &amp;&amp; now.Sub(lastEventTime) &lt; 100*time.Millisecond {
					continue
				}
				eventCache[&#34;reload&#34;] = now
				if err := parseTemplates(); err != nil {
					log.Println(&#34;Failed to reload templates:&#34;, err)
				}
				notifyClients()
			}
			if event.Op&amp;fsnotify.Create == fsnotify.Create {
				fileInfo, err := os.Stat(event.Name)
				if err == nil &amp;&amp; fileInfo.IsDir() {
					watcher.Add(event.Name)
					fmt.Println(&#34;Added new directory to watch:&#34;, event.Name)
				}
			}
		case err, ok := &lt;-watcher.Errors:
			if !ok {
				return
			}
			log.Println(&#34;Error watching files:&#34;, err)
		}
	}
}

func reloadByWebSocket(mux *http.ServeMux) {
	go watchDirectory(&#34;html&#34;)

	mux.HandleFunc(&#34;/ws&#34;, func(w http.ResponseWriter, r *http.Request) {
		upgrader.CheckOrigin = func(r *http.Request) bool { return true }
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			log.Println(&#34;WebSocket upgrade error:&#34;, err)
			return
		}

		mu.Lock()
		connections[conn] = true
		mu.Unlock()

		fmt.Println(&#34;New WebSocket connection&#34;)
	})

	mux.HandleFunc(&#34;/reload&#34;, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&#34;Content-Type&#34;, &#34;text/html&#34;)
		w.Write(reloadHtmlFile)
	})
}

func notifyClients() {
	mu.Lock()
	defer mu.Unlock()
	for conn := range connections {
		err := conn.WriteMessage(websocket.TextMessage, []byte(&#34;reload&#34;))
		if err != nil {
			log.Println(&#34;Deleting connection:&#34;, err)
			conn.Close()
			delete(connections, conn)
		}
	}
}

func parseTemplates() error {
	templs = template.New(&#34;&#34;)

	err := filepath.WalkDir(&#34;html&#34;, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) == &#34;.html&#34; {
			relPath, err := filepath.Rel(&#34;html&#34;, path)
			if err != nil {
				return err
			}
			relPath = filepath.ToSlash(relPath) // Ensure cross-platform compatibility
			if strings.HasPrefix(relPath, &#34;pages/&#34;) {
				pages[relPath] = true
			}
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			_, err = templs.New(relPath).Parse(string(content))
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		return err
	}
	log.Println(&#34;Templates reloaded successfully.&#34;)
	return nil
}

// setupLog creates and returns a new *log.Logger instance and a cleanup function.
// Logs are written to both app.log and stdout unless production is true.
func setupLog(production bool) (cleanup func(), err error) {
	var logFile *os.File
	logFile, err = os.OpenFile(&#34;bot.log&#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, err
	}

	cleanup = func() {
		if cerr := logFile.Close(); cerr != nil {
			log.Printf(&#34;Error closing log file: %v&#34;, cerr)
		}
	}

	var writer io.Writer
	if production {
		writer = logFile
	} else {
		writer = io.MultiWriter(os.Stdout, logFile)
	}

	logger = log.New(writer, &#34;&#34;, log.Ldate|log.Ltime|log.Lshortfile) // adds timestamp + file:line
	return
}

func renderHTML(w http.ResponseWriter, page string, data map[string]interface{}) {
	err := templs.ExecuteTemplate(w, page, data)
	if err != nil {
		log.Printf(&#34;Error executing template: %v&#34;, err)
		http.Error(w, &#34;Please try letter&#34;, http.StatusInternalServerError)
	}
}

func dynamic(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, &#34;/&#34;)
	path = filepath.ToSlash(path) // Ensure cross-platform compatibility
	templateFile := fmt.Sprintf(&#34;pages/%s.html&#34;, path)

	if ok := pages[templateFile]; !ok {
		if strings.HasSuffix(path, &#34;/&#34;) {
			path += &#34;index&#34; // route is like /blog/tennis/
		} else {
			path += &#34;/index&#34; // route is like /blog/tennis
		}
		templateFile = fmt.Sprintf(&#34;pages/%s.html&#34;, path)
	}

	renderHTML(w, templateFile, nil)
}

func home(w http.ResponseWriter, r *http.Request) {
	renderHTML(w, &#34;pages/index.html&#34;, nil)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet boilerplate app" value="package main

import (
	&#34;database/sql&#34;
	_ &#34;embed&#34;
	&#34;flag&#34;
	&#34;fmt&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
	&#34;io&#34;
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;os&#34;
	&#34;time&#34;
)

var remoteAuth RemoteAuth
var app App

type RemoteAuth struct {
	Username  string
	Password  string
	Session   string
	XSRFToken string
}

type App struct {
	IsProduction     bool
	ReloadFromServer bool
	CodestitchURL    string
}

type Database struct {
	DB     *sql.DB
	DBName string
}

type User struct {
	Email    string `json:&#34;email&#34;`
	Password string `json:&#34;password&#34;`
}

func init() {
	log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)

	remoteAuth.Username = os.Getenv(&#34;codestitchUsername&#34;)
	if remoteAuth.Username == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichUsername is not set&#34;)
	}

	remoteAuth.Password = os.Getenv(&#34;codestitchPassword&#34;)
	if remoteAuth.Password == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichPassword is not set&#34;)
	}

	// Retrieve session and XSRF tokens from environment variables
	remoteAuth.Session = os.Getenv(&#34;codestitch_session&#34;)
	if remoteAuth.Session == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestitch_session is not set&#34;)
	}

	remoteAuth.XSRFToken = os.Getenv(&#34;XSRF_TOKEN&#34;)
	if remoteAuth.XSRFToken == &#34;&#34; {
		log.Fatal(&#34;Environment variable XSRF_TOKEN is not set&#34;)
	}

	app.CodestitchURL = &#34;https://codestitch.app/app/dashboard/catalog/sections/3?perPage=180&amp;page=1&#34;

	flag.BoolVar(&amp;app.IsProduction, &#34;isProduction&#34;, false, &#34;set production mode: -isProduction=true&#34;)
	flag.BoolVar(&amp;app.ReloadFromServer, &#34;reloadFromServer&#34;, false, &#34;set reloadFromServer mode: -reloadFromServer=true&#34;)
	flag.Parse()
}

func (d *Database) Init() {
	var err error
	d.DB, err = sql.Open(&#34;sqlite3&#34;, &#34;file:&#34;+d.DBName+&#34;?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;)
	if err != nil {
		log.Fatalln(&#34;Failed to open database: &#34;, err)
	}

	_, err = d.DB.Exec(`
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL
        );
    `)
	if err != nil {
		d.DB.Close()
		log.Fatalln(&#34;Failed to create table: &#34;, err)
	}

	d.DB.SetMaxOpenConns(25)
	d.DB.SetMaxIdleConns(25)
	d.DB.SetConnMaxIdleTime(5 * time.Minute)
	d.DB.SetConnMaxLifetime(2 * time.Hour)
}

// Close the database connection
func (d *Database) Close() {
	if err := d.DB.Close(); err != nil {
		log.Printf(&#34;Failed to close database: %v&#34;, err)
	} else {
		fmt.Println(&#34;Closing database without errors&#34;)
	}
}

func main() {
	db := Database{DBName: &#34;codestitch.db&#34;}
	db.Init()
	defer db.Close()
	
	// write logic
}

// getHTMLPage returns the HTML content of a given URL
func getHTMLPage(href string) []byte {
	req, err := http.NewRequest(&#34;GET&#34;, href, nil)
	if err != nil {
		log.Fatalln(err)
	}
	// Manually set the Cookie header using the values retrieved from your browser.
	// Depending on the site&#39;s requirements, you might need to include additional cookies.
	cookieHeader := fmt.Sprintf(&#34;codestitch_session=%s; XSRF-TOKEN=%s&#34;, remoteAuth.Session, remoteAuth.XSRFToken)
	req.Header.Set(&#34;Cookie&#34;, cookieHeader)

	// Set a typical browser User-Agent header.
	req.Header.Set(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124&#34;)

	// Optionally, add Referer and Origin headers if needed.
	req.Header.Set(&#34;Referer&#34;, &#34;https://codestitch.app/login&#34;)
	req.Header.Set(&#34;Origin&#34;, &#34;https://codestitch.app&#34;)

	client := &amp;http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		log.Fatalln(&#34;HTTP request failed with status code&#34;, resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	return body
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet boilerplate app gorm" value="package main

import (
	&#34;bytes&#34;
	_ &#34;embed&#34;
	&#34;flag&#34;
	&#34;fmt&#34;
	&#34;github.com/PuerkitoBio/goquery&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
	&#34;gorm.io/driver/sqlite&#34;
	&#34;gorm.io/gorm&#34;
	&#34;io&#34;
	&#34;log&#34;
	&#34;net/http&#34;
	&#34;os&#34;
	&#34;time&#34;
)

var remoteAuth RemoteAuth
var app App

type RemoteAuth struct {
	Username  string
	Password  string
	Session   string
	XSRFToken string
}

type App struct {
	IsProduction     bool
	ReloadFromServer bool
	CodestitchURL    string
}

type Page struct {
	ID       uint `gorm:&#34;primaryKey&#34;`
	Name     string
	URL      string
	PageHTML string
}

type Component struct {
	ID       uint `gorm:&#34;primaryKey&#34;`
	Name     string
	URL      string
	PageHTML string
	CSS      string
	JS       string
	HTML     string
	GoCode   string
}

type Category struct {
	ID    uint `gorm:&#34;primaryKey&#34;`
	Name  string
	Pages []Page `gorm:&#34;many2many:category_pages;&#34;`
}

type CodeStitches struct {
	Categories []Category
	Components []Component
}

type Database struct {
	DB     *gorm.DB
	DBName string
}

func init() {
	log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)

	remoteAuth.Username = os.Getenv(&#34;codestitchUsername&#34;)
	if remoteAuth.Username == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichUsername is not set&#34;)
	}

	remoteAuth.Password = os.Getenv(&#34;codestitchPassword&#34;)
	if remoteAuth.Password == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestichPassword is not set&#34;)
	}

	// Retrieve session and XSRF tokens from environment variables
	remoteAuth.Session = os.Getenv(&#34;codestitch_session&#34;)
	if remoteAuth.Session == &#34;&#34; {
		log.Fatal(&#34;Environment variable codestitch_session is not set&#34;)
	}

	remoteAuth.XSRFToken = os.Getenv(&#34;XSRF_TOKEN&#34;)
	if remoteAuth.XSRFToken == &#34;&#34; {
		log.Fatal(&#34;Environment variable XSRF_TOKEN is not set&#34;)
	}

	app.CodestitchURL = &#34;https://codestitch.app/app/dashboard/catalog/sections/3?perPage=180&amp;page=1&#34;

	flag.BoolVar(&amp;app.IsProduction, &#34;isProduction&#34;, false, &#34;set production mode: -isProduction=true&#34;)
	flag.BoolVar(&amp;app.ReloadFromServer, &#34;reloadFromServer&#34;, false, &#34;set reloadFromServer mode: -reloadFromServer=true&#34;)
	flag.Parse()
}

func (d *Database) Connect() {
	var err error
	d.DB, err = gorm.Open(sqlite.Open(&#34;file:&#34;+d.DBName+&#34;?_cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;), &amp;gorm.Config{})
	if err != nil {
		log.Fatalf(&#34;Failed to connect to database: %v&#34;, err)
	}

	// Get underlying *sql.DB for further configuration
	sqlDB, err := d.DB.DB()
	if err != nil {
		log.Fatalf(&#34;Failed to get SQL DB instance: %v&#34;, err)
	}

	// Set database connection pooling options
	sqlDB.SetMaxOpenConns(10)           // Max 10 open connections
	sqlDB.SetMaxIdleConns(5)            // Max 5 idle connections
	sqlDB.SetConnMaxLifetime(time.Hour) // Recycle connections every hour

	fmt.Println(&#34;Connected to SQLite database:&#34;, d.DBName)
}

func (d *Database) Close() {
	sqlDB, err := d.DB.DB()
	if err != nil {
		log.Printf(&#34;Error getting SQL DB instance for closing: %v&#34;, err)
		return
	}
	sqlDB.Close()
	fmt.Println(&#34;Database connection closed.&#34;)
}

func (d *Database) ExtractLinksFromHTML(htmlFile []byte) {
	/*

		&lt;ul id=&#34;stitch-list&#34;&gt;
		    &lt;li class=&#34;dropdown&#34;&gt;
		        &lt;span class=&#34;category category_toggle&#34;&gt;E-Commerce&lt;/span&gt;
		        &lt;ul class=&#34;child_list&#34;&gt;
		            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/100&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(23)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
		            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/232&#34;&gt;Collections &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
		        &lt;/ul&gt;
		    &lt;/li&gt;
		    &lt;li class=&#34;dropdown&#34;&gt;
		        &lt;span class=&#34;category category_toggle&#34;&gt;Buttons&lt;/span&gt;
		        &lt;ul class=&#34;child_list&#34;&gt;
		            &lt;li&gt;&lt;a href=&#34;https://codestitch.app/app/dashboard/catalog/sections/22&#34;&gt;All &lt;span class=&#34;cat-options&#34;&gt;(11)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
		        &lt;/ul&gt;
		    &lt;/li&gt;
		&lt;/ul&gt;

	*/

	doc, err := goquery.NewDocumentFromReader(bytes.NewReader(htmlFile))
	if err != nil {
		log.Fatalln(&#34;Error loading HTML:&#34;, err)
	}

	doc.Find(&#34;li.dropdown&#34;).Each(func(i int, s *goquery.Selection) {
		name := s.Find(&#34;span.category_toggle&#34;).Text()
		fmt.Println(&#34;Element:&#34;, name)

		// Find sub-items
		s.Find(&#34;ul.child_list a&#34;).Each(func(j int, a *goquery.Selection) {
			href, exists := a.Attr(&#34;href&#34;)
			if exists {
				value := a.Find(&#34;span.cat-options&#34;).Contents().Nodes[0].Data
				fmt.Printf(&#34;  - Link: %s | Value: %s\n&#34;, href, value)
			}
		})
	})
}

func main() {
	db := &amp;Database{DBName: &#34;codestitch.db&#34;}
	db.Connect()
	defer db.Close()
	
	// write logic
	htmlFile := getHTMLPage(app.CodestitchURL)
}

// getHTMLPage returns the HTML content of a given URL
func getHTMLPage(href string) []byte {
	req, err := http.NewRequest(&#34;GET&#34;, href, nil)
	if err != nil {
		log.Fatalln(err)
	}
	// Manually set the Cookie header using the values retrieved from your browser.
	// Depending on the site&#39;s requirements, you might need to include additional cookies.
	cookieHeader := fmt.Sprintf(&#34;codestitch_session=%s; XSRF-TOKEN=%s&#34;, remoteAuth.Session, remoteAuth.XSRFToken)
	req.Header.Set(&#34;Cookie&#34;, cookieHeader)

	// Set a typical browser User-Agent header.
	req.Header.Set(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124&#34;)

	// Optionally, add Referer and Origin headers if needed.
	req.Header.Set(&#34;Referer&#34;, &#34;https://codestitch.app/login&#34;)
	req.Header.Set(&#34;Origin&#34;, &#34;https://codestitch.app&#34;)

	client := &amp;http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		log.Fatalln(&#34;HTTP request failed with status code&#34;, resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	return body
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet email send" value="func emailSendLink(email, link string) error {
	// Create a new email - specify the SMTP host:port and auth (if needed)
	mail := mailyak.New(&#34;smtp.mail.me.com:587&#34;, smtp.PlainAuth(&#34;&#34;, smtpUser, smtpPass, &#34;smtp.mail.me.com&#34;))

	mail.To(email)
	mail.From(smtpUser)
	mail.FromName(&#34;Localhost&#34;)

	mail.Subject(&#34;Password Reset&#34;)

	// Or set the body using a string setter
	mail.Plain().Set(&#34;Click the link to reset your password: &#34; + link)

	// And you&#39;re done!
	if err := mail.Send(); err != nil {
		return err
	}
	return nil
}

// verifyUserEmail sends a verification email: verifyUserEmail(w, user, &#34;/urlPath&#34;)
func verifyUserEmail(w http.ResponseWriter, email, token, urlPath string) (err error) {
	resetLink := fmt.Sprintf(domain+urlPath+&#34;?token=%s&#34;, token)
	if isProduction {
		go func() {
			err = emailSendLink(email, resetLink)
			if err != nil {
				setCookie(w, tokenCookieValidate, &#34;&#34;, time.Now().Add(-time.Hour))
			}
		}()
	} else {
		logToFileWithCaller(levelInfo, resetLink)
	}
	return err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet random key generator" value="func generateKey() []byte {
	randomBytes := make([]byte, 32) // 32 bytes, 256 bit
	numBytesRead, err := rand.Read(randomBytes)
	if err != nil {
		log.Fatal(&#34;Error generating random key.&#34;, err)
	}
	if numBytesRead != 32 {
		log.Fatal(&#34;Error generating 32 random bytes for key.&#34;)
	}
	return randomBytes
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet random number generator" value="seed := time.Now().UnixNano()
r := rand.New(rand.NewSource(seed))
randomNumber := r.Intn(100)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet sentiment analysis" value="&#34;github.com/cdipaolo/sentiment&#34;

model, err := sentiment.Restore()
if err != nil {
    panic(err)
}

var analysis *sentiment.Analysis
var text string

// Negative Example
text = &#34;Your mother is an awful lady&#34;
analysis = model.SentimentAnalysis(text, sentiment.English)
if analysis.Score == 1 {
    log.Printf(&#34;%s - Score of %d = Positive Sentiment\n&#34;, text, analysis.Score)
} else {
    log.Printf(&#34;%s - Score of %d = Negative Sentiment\n&#34;, text, analysis.Score)
}

// Positive Example
text = &#34;Your mother is a lovely lady&#34;
analysis = model.SentimentAnalysis(text, sentiment.English)
if analysis.Score == 1 {
    log.Printf(&#34;%s - Score of %d = Positive Sentiment\n&#34;, text, analysis.Score)
} else {
    log.Printf(&#34;%s - Score of %d = Negative Sentiment\n&#34;, text, analysis.Score)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet validate password" value="func checkPasswordStrength(password string) bool {
	if !isProduction {
		return true
	}
	if len(password) &lt; 12 {
		return false
	}
	var hasUpper, hasLower, hasNumber, hasSpecial bool
	for _, r := range password {
		switch {
		case unicode.IsUpper(r):
			hasUpper = true
		case unicode.IsLower(r):
			hasLower = true
		case unicode.IsNumber(r):
			hasNumber = true
		case unicode.IsPunct(r) || unicode.IsSymbol(r):
			hasSpecial = true
		}
	}
	return hasUpper &amp;&amp; hasLower &amp;&amp; hasNumber &amp;&amp; hasSpecial
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet word count" value="// WordCount function counts the number of occurrences of each word in the given string.
func WordCount(s string) map[string]int {
    // Create a map to store the count of each word.
    wordCount := make(map[string]int)

    // Split the string into words. We consider a word to be a sequence of letters and digits.
    fields := strings.FieldsFunc(s, func(c rune) bool {
        return !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c)
    })

    // Increment the count for each word in the map.
    for _, word := range fields {
        wordCount[word]++
    }

    // Return the map with word counts.
    return wordCount
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet turnstile" value="package security

import (
	&#34;encoding/json&#34;
	&#34;fmt&#34;
	&#34;net/http&#34;
	&#34;net/url&#34;
	&#34;pocketplate/app/filelog&#34;
	&#34;time&#34;
)

const (
	api_endpoint    = &#34;https://challenges.cloudflare.com/turnstile/v0/siteverify&#34;
	default_timeout = 15
)

type turnstile struct {
	SecretKey string
	Timeout   time.Duration
}

type response struct {
	Success     bool      `json:&#34;success&#34;`
	ErrorCodes  []string  `json:&#34;error-codes&#34;`
	ChallengeTs time.Time `json:&#34;challenge_ts&#34;`
	Hostname    string    `json:&#34;hostname&#34;`
}

func (r *response) IsSuccess() bool {
	return r.Success
}

func (r *response) HasErrors() bool {
	return len(r.ErrorCodes) &gt; 0
}

func newTurnstile(secretKey string, timeout int) *turnstile {
	return &amp;turnstile{
		SecretKey: secretKey,
		Timeout:   time.Duration(timeout) * time.Second,
	}
}

func (t *turnstile) verify(responseToken string, remoteIP string) (*response, error) {
	data := url.Values{
		&#34;secret&#34;:   {t.SecretKey},
		&#34;response&#34;: {responseToken},
	}
	if remoteIP != &#34;&#34; {
		data.Add(&#34;remoteip&#34;, remoteIP)
	}

	request, err := http.PostForm(api_endpoint, data)
	if err != nil {
		return nil, err
	}
	defer request.Body.Close()

	response := &amp;response{}
	if err := json.NewDecoder(request.Body).Decode(response); err != nil {
		return nil, err
	}

	return response, nil
}

func ValidateTurnstile(w http.ResponseWriter, r *http.Request) (ok bool) {
	// TODO: move secret key to avoid leaks
	validator := newTurnstile(&#34;0x4AAAAAAAS-lrqDH1USP4oraJ_rHkgg46c&#34;, default_timeout)

	// Get the CAPTCHA token from the &#39;cf-turnstile-response&#39; form value
	captchaToken := r.FormValue(&#34;cf-turnstile-response&#34;)

	// Get the user&#39;s IP address
	userIP := getRealIP(r)

	// Captcha token received from form value cf-turnstile-response
	// Remote IP isn&#39;t required, if you wouldn&#39;t pass IP then insert &#34;&#34;
	response, err := validator.verify(captchaToken, userIP)
	if err != nil {
		filelog.Log.Error(err)
		return false
	}

	if response.HasErrors() {
		var errorCodes string
		for _, v := range response.ErrorCodes {
			errorCodes += v + &#34; &#34;
		}
		filelog.Log.Error(fmt.Errorf(&#34;errorCodes: %s&#34;, errorCodes))
	}

	if !response.IsSuccess() {
		return false
	}

	return true
}

// getRealIP retrieves the real IP address from the request.
func getRealIP(r *http.Request) string {
	// Check for headers that might contain the real IP address
	ip := r.Header.Get(&#34;X-Forwarded-For&#34;)
	if ip == &#34;&#34; {
		ip = r.Header.Get(&#34;X-Real-IP&#34;)
	}
	if ip == &#34;&#34; {
		ip = r.RemoteAddr
	}
	return ip
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet email verify" value="// verifyUserEmail sends a verification email: verifyUserEmail(w, user, &#34;/urlPath&#34;)
func verifyUserEmail(w http.ResponseWriter, email, urlPath string) error {
	resetToken, err := encryptToken(email, []byte(config.Config.SecretKey))
	if err != nil {
		log.Println(err)
		return err
	}

	// Send a password reset email
	resetLink := fmt.Sprintf(config.Config.Domain+urlPath+&#34;?token=%s&#34;, resetToken)
	cookies.Set(w, &#34;tokenValidate&#34;, resetToken, time.Now().Add(1*time.Hour)) // TODO: insert to verification_tokens

	if config.Config.IsProd {
		go func() {
			if err = emailSendLink(email, resetLink); err != nil {
				log.Println(err)
				cookies.Delete(w, &#34;tokenValidate&#34;)
			}
		}()
	} else {
		fmt.Println(resetLink)
	}
	return err
}

func encryptToken(email string, secretKey []byte) (string, error) {
	plaintext := []byte(email + &#34;|&#34; + time.Now().Add(1*time.Hour).Format(time.RFC3339))
	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return &#34;&#34;, err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}

func decryptToken(token string, secretKey []byte) (string, error) {
	ciphertext, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return &#34;&#34;, err
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return &#34;&#34;, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return &#34;&#34;, err
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) &lt; nonceSize {
		return &#34;&#34;, fmt.Errorf(&#34;ciphertext too short&#34;)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return &#34;&#34;, err
	}

	parts := strings.SplitN(string(plaintext), &#34;|&#34;, 2)
	if len(parts) != 2 {
		return &#34;&#34;, fmt.Errorf(&#34;invalid token format&#34;)
	}

	expiry, err := time.Parse(time.RFC3339, parts[1])
	if err != nil {
		return &#34;&#34;, err
	}

	if time.Now().After(expiry) {
		return &#34;&#34;, fmt.Errorf(&#34;token has expired&#34;)
	}

	return parts[0], nil
}

func verifyTokens(token1, token2 string) (string, error) {
	email1, err := decryptToken(token1, []byte(config.Config.SecretKey))
	if err != nil {
		return &#34;&#34;, err
	}

	email2, err := decryptToken(token2, []byte(config.Config.SecretKey))
	if err != nil {
		return &#34;&#34;, err
	}

	if email1 != email2 {
		return &#34;&#34;, errors.New(&#34;tokens don&#39;t match&#34;)
	}
	return email1, nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet turnstile verify" value="if ok := captcha.ValidateTurnstile(w, r); !ok {
    http.Error(w, &#34;CAPTCHA failed. Try again.&#34;, http.StatusForbidden)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippet binance calculate quantity" value="// calculateValidQuantity computes valid quantity for a custom USDC amount.
// Args:
//
//	symbol: Trading pair (e.g., &#34;BTCUSDC&#34;).
//	moneyStr: Desired USDC amount (e.g., &#34;10.5&#34;).
func calculateValidQuantity(client *bc.Client, symbol, moneyStr string) (float64, error) {
	errg, ctx := errgroup.WithContext(context.Background())
	stepSize, minNotional, priceStr := decimal.Decimal{}, decimal.Decimal{}, []*bc.TickerPriceResponse{}

	errg.Go(func() error {
		if ctx.Err() != nil {
			return ctx.Err()
		}
		var err error
		// Fetch symbol info (precision, minNotional)
		stepSize, minNotional, err = getSymbolFilters(client, symbol)
		if err != nil {
			return err
		}
		return nil
	})

	errg.Go(func() error {
		if ctx.Err() != nil {
			return ctx.Err()
		}
		var err error
		// Fetch latest price
		priceStr, err = marketGetLastPrice(client, symbol)
		if err != nil {
			return err
		}
		return nil
	})

	if err := errg.Wait(); err != nil {
		return 0, err
	}

	// Parse inputs
	money, _ := decimal.NewFromString(moneyStr)
	price, _ := decimal.NewFromString(priceStr[0].Price)
	if money.IsZero() || price.IsZero() {
		return 0, fmt.Errorf(&#34;invalid money/price&#34;)
	}

	// Calculate quantity and round UP to stepSize precision
	quantity := money.Div(price)
	quantity = adjustToStepSize(quantity, stepSize)

	// Ensure notional  max(minNotional, money)
	minNotionalVal := decimal.Max(minNotional, money)
	if notional := quantity.Mul(price); notional.LessThan(minNotionalVal) {
		return 0, fmt.Errorf(&#34;notional too small (need %s, got %s)&#34;, minNotionalVal, notional)
	}

	return quantity.InexactFloat64(), nil
}

// getSymbolFilters retrieves precision (stepSize) and minNotional from Binance
func getSymbolFilters(client *bc.Client, symbol string) (stepSize, minNotional decimal.Decimal, err error) {
	res, err := client.NewExchangeInfoService().Symbol(symbol).Do(context.Background())
	if err != nil {
		return decimal.Zero, decimal.Zero, fmt.Errorf(&#34;failed to fetch symbol info: %v&#34;, err)
	}

	for _, s := range res.Symbols {
		if s.Symbol == symbol {
			for _, filter := range s.Filters {
				// Extract LOT_SIZE (stepSize)
				if filter.FilterType == &#34;LOT_SIZE&#34; {
					stepSize = decimal.RequireFromString(filter.StepSize)
				}
				// Extract MIN_NOTIONAL or NOTIONAL filter
				if filter.FilterType == &#34;MIN_NOTIONAL&#34; || filter.FilterType == &#34;NOTIONAL&#34; {
					minNotional = decimal.RequireFromString(filter.MinNotional)
				}
			}
			return stepSize, minNotional, nil
		}
	}
	return decimal.Zero, decimal.Zero, fmt.Errorf(&#34;symbol %s not found&#34;, symbol)
}

// adjustToStepSize rounds UP to Binance&#39;s allowed stepSize precision
func adjustToStepSize(qty, stepSize decimal.Decimal) decimal.Decimal {
	if stepSize.IsZero() {
		return qty
	}
	// Calculate precision from stepSize (e.g., &#34;0.001&#34;  3 decimals)
	stepFloat, _ := stepSize.Float64()
	precision := -decimal.NewFromFloat(stepFloat).Exponent()

	// Round up to stepSize multiple (e.g., 0.123456  0.124)
	return qty.Div(stepSize).Ceil().Mul(stepSize).Truncate(int32(precision))
}

func parseStrNumToFloat(qtyStr string) (float64, error) {
	qty, _ := decimal.NewFromString(qtyStr)
	if qty.IsZero() {
		return 0, fmt.Errorf(&#34;invalid money/price&#34;)
	}

	return qty.InexactFloat64(), nil
}

// Function to calculate and force correct float64 format
func calculateTargetSellPrice(buyPrice, quantity, buyFeeRate, sellFeeRate float64) float64 {
	// Convert values to decimal for precision
	buyPriceDec := decimal.NewFromFloat(buyPrice)
	quantityDec := decimal.NewFromFloat(quantity)
	buyFeeRateDec := decimal.NewFromFloat(buyFeeRate)
	sellFeeRateDec := decimal.NewFromFloat(sellFeeRate)

	// Calculate buy fee
	buyFee := buyPriceDec.Mul(quantityDec).Mul(buyFeeRateDec)

	// Calculate target price with 2% profit
	targetPrice := buyPriceDec.Mul(decimal.NewFromFloat(1.02))

	// Estimate sell fee
	sellFee := targetPrice.Mul(quantityDec).Mul(sellFeeRateDec)

	// Final target price including fees
	finalPrice := targetPrice.Add(buyFee.Div(quantityDec)).Add(sellFee.Div(quantityDec)).Round(8)

	// Format as a string to remove scientific notation
	strPrice := finalPrice.String() // Guarantees a fixed decimal format

	// Convert back to float64 properly
	finalFloat, _ := strconv.ParseFloat(strPrice, 64)

	return finalFloat
}

// Function to format float as a proper decimal before passing to Binance API
func formatDecimalForBinance(value float64, precision int) string {
	// Convert to decimal for precision control
	dec := decimal.NewFromFloat(value)

	// Format as a fixed decimal string with correct precision
	return dec.Round(int32(precision)).String() // Keeps trailing zeros
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="snippets server local and production" value="&#34;golang.org/x/crypto/acme/autocert&#34;

ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer stop()

if *isProd {
    slog.Info(&#34;Starting server with HTTPS&#34;, &#34;domain&#34;, *domain)
    certManager := &amp;autocert.Manager{
        Prompt:     autocert.AcceptTOS,
        HostPolicy: autocert.HostWhitelist(*domain),
        Cache:      autocert.DirCache(&#34;certs&#34;),
    }

    go func() {
        httpChallengeServer := &amp;http.Server{
            Addr:         &#34;:80&#34;,
            Handler:      certManager.HTTPHandler(nil),
            ReadTimeout:  5 * time.Second,
            WriteTimeout: 5 * time.Second,
            IdleTimeout:  120 * time.Second,
        }
        slog.Info(&#34;Starting HTTP challenge server on :80&#34;)
        if err := httpChallengeServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
            slog.Error(&#34;HTTP challenge server ListenAndServe error&#34;, &#34;error&#34;, err)
        }
    }()

    httpsServer := &amp;http.Server{
        Addr:         &#34;:443&#34;,
        Handler:      finalHandler,
        TLSConfig:    certManager.TLSConfig(),
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
    }

    go func() {
        slog.Info(&#34;Starting HTTPS server on :443&#34;)
        if err := httpsServer.ListenAndServeTLS(&#34;&#34;, &#34;&#34;); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
            slog.Error(&#34;HTTPS server ListenAndServeTLS error&#34;, &#34;error&#34;, err)
            os.Exit(1)
        }
    }()

    &lt;-ctx.Done()
    stop()

    slog.Info(&#34;Shutdown signal received. Shutting down HTTPS server...&#34;)
    shutdownCtx, cancelShutdown := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelShutdown()

    if err := httpsServer.Shutdown(shutdownCtx); err != nil {
        slog.Error(&#34;HTTPS server shutdown failed&#34;, &#34;error&#34;, err)
    }
    slog.Info(&#34;HTTPS server gracefully stopped.&#34;)

} else {
    slog.Info(&#34;Starting server on HTTP&#34;, &#34;address&#34;, &#34;http://127.0.0.1:8080&#34;)
    httpServer := &amp;http.Server{
        Addr:         &#34;:8080&#34;,
        Handler:      finalHandler,
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
    }

    go func() {
        if err := httpServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
            slog.Error(&#34;HTTP server ListenAndServe error&#34;, &#34;error&#34;, err)
            os.Exit(1)
        }
    }()

    &lt;-ctx.Done()
    stop()

    slog.Info(&#34;Shutdown signal received. Shutting down HTTP server...&#34;)
    shutdownCtx, cancelShutdown := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelShutdown()

    if err := httpServer.Shutdown(shutdownCtx); err != nil {
        slog.Error(&#34;HTTP server shutdown failed&#34;, &#34;error&#34;, err)
    }
    slog.Info(&#34;HTTP server gracefully stopped.&#34;)
}
slog.Info(&#34;Application exiting.&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth" value="_ &#34;github.com/mattn/go-sqlite3&#34;

var dbAuth *sql.DB

type User struct {
	Email    string `json:&#34;email&#34;`
	Password string `json:&#34;password&#34;`
}

func initAuthDB() {
	var err error
	dbAuth, err = sql.Open(&#34;sqlite3&#34;, &#34;file:auth.db?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to open database: %v&#34;, err)
	}

	_, err = dbAuth.Exec(`
		CREATE TABLE IF NOT EXISTS users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email TEXT UNIQUE NOT NULL,
			password TEXT NOT NULL
		);
	`)
	if err != nil {
		log.Fatal(err)
	}
	
	dbAuth.SetMaxOpenConns(25)
	dbAuth.SetMaxIdleConns(25)
	dbAuth.SetConnMaxIdleTime(5 * time.Minute)
	dbAuth.SetConnMaxLifetime(2 * time.Hour)
}

func closeAuthDB() {
	err := dbAuth.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(&#34;Closing database without errors&#34;)
}

initAuthDB()
defer closeAuthDB()
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth exec (create table)" value="_, err = dbAuth.Exec(`
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL
    );
`)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth exec (INSERT)" value="_, err = dbAuth.Exec(&#34;INSERT INTO users (email, password) VALUES (?, ?)&#34;, user.Email, string(hashedPassword))
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth exec (UPDATE)" value="_, err = dbAuth.Exec(&#34;UPDATE users SET password = ? WHERE email = ?&#34;, string(hashedPassword), email)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth exec (VERIFY)" value="email := r.FormValue(&#34;email&#34;)
var exists bool
err := dbAuth.QueryRow(&#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, email).Scan(&amp;exists)
if err != nil || !exists {
    setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
    http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth query row (example get row by email)" value="var hashedPassword string
err := dbAuth.QueryRow(&#34;SELECT password FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;hashedPassword)
if err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password)) != nil {
    setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
    http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth compare two password with bcrypt" value="// check password with database password
var hashedPassword string
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
err := dbAuth.QueryRowContext(ctx, &#34;SELECT password FROM users WHERE email = ?&#34;, email).Scan(&amp;hashedPassword)
if err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) != nil {
    setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
    http.Redirect(w, r, &#34;/delete-account&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth delete" value="ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
_, err = dbAuth.ExecContext(ctx, &#34;DELETE FROM users WHERE email = ?&#34;, email)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth init" value="func initAuthDB() {
	var err error
	dbAuth, err = sql.Open(&#34;sqlite3&#34;, &#34;file:auth.db?cache=shared&amp;mode=rwc&amp;_journal_mode=WAL&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to open database: %v&#34;, err)
	}

	// Configure connection pool
	dbAuth.SetMaxOpenConns(25)
	dbAuth.SetMaxIdleConns(25)
	dbAuth.SetConnMaxLifetime(5 * time.Minute)

	// TODO: add verify_tokens table to verify email
	_, err = dbAuth.Exec(`
		CREATE TABLE IF NOT EXISTS users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email TEXT UNIQUE NOT NULL,
			password TEXT NOT NULL,
			user_type TEXT NOT NULL DEFAULT &#39;user&#39;, -- Can be &#39;admin&#39;, &#39;user&#39;, etc
			verified BOOLEAN NOT NULL DEFAULT 0,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		);
	`)
	if err != nil {
		log.Fatal(err)
	}
}

func closeAuthDB() {
	err := dbAuth.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(&#34;Closing database without errors&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth insert" value="ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
_, err = dbAuth.ExecContext(ctx, &#34;INSERT INTO users (email, password) VALUES (?, ?)&#34;, user.Email, string(hashedPassword))
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth select (select password and bcrypt compare)" value="ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
err := dbAuth.QueryRowContext(ctx, &#34;SELECT password, user_type, verified FROM users WHERE email = ?&#34;, user.Email).
    Scan(&amp;dbUser.Password, &amp;dbUser.UserType, &amp;dbUser.Verified)
if err != nil || bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(user.Password)) != nil {
    setFlash(w, flashCookie, &#34;Invalid credentials&#34;)
    http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth select all" value="ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
rows, err := dbAuth.QueryContext(ctx, &#34;SELECT id, email FROM users&#34;)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
defer rows.Close()

var users []User
for rows.Next() {
    var user User
    if err := rows.Scan(&amp;user.Id, &amp;user.Email); err != nil {
        logToFileWithCaller(levelError, err.Error())
        continue
    }
    users = append(users, user)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth select check if exist" value="var exists bool
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
err := dbAuth.QueryRowContext(ctx, &#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, email).Scan(&amp;exists)
if err != nil || !exists {
    setFlash(w, flashCookie, &#34;If the email exists, instructions to reset the password have been sent.&#34;)
    http.Redirect(w, r, &#34;/change-password&#34;, http.StatusSeeOther)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth transaction" value="ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

tx, err := dbAuth.BeginTx(ctx, nil)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}

var exists bool
err = tx.QueryRowContext(ctx, &#34;SELECT COUNT(*) &gt; 0 FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;exists)
if err != nil {
    tx.Rollback()
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}

if exists {
    err = tx.QueryRowContext(ctx, &#34;SELECT verified FROM users WHERE email = ?&#34;, user.Email).Scan(&amp;user.Verified)
    if err != nil {
        tx.Rollback()
        logToFileWithCaller(levelError, err.Error())
        http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
        return
    }
    if user.Verified {
        tx.Rollback()
        setFlash(w, flashCookie, &#34;An account with the provided email address already exists.&#34;)
        http.Redirect(w, r, &#34;/login&#34;, http.StatusSeeOther)
        return
    }
}

if !exists {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
    if err != nil {
        tx.Rollback()
        logToFileWithCaller(levelError, err.Error())
        http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
        return
    }

    _, err = tx.ExecContext(ctx, &#34;INSERT INTO users (email, password) VALUES (?, ?)&#34;, user.Email, string(hashedPassword))
    if err != nil {
        tx.Rollback()
        logToFileWithCaller(levelError, err.Error())
        http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
        return
    }
}

if err = verifyUserEmail(w, user.Email, &#34;/confirm-account&#34;); err != nil {
    tx.Rollback()
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}

err = tx.Commit()
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite auth update" value="ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
_, err = dbAuth.ExecContext(ctx, &#34;UPDATE users SET password = ? WHERE email = ?&#34;, string(hashedPassword), email)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sqlite delete table content and reset index" value="_, err := db.Exec(&#34;DELETE FROM rackets&#34;)
if err != nil {
    log.Fatal(&#34;Error deleting existing racket data:&#34;, err)
}

// Reset the auto-increment value
_, err = db.Exec(&#34;DELETE FROM sqlite_sequence WHERE name=&#39;rackets&#39;&#34;)
if err != nil {
    log.Fatal(&#34;Error resetting auto-increment value:&#34;, err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template html variable" value="{{$number := .}}
&lt;h1&gt; It is day number {{$number}} of the month &lt;/h1&gt;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template html range" value="&lt;ul&gt;
{{ range . }}
  &lt;li&gt;{{ . }}&lt;/li&gt;
{{ end}}
&lt;/ul&gt;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template html if" value="{{ if . }}
  Number is greater than 5!
{{ else }}
  Number is 5 or less!
{{ end }}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template html and" value="{{if and .User .User.Admin}}
  You are an admin user!
{{else}}
  Access denied!
{{end}}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template html dot change" value="&lt;div&gt;The dot is {{ . }}&lt;/div&gt;
&lt;div&gt;
{{ with &#34;world&#34;}}
  Now the dot is set to {{ . }}
{{ end }}
&lt;/div&gt;
&lt;div&gt;The dot is {{ . }} again&lt;/div&gt;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template inline html with function" value="const templ = `Hello {{.Name}} it&#39;s {{.T | daysAgo}}`

func daysAgo(t time.Time) string {
	clock, min, sec := t.Clock()
	return fmt.Sprintf(&#34;%d:%d:%d\n&#34;, clock, min, sec)
}

var report = template.Must(template.New(&#34;issuelist&#34;).
	Funcs(template.FuncMap{&#34;daysAgo&#34;: daysAgo}).
	Parse(templ))
	
data := struct {
    Name string
    T    time.Time
}{
    Name: &#34;Andrei&#34;,
    T:    time.Now(),
}
log.Fatalln(report.Execute(os.Stdout, data))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template parse all files and render page (generate html)" value="var (
	templates     *template.Template
	templatesLock sync.RWMutex
	templateDir   = &#34;app/src&#34;
)

/* Initial load of templates */
if err := loadTemplates(templateDir); err != nil {
    log.Fatal(&#34;Failed to load templates:&#34;, err)
}

/* index functionality */
http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
    RenderTemplate(w, &#34;index.html&#34;, map[string]interface{}{})
})
	
// Load all templates from the directory dynamically
func loadTemplates(goTemplatesDir string) error {
	files := []string{}

	// Walk through the directory and collect all .html files
	err := filepath.WalkDir(goTemplatesDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() &amp;&amp; filepath.Ext(path) == &#34;.html&#34; {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		return err
	}

	// Parse all template files dynamically
	tmpl, err := template.ParseFiles(files...)
	if err != nil {
		return err
	}

	// Safely update the global template reference
	templatesLock.Lock()
	templates = tmpl
	templatesLock.Unlock()

	log.Println(&#34;Templates reloaded successfully.&#34;)
	return nil
}	

// RenderTemplate safely renders the given template with provided data
func RenderTemplate(w http.ResponseWriter, tmplName string, data map[string]interface{}) {
	templatesLock.RLock()
	defer templatesLock.RUnlock()

	err := templates.ExecuteTemplate(w, tmplName, data)
	if err != nil {
		http.Error(w, fmt.Sprintf(&#34;Template execution error: %v&#34;, err), http.StatusInternalServerError)
		log.Printf(&#34;Template execution error: %v&#34;, err)
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template render inline html" value="tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Authorization Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&#34;/login&#34;&gt;Login&lt;/a&gt;
    &lt;a href=&#34;/signup&#34;&gt;Signup&lt;/a&gt;
    &lt;a href=&#34;/logout&#34;&gt;Logout&lt;/a&gt;
    &lt;h1&gt;Authorization Example&lt;/h1&gt;
    {{if .FlashMsg}}
            &lt;p style=&#34;color: green;&#34;&gt;{{.FlashMsg}}&lt;/p&gt;
        {{end}}
    {{if .UserEmail}}
        &lt;p&gt;Welcome, {{.UserEmail}}!&lt;/p&gt;
    {{else}}
        &lt;p&gt;Welcome, Guest!&lt;/p&gt;
    {{end}}
&lt;/body&gt;
&lt;/html&gt;`

data := map[string]interface{}{
    &#34;UserEmail&#34;: userEmail,
    &#34;FlashMsg&#34;:  flashMsg,
}

err := RenderTemplateInline(w, tmpl, data)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try letter&#34;, http.StatusInternalServerError)
}

func RenderTemplateInline(w http.ResponseWriter, tmpl string, data map[string]interface{}) error {
	tempParsed, err := template.New(&#34;&#34;).Parse(tmpl)
	if err != nil {
		return err
	}
	err = tempParsed.Execute(w, data)
	if err != nil {
		return err
	}
	return nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="template csrf" value="{{ .csrfField }}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="termianl pretty print" value="func printToTerminal() {
	const format = &#34;%v\t%v\t%v\t%v\t%v\t\n&#34;
	tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, &#39; &#39;, 0)
	fmt.Fprintf(tw, format, &#34;Title&#34;, &#34;Artist&#34;, &#34;Album&#34;, &#34;Year&#34;, &#34;Length&#34;)
	fmt.Fprintf(tw, format, &#34;-----&#34;, &#34;------&#34;, &#34;-----&#34;, &#34;----&#34;, &#34;------&#34;)
	fmt.Fprintf(tw, format, &#34;Song&#34;, &#34;Andrei&#34;, &#34;Life&#34;, &#34;1987&#34;, &#34;10min&#34;)
	tw.Flush() // calculate column widths and print table
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal ask question" value="// ssl := doYouWant(&#34;ssl&#34;)
func doYouWant(option string) (yes bool, err error) {
	answer := &#34;&#34;

	// ask question
	fmt.Printf(&#34;Activate %s? (y/N) &#34;, option)

	// get answer
	_, err = fmt.Fscanln(os.Stdin, &amp;answer)
	if err != nil {
		if strings.Contains(err.Error(), &#34;unexpected newline&#34;) {
			return false, nil
		} else {
			return false, err
		}
	}

	if answer != &#34;&#34; {
		if strings.ToLower(answer) == &#34;y&#34; {
			yes = true
		}
	}

	return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal exec command" value="command := &#34;ls&#34;
c := exec.Command(&#34;sh&#34;, &#34;-c&#34;, command)
o, err := c.Output()
if err != nil {
    return nil, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal exec command with syscall" value="command := &#34;/bin/ls&#34;
env := os.Environ()
syscall.Exec(command, []string{&#34;ls&#34;, &#34;-a&#34;, &#34;-x&#34;}, env)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal flags" value="strPtr := flag.String(&#34;name&#34;, &#34;Shiju&#34;, &#34;a string&#34;)
numbPtr := flag.Int(&#34;num&#34;, 25, &#34;an int&#34;)
boolPtr := flag.Bool(&#34;enable&#34;, false, &#34;a bool&#34;)
var num int
flag.IntVar(&amp;num, &#34;num&#34;, 30, &#34;an int&#34;)	
// Parse parses flag definitions from the argument list.
flag.Parse()
// Get the values for pointers
fmt.Println(&#34;name:&#34;, *strPtr)
fmt.Println(&#34;num:&#34;, *numbPtr)
fmt.Println(&#34;enable:&#34;, *boolPtr)
// Get the value from a variable
fmt.Println(&#34;num:&#34;, num)
// Args returns the non-flag command-line arguments.
fmt.Println(&#34;arguments:&#34;, flag.Args())
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal read byte" value="os.Stdin.Read(make([]byte, 1))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal read with reader (bufio)" value="reader := bufio.NewReader(os.Stdin)
for {
  fmt.Printf(&#34;Enter some text: &#34;)
  data, err := reader.ReadString(&#39;\n&#39;)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Println(data)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="terminal read with scanner" value="seen := make(map[string]bool) // a set of strings
input := bufio.NewScanner(os.Stdin)
for input.Scan() {
    line := input.Text()
    if !seen[line] {
        seen[line] = true
        fmt.Println(line)
    }
}

if err := input.Err(); err != nil {
    fmt.Fprintf(os.Stderr, &#34;dedup: %v\n&#34;, err)
    os.Exit(1)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails onshutdown" value="OnShutdown: func(ctx context.Context) {
    if app.CurrentFile != &#34;&#34; {
        app.RunEncrypt()
    }
},
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails runtime open file" value="func (a *App) OpenFile() (string, error) {
	file, err := runtime.OpenFileDialog(a.Ctx, runtime.OpenDialogOptions{
		Title: &#34;Choose a file to edit&#34;,
	})
	if err != nil {
		return &#34;&#34;, err
	}
	if file == &#34;&#34; {
		return &#34;&#34;, nil
	}

	a.CurrentFile = file
	data, err := os.ReadFile(file)
	if err != nil {
		return &#34;&#34;, err
	}

	decrypted, err := decryptData(string(data), a.Key)
	if err != nil {
		a.Content = string(data)
	} else {
		a.Content = decrypted
	}

	return a.Content, nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails import func" value="import { OpenFile, SaveContent } from &#39;../wailsjs/go/main/App&#39;;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails openfile and save" value="import &#39;./style.css&#39;;
import &#39;./app.css&#39;;

import logo from &#39;./assets/images/logo-universal.png&#39;;
import { OpenFile, SaveContent } from &#39;../wailsjs/go/main/App&#39;;

document.querySelector(&#39;#app&#39;).innerHTML = `
  &lt;img id=&#34;logo&#34; class=&#34;logo&#34;&gt;
  &lt;div class=&#34;result&#34; id=&#34;status&#34;&gt;Choose a file to begin editing:&lt;/div&gt;
  &lt;div class=&#34;input-box&#34;&gt;
    &lt;button class=&#34;btn&#34; id=&#34;openFileBtn&#34;&gt;Choose File&lt;/button&gt;
  &lt;/div&gt;
  &lt;textarea id=&#34;content&#34; rows=&#34;20&#34; class=&#34;editor&#34; placeholder=&#34;File content will appear here...&#34;&gt;&lt;/textarea&gt;
  &lt;div class=&#34;input-box&#34;&gt;
    &lt;button class=&#34;btn&#34; id=&#34;saveFileBtn&#34;&gt;Save Changes&lt;/button&gt;
  &lt;/div&gt;
`;

document.getElementById(&#39;logo&#39;).src = logo;

const status = document.getElementById(&#39;status&#39;);
const content = document.getElementById(&#39;content&#39;);
const openBtn = document.getElementById(&#39;openFileBtn&#39;);
const saveBtn = document.getElementById(&#39;saveFileBtn&#39;);

openBtn.addEventListener(&#39;click&#39;, async () =&gt; {
    try {
        const result = await OpenFile();
        if (result !== null &amp;&amp; result !== undefined) {
            content.value = result;
            status.innerText = &#39;File loaded successfully.&#39;;
        } else {
            status.innerText = &#39;No file selected.&#39;;
        }
    } catch (err) {
        console.error(err);
        status.innerText = &#39;Error loading file.&#39;;
    }
});

saveBtn.addEventListener(&#39;click&#39;, async () =&gt; {
    try {
        await SaveContent(content.value);
        status.innerText = &#39;File saved!&#39;;
    } catch (err) {
        console.error(err);
        status.innerText = &#39;Failed to save file.&#39;;
    }
});

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails app" value="type App struct {
	Ctx         context.Context
	CurrentFile string
	Content     string
	Key         []byte
}

func NewApp() *App {
	return &amp;App{
		Key: []byte(&#34;forbfwjbfwljibfvfoieubvieufewwdw&#34;),
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails save file content" value="func (a *App) SaveContent(content string) error {
	a.Content = content
	return os.WriteFile(a.CurrentFile, []byte(content), 0644)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wails runencrypt" value="func (a *App) RunEncrypt() {
	if a.CurrentFile == &#34;&#34; || a.Content == &#34;&#34; {
		return
	}
	encrypted, err := encryptData(a.Content, a.Key)
	if err != nil {
		runtime.LogError(a.Ctx, err.Error())
		return
	}
	_ = os.WriteFile(a.CurrentFile, []byte(encrypted), 0644)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="websocket watch for files change inside folder recursively" value="//go:embed reload.html
var reloadHtmlFile []byte

var (
	upgrader    = websocket.Upgrader{}
	connections = make(map[*websocket.Conn]bool)
	mu          sync.Mutex
	templateDir = &#34;app/src&#34;
)

/* ws */
go watchDirectory(templateDir)
http. HandleFunc(&#34;/&#34;, func(w http. ResponseWriter, r *http. Request) {
    w.Write([]byte(&#34;Hello World!&#34;))
})

http.HandleFunc(&#34;/ws&#34;, func(w http.ResponseWriter, r *http.Request) {
    upgrader.CheckOrigin = func(r *http.Request) bool { return true }
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(&#34;WebSocket upgrade error:&#34;, err)
        return
    }

    mu.Lock()
    connections[conn] = true
    mu.Unlock()

    fmt.Println(&#34;New WebSocket connection&#34;)
})

/* index functionality */
http.HandleFunc(&#34;/reload&#34;, func(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&#34;Content-Type&#34;, &#34;text/html&#34;)
    w.Write(reloadHtmlFile)
})

// Watch for changes in the directory and if there is a change loadTemplates() and notifyClients()
func watchDirectory(directory string) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	// Function to recursively add directories to the watcher
	err = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			err = watcher.Add(path)
			if err != nil {
				log.Printf(&#34;Error watching directory: %s, %v&#34;, path, err)
			} else {
				fmt.Println(&#34;Watching:&#34;, path)
			}
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	eventCache := make(map[string]time.Time)
	
	for {
		select {
		case event, ok := &lt;-watcher.Events:
			if !ok {
				return
			}
			if event.Op&amp;(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 &amp;&amp; strings.HasSuffix(event.Name, &#34;.html&#34;) {
				now := time.Now()
				if lastEventTime, exists := eventCache[&#34;reload&#34;]; exists &amp;&amp; now.Sub(lastEventTime) &lt; 100*time.Millisecond {
					continue
				}
				eventCache[&#34;reload&#34;] = now
				if err := templates.Load(); err != nil {
					log.Println(&#34;Failed to reload templates:&#34;, err)
				}
				ws.NotifyClients()
			}
			// Handle newly created directories
			if event.Op&amp;fsnotify.Create == fsnotify.Create {
				fileInfo, err := os.Stat(event.Name)
				if err == nil &amp;&amp; fileInfo.IsDir() {
					watcher.Add(event.Name)
					fmt.Println(&#34;Added new directory to watch:&#34;, event.Name)
				}
			}
		case err, ok := &lt;-watcher.Errors:
			if !ok {
				return
			}
			log.Println(&#34;Error watching files:&#34;, err)
		}
	}
}

// Notify all connected WebSocket clients
func notifyClients() {
	mu.Lock()
	defer mu.Unlock()
	for conn := range connections {
		err := conn.WriteMessage(websocket.TextMessage, []byte(&#34;reload&#34;))
		if err != nil {
			log.Println(&#34;Error sending message:&#34;, err)
			conn.Close()
			delete(connections, conn)
		}
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="mail send link" value="&#34;github.com/domodwyer/mailyak/v3&#34;

func sendResetPassword(email, link string) error {
	// Create a new email - specify the SMTP host:port and auth (if needed)
	mail := mailyak.New(&#34;smtp.mail.me.com:587&#34;, smtp.PlainAuth(&#34;&#34;, &#34;andreinita@icloud.com&#34;, &#34;kqfp-sdar-bxzw-awfu&#34;, &#34;smtp.mail.me.com&#34;))

	mail.To(email)
	mail.From(&#34;andreinita@icloud.com&#34;)
	mail.FromName(&#34;Localhost&#34;)

	mail.Subject(&#34;Password Reset&#34;)

	// Or set the body using a string setter
	mail.Plain().Set(&#34;Click the link to reset your password: &#34; + link)

	// And you&#39;re done!
	if err := mail.Send(); err != nil {
		return err
	}
	return nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="hash password bcrypt" value="&#34;golang.org/x/crypto/bcrypt&#34;

hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
if err != nil {
    logToFileWithCaller(levelError, err.Error())
    http.Error(w, &#34;Please try later&#34;, http.StatusInternalServerError)
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="hash sha256" value="c1 := sha256.Sum256([]byte(&#34;x&#34;))
c2 := sha256.Sum256([]byte(&#34;X&#34;))
fmt.Printf(&#34;%x\n%x\n%t\n%T\n&#34;, c1, c2, c1 == c2, c1)
// Output:
// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
// false
// [32]uint8
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="struct building from json" value="type IssuesSearchResult struct {
	TotalCount int `json:&#34;total_count&#34;`
	Items      []*Issue
}

type Issue struct {
	Number    int
	HTMLURL   string `json:&#34;html_url&#34;`
	Title     string
	State     string
	User      *User
	CreatedAt time.Time `json:&#34;created_at&#34;`
	Body      string    // in Markdown format
}

type User struct {
	Login   string
	HTMLURL string `json:&#34;html_url&#34;`
}

/*
{
	&#34;total_count&#34;: 123,
	&#34;items&#34;:[
		{
			&#34;number&#34;: 1,
			&#34;html_url&#34;: &#34;https://golang.com&#34;,
			&#34;title&#34;: &#34;Go&#34;,
			&#34;user&#34;: {
				&#34;login&#34;: &#34;baubabu&#34;,
				&#34;html_url&#34;: &#34;https://google.com&#34;,
				... can be more
			},
			&#34;state&#34;: &#34;open&#34;,
			&#34;created_at&#34;: &#34;021-03-04T13:10:42Z&#34;,
			&#34;body&#34;: &#34;lorem ipsum...&#34;,
			... can be more
		},
		... can be more
	]
}
*/
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="io pipe (multiple writer)" value="// the pipe reader and pipe writer implement
// io.Reader and io.Writer
r, w := io.Pipe()

// this needs to be run in a separate go routine
// as it will block waiting for the reader
// close at the end for cleanup
go func() {
  // for now we&#39;ll write something basic,
  // this could also be used to encode json
  // base64 encode, etc.
  w.Write([]byte(&#34;test\n&#34;))
  w.Close()
}()

if _, err := io.Copy(os.Stdout, r); err != nil {
  log.Fatalln(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="mail read" value="// an example email message
const msg string = `Date: Thu, 24 Jul 2019 08:00:00 -0700
From: Aaron &lt;fake_sender@example.com&gt;
To: Reader &lt;fake_receiver@example.com&gt;
Subject: Gophercon 2019 is going to be awesome!

Feel free to share my book with others if you&#39;re attending.
This recipe can be used to process and parse email information.
`

r := strings.NewReader(msg)
m, err := mail.ReadMessage(r)
if err != nil {
    log.Fatal(err)
}

printHeaderInfo(m.Header)

// after printing the header, dump the body to stdout
if _, err := io.Copy(os.Stdout, m.Body); err != nil {
    log.Fatal(err)
}

// extract header info and print it nicely
func printHeaderInfo(header mail.Header) {
	// this works because we know it&#39;s a single address
	// otherwise use ParseAddressList
	toAddress, err := mail.ParseAddress(header.Get(&#34;To&#34;))
	if err == nil {
		fmt.Printf(&#34;To: %s &lt;%s&gt;\n&#34;, toAddress.Name, toAddress.Address)
	}
	fromAddress, err := mail.ParseAddress(header.Get(&#34;From&#34;))
	if err == nil {
		fmt.Printf(&#34;From: %s &lt;%s&gt;\n&#34;, fromAddress.Name, fromAddress.Address)
	}

	fmt.Println(&#34;Subject:&#34;, header.Get(&#34;Subject&#34;))

	// this works for a valid RFC5322 date
	// it does a header.Get(&#34;Date&#34;), then a
	// mail.ParseDate(that_result)
	if date, err := header.Date(); err == nil {
		fmt.Println(&#34;Date:&#34;, date)
	}

	fmt.Println(strings.Repeat(&#34;=&#34;, 40))
	fmt.Println()
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="os signal" value="//initialize our channels
signals := make(chan os.Signal)
done := make(chan bool)

//hook them up to the signals lib
signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)

//if a signal is caught by this go routine
//it will write to done
go CatchSig(signals, done)

fmt.Println(&#34;Press ctrl-c to terminate...&#34;)
&lt;-done
fmt.Println(&#34;Done!&#34;)


// CatchSig sets up a listener for
// SIGINT interrupts
func CatchSig(ch chan os.Signal, done chan bool) {
	// block on waiting for a signal
	sig := &lt;-ch
	// print it when it&#39;s received
	fmt.Println(&#34;\nsig received:&#34;, sig)

	// we can set up handlers for all types of
	// sigs here
	switch sig {
	case syscall.SIGINT:
		fmt.Println(&#34;handling a SIGINT now!&#34;)
	case syscall.SIGTERM:
		fmt.Println(&#34;handling a SIGTERM in an entirely different way!&#34;)
	default:
		fmt.Println(&#34;unexpected signal received&#34;)
	}

	// terminate
	done &lt;- true
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="panic recover" value="// Panic panics with a divide by zero
func Panic() {
	zero := 0
	a := 1 / zero
	fmt.Println(&#34;we&#39;ll never get here&#34;, a)
}

// Catcher calls Panic
func Recover() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println(&#34;panic occurred:&#34;, r)
		}
	}()
	Panic()
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="reflect get values and names of a struct" value="type Student struct {
    Fname  string
    Lname  string
    City   string
    Mobile int64
}

s := Student{&#34;Chetan&#34;, &#34;Kumar&#34;, &#34;Bangalore&#34;, 7777777777}
v := reflect.ValueOf(s)
typeOfS := v.Type()

for i := 0; i&lt; v.NumField(); i++ {
    fmt.Printf(&#34;Field: %s\tValue: %v\n&#34;, typeOfS.Field(i).Name, v.Field(i).Interface())
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="regex match string" value="// only letter and numbers. No space, /, # ecc.
match, err := regexp.MatchString(&#34;[A-Za-z0-9]+$&#34;, projectname)
if err != nil {
    log.Fatalln(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="regex match parameter" value="var (
	regexPath *regexp.Regexp
)

func init() {
	regexPath = regexp.MustCompile(&#34;^/(evenimente)/([a-zA-Z0-9-]+)$&#34;)

}

// inside route
if match := regexPath.FindString(r.URL.Path); match != &#34;&#34; {
    fmt.Fprintln(w, path.Base(match))
    return
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="runtime file get path at runtime" value="_, filename, _, _ := runtime.Caller(0) // get full path of this file
fmt.Println(filename)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="runtime os (operating system)" value="if runtime.GOOS == &#34;windows&#34; {
    fmt.Println(&#34;Hello from Windows&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="runtime check memory" value="func printStats(mem runtime.MemStats) {
	runtime.ReadMemStats(&amp;mem)
	fmt.Println(&#34;mem.Alloc:&#34;, mem.Alloc)
	fmt.Println(&#34;mem.TotalAlloc:&#34;, mem.TotalAlloc)
	fmt.Println(&#34;mem.HeapAlloc:&#34;, mem.HeapAlloc)
	fmt.Println(&#34;mem.NumGC:&#34;, mem.NumGC)
	fmt.Println(&#34;-----&#34;)
}

var mem runtime.MemStats
printStats(mem)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="runtime info (compiler, goarch, version, num pcu, num goroutines)" value="fmt.Print(&#34;You are using &#34;, runtime.Compiler, &#34; &#34;)
fmt.Println(&#34;on a&#34;, runtime.GOARCH, &#34;machine&#34;)
fmt.Println(&#34;Using Go version&#34;, runtime.Version())
fmt.Println(&#34;Number of CPUs:&#34;, runtime.NumCPU())
fmt.Println(&#34;Number of Goroutines:&#34;, runtime.NumGoroutine())
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="time" value="t := time.Now()
fmt.Println(t.Format(time.RFC3339)) // 2025-02-04T17:10:27+02:00
fmt.Println(t.Format(&#34;3:04:01&#34;)) // 5:10:02
fmt.Println(t.Format(&#34;3:04PM&#34;)) // 5:10PM
fmt.Println(t.Format(&#34;Mon Jan _2 15:04:05 2006&#34;)) // Tue Feb  4 17:10:27 2025
fmt.Println(t.Format(&#34;2006-01-02T15:04:05.999999-07:00&#34;)) // 2025-02-04T17:10:27.366005+02:00
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="time how to use" value="now := time.Now()
fmt.Println(now) // 2025-02-04 17:12:20.723865 +0200 EET m=+0.001601701

ro, err := time.LoadLocation(&#34;Europe/Bucharest&#34;)
if err != nil {
    log.Fatalln(err)
}

then := time.Date(2009, 11, 17, 20, 34, 58, 651387237, ro)
fmt.Println(then) // 2009-11-17 20:34:58.651387237 +0200 EET

fmt.Println(then.Format(&#34;02 January 2006&#34;)) // 17 November 2009

fmt.Println(then.Year()) // 2009
fmt.Println(then.Month()) // November
fmt.Println(then.Day()) // 17
fmt.Println(then.Hour()) // 20
fmt.Println(then.Minute()) // 34
fmt.Println(then.Second()) // 58
fmt.Println(then.Nanosecond()) // 651387237
fmt.Println(then.Location()) // 651387237

fmt.Println(then.Weekday()) // Tuesday

fmt.Println(then.Before(now)) // true
fmt.Println(then.After(now)) // false
fmt.Println(then.Equal(now)) // false

diff := now.Sub(then)
fmt.Println(diff) // 133388h37m22.072477763s

fmt.Println(diff.Hours()) // 133388.6227979105
fmt.Println(diff.Minutes()) // 8.00331736787463e+06
fmt.Println(diff.Seconds()) // 4.8019904207247776e+08
fmt.Println(diff.Nanoseconds()) // 480199042072477763

fmt.Println(then.Add(diff)) // 2025-02-04 17:12:20.723865 +0200 EET
fmt.Println(then.Add(-diff)) // 1994-08-31 00:57:36.578909474 +0300 EEST
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="regex valigate email" value="var emailRegex = regexp.MustCompile(&#34;^[a-zA-Z0-9.!#$%&amp;&#39;*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$&#34;)

// isEmailValid checks if the email provided passes the required structure and length.
func isEmailValid(e string) bool {
	if len(e) &lt; 3 &amp;&amp; len(e) &gt; 254 {
		return false
	}
	return emailRegex.MatchString(e)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="path normalize for both windows and linux" value="path = filepath.ToSlash(path)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="init get variables from os variables" value="func init() {
	// Attempt to load the secret key from the environment variable.
	secretKey = os.Getenv(&#34;secretKey&#34;)
	if secretKey == &#34;&#34; {
		log.Fatal(&#34;Environment variable secretKey is not set&#34;)
	}

	// Attempt to load the email password from the environment variable.
	emailPassword = os.Getenv(&#34;emailPassword&#34;)
	if emailPassword == &#34;&#34; {
		log.Fatal(&#34;Environment variable emailPassword is not set&#34;)
	}

	fmt.Println(&#34;Successfully loaded secretKey and emailPassword from environment variables&#34;)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="go build ignore" value="//go:build ignore
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="os get environment variable" value="// Attempt to load the email password from the environment variable.
emailPassword = os.Getenv(&#34;emailPassword&#34;)
if emailPassword == &#34;&#34; {
    log.Fatal(&#34;Environment variable emailPassword is not set&#34;)
}

fmt.Println(&#34;Successfully loaded secretKey and emailPassword from environment variables&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="mail send template with data" value="package smtp

import (
	&#34;bytes&#34;
	&#34;time&#34;

	&#34;gostart/assets&#34;
	&#34;gostart/internal/funcs&#34;

	&#34;github.com/wneessen/go-mail&#34;

	htmlTemplate &#34;html/template&#34;
	textTemplate &#34;text/template&#34;
)

const defaultTimeout = 10 * time.Second

type Mailer struct {
	client *mail.Client
	from   string
}

func NewMailer(host string, port int, username, password, from string) (*Mailer, error) {
	client, err := mail.NewClient(host, mail.WithTimeout(defaultTimeout), mail.WithSMTPAuth(mail.SMTPAuthLogin), mail.WithPort(port), mail.WithUsername(username), mail.WithPassword(password))
	if err != nil {
		return nil, err
	}

	mailer := &amp;Mailer{
		client: client,
		from:   from,
	}

	return mailer, nil
}

func (m *Mailer) Send(recipient string, data any, patterns ...string) error {
	for i := range patterns {
		patterns[i] = &#34;emails/&#34; + patterns[i]
	}
	msg := mail.NewMsg()

	err := msg.To(recipient)
	if err != nil {
		return err
	}

	err = msg.From(m.from)
	if err != nil {
		return err
	}

	ts, err := textTemplate.New(&#34;&#34;).Funcs(funcs.TemplateFuncs).ParseFS(assets.EmbeddedFiles, patterns...)
	if err != nil {
		return err
	}

	subject := new(bytes.Buffer)
	err = ts.ExecuteTemplate(subject, &#34;subject&#34;, data)
	if err != nil {
		return err
	}

	msg.Subject(subject.String())

	plainBody := new(bytes.Buffer)
	err = ts.ExecuteTemplate(plainBody, &#34;plainBody&#34;, data)
	if err != nil {
		return err
	}

	msg.SetBodyString(mail.TypeTextPlain, plainBody.String())

	if ts.Lookup(&#34;htmlBody&#34;) != nil {
		ts, err := htmlTemplate.New(&#34;&#34;).Funcs(funcs.TemplateFuncs).ParseFS(assets.EmbeddedFiles, patterns...)
		if err != nil {
			return err
		}

		htmlBody := new(bytes.Buffer)
		err = ts.ExecuteTemplate(htmlBody, &#34;htmlBody&#34;, data)
		if err != nil {
			return err
		}

		msg.AddAlternativeString(mail.TypeTextHTML, htmlBody.String())
	}

	for i := 1; i &lt;= 3; i++ {
		err = m.client.DialAndSend(msg)

		if nil == err {
			return nil
		}

		if i != 3 {
			time.Sleep(2 * time.Second)
		}
	}

	return err
}

/*

package main

import (
	&#34;log&#34;

	&#34;gostart/internal/smtp&#34;
)

func main() {
	// Initialize SMTP settings for the mailer
	host := &#34;smtp.example.com&#34;
	port := 587
	username := &#34;user@example.com&#34;
	password := &#34;password&#34;
	from := &#34;Example &lt;no_reply@example.com&gt;&#34;

	mailer, err := smtp.NewMailer(host, port, username, password, from)
	if err != nil {
		log.Fatalf(&#34;Failed to create mailer: %v&#34;, err)
	}

	// Data for the email templates. Fields must match the template placeholders.
	data := struct {
		BaseURL       string
		Message       string
		RequestMethod string
		RequestURL    string
		Trace         string
	}{
		BaseURL:       &#34;http://localhost:8080&#34;,
		Message:       &#34;An error occurred while processing your request.&#34;,
		RequestMethod: &#34;GET&#34;,
		RequestURL:    &#34;http://localhost:8080/home&#34;,
		Trace:         &#34;example stack trace information&#34;,
	}

	// Send email using the template file &#39;assets/emails/error-notification.tmpl&#39;
	err = mailer.Send(&#34;recipient@example.com&#34;, data, &#34;error-notification.tmpl&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to send email: %v&#34;, err)
	}

	log.Println(&#34;Email sent successfully.&#34;)
}

*/

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="strings builder" value="var sb strings.Builder
sb.WriteString(&#34;{{define \&#34;&#34; + filepath.Base(filePath) + &#34;\&#34;}}&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="sass example" value="transpiler, _ := libsass.New(libsass.Options{OutputStyle: libsass.CompressedStyle})

	start := time.Now()
	result, _ := transpiler.Execute(`
$font-stack:    Helvetica, sans-serif;
$primary-color: #321;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
`)

	fmt.Println(time.Since(start))
	fmt.Println(result.CSS)
	// Output: body{font:100% Helvetica,sans-serif;color:#333}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="cache event (avoid duplicates)" value="eventCache := make(map[string]time.Time)

now := time.Now()
if lastEventTime, exists := eventCache[event.Name]; exists &amp;&amp; now.Sub(lastEventTime) &lt; 100*time.Millisecond {
    continue
}
eventCache[event.Name] = now
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="errgroup example" value="errg, ctx := errgroup.WithContext(context.Background())
stepSize, minNotional, priceStr := decimal.Decimal{}, decimal.Decimal{}, []*bc.TickerPriceResponse{}

errg.Go(func() error {
    if ctx.Err() != nil {
        return ctx.Err()
    }
    var err error
    // Fetch symbol info (precision, minNotional)
    stepSize, minNotional, err = getSymbolFilters(client, symbol)
    if err != nil {
        return err
    }
    return nil
})

errg.Go(func() error {
    if ctx.Err() != nil {
        return ctx.Err()
    }
    var err error
    // Fetch latest price
    priceStr, err = getLatestPrice(client, symbol)
    if err != nil {
        return err
    }
    return nil
})

if err := errg.Wait(); err != nil {
    return 0, err
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="string to float" value="func parseStrNumToFloat(qtyStr string) (float64, error) {
	qty, _ := decimal.NewFromString(qtyStr)
	if qty.IsZero() {
		return 0, fmt.Errorf(&#34;invalid money/price&#34;)
	}
	
	return qty.InexactFloat64(), nil
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="envirment get value" value="apiKey := os.Getenv(&#34;BINANCE_PUBLIC&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="mod replace" value="replace github.com/binance/binance-connector-go =&gt; github.com/andnt87/binance-connector-go v0.0.0-20250527153907-9d7a2c7a6f22

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="time format" value="then.Format(&#34;02 January 2006&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="decimal from string" value="money, _ := decimal.NewFromString(moneyStr)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="comment for goland (TIP)" value="//TIP &lt;p&gt;To run your code, right-click the code and select &lt;b&gt;Run&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;Alternatively, click
// the &lt;icon src=&#34;AllIcons.Actions.Execute&#34;/&gt; icon in the gutter and select the &lt;b&gt;Run&lt;/b&gt; menu item from here.&lt;/p&gt;
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="test boilerplate" value="package main

import (
	&#34;log&#34;
	&#34;os&#34;
	&#34;testing&#34;

	&#34;github.com/asdine/storm/v3&#34;
)

var db *storm.DB // Package-level variable for the DB

// TestMain is executed by the testing package before any tests or benchmarks
// in this package are run.
func TestMain(m *testing.M) {
	// dbPath := &#34;/dev/shm/my_in_memory_storm.db&#34; // Option for RAM disk on Linux
	dbPath := &#34;my_test.db&#34; // Using a local file for the test database

	// Best effort to remove any pre-existing test database file to ensure a clean state.
	// This is helpful if a previous test run was interrupted.
	// We ignore the error here as the file might not exist.
	_ = os.Remove(dbPath)

	var err error
	db, err = storm.Open(dbPath)
	if err != nil {
		// Use log.Printf or fmt.Printf for errors where you want to control the exit yourself.
		log.Printf(&#34;CRITICAL: Failed to open test database %s: %v&#34;, dbPath, err)
		// No db instance to close if Open failed.
		// The file might or might not have been created by storm.Open before erroring.
		// For simplicity, we exit directly. If storm.Open guarantees file creation on error,
		// an os.Remove(dbPath) could be attempted here.
		os.Exit(1)
	}

	// If storm.Open succeeded, db is valid.
	// We will explicitly close it and remove the file in the teardown phase.

	// Initialize schema
	if err := db.Init(&amp;User{}); err != nil {
		log.Printf(&#34;CRITICAL: Failed to initialize User schema for test database %s: %v&#34;, dbPath, err)
		// Attempt to clean up since DB was opened.
		_ = db.Close()        // Best effort to close the opened database.
		_ = os.Remove(dbPath) // Best effort to remove the (partially) created db file.
		os.Exit(1)
	}

	// If all setup is successful, run the tests and benchmarks.
	exitCode := m.Run()

	// Teardown phase: This runs after all tests/benchmarks in m.Run() complete.
	// It&#39;s crucial to attempt cleanup regardless of test outcomes.
	if err := db.Close(); err != nil {
		log.Printf(&#34;Warning: Failed to close test database %s: %v&#34;, dbPath, err)
	}
	if err := os.Remove(dbPath); err != nil {
		// This might fail if db.Close() didn&#39;t release a lock, or due to permissions, etc.
		log.Printf(&#34;Warning: Failed to remove test database file %s: %v&#34;, dbPath, err)
	}

	os.Exit(exitCode) // Exit with the status code from m.Run()
}

// Your User struct definition would need to be accessible here.
// (Assuming User struct is defined as in previous contexts or in main.go of package main)
// type User struct {
// 	ID uint `storm:&#34;id,increment&#34;`
// 	// ... other fields
// }

func BenchmarkAll(b *testing.B) {
	var users []User
	b.ResetTimer()
	for i := 0; i &lt; b.N; i++ {
		if err := db.All(&amp;users); err != nil {
			b.Fatalf(&#34;db.All() failed: %v&#34;, err)
		}
	}
}

func BenchmarkAllIndex(b *testing.B) {
	var users []User
	b.ResetTimer()
	for i := 0; i &lt; b.N; i++ {
		// Assuming &#34;ID&#34; is an indexed field in your User struct.
		// If User struct has `storm:&#34;id,increment&#34;`, &#34;ID&#34; is implicitly indexed.
		if err := db.AllByIndex(&#34;ID&#34;, &amp;users); err != nil {
			b.Fatalf(&#34;db.AllByIndex(\&#34;ID\&#34;, &amp;users) failed: %v&#34;, err)
		}
	}
}

" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="benchmark example" value="func BenchmarkAll(b *testing.B) {
	// Ensure some data exists for a meaningful benchmark,
	// or benchmark the &#34;no data&#34; case if that&#39;s intended.
	// For example, you might add a setup step here or in TestMain
	// to populate the DB if benchmarking retrieval from a populated DB.

	// Example: Add a dummy user if the DB is empty for this benchmark
	// This setup should ideally be outside the b.N loop for accurate benchmarking
	// or done once in TestMain if the data should persist across all benchmarks.
	// For simplicity here, we&#39;ll assume the DB might be empty or have data.

	b.ResetTimer() // Reset timer to exclude setup time if any was done before this line
	for i := 0; i &lt; b.N; i++ {
		var users []User // Use var to avoid re-declaration issues in loop if not careful
		if err := db.All(&amp;users); err != nil {
			// In benchmarks, b.Fatal or b.Error is preferred over panic
			// as it integrates better with the testing framework.
			b.Fatalf(&#34;db.All() failed: %v&#34;, err)
		}
	}
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="err error inline if" value="err != nil {
    $END$
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="storm init (bolt)" value="db, err := storm.Open(&#34;my.db&#34;) // Check for errors when opening
if err != nil {
    log.Fatalf(&#34;Failed to open database: %v&#34;, err)
}
defer db.Close()

if err := db.Init(&amp;User{}); err != nil {
    panic(err)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="cache in memory" value="// Create a cache with a default expiration time of 5 minutes, and which
// purges expired items every 10 minutes
c := cache.New(5*time.Minute, 10*time.Minute)

// Set the value of the key &#34;foo&#34; to &#34;bar&#34;, with the default expiration time
c.Set(&#34;foo&#34;, &#34;bar&#34;, cache.DefaultExpiration)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="slog setup" value="func setupLogger(isProd bool) slog.Handler {
	if isProd {
		logFile, err := os.OpenFile(&#34;app.json&#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
		if err != nil {
			fmt.Fprintf(os.Stderr, &#34;Failed to open log file: %v\n&#34;, err)
			os.Exit(1)
		}
		return slog.NewJSONHandler(logFile, &amp;slog.HandlerOptions{
			AddSource: true,
			Level:     slog.LevelInfo,
		})
	}
	return slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
		AddSource: true,
		Level:     slog.LevelDebug,
	})
}

// handler := setupLogger(*isProd)
// logger := slog.New(handler)
// slog.SetDefault(logger)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="context set" value="const contextLang contextKeyLang = &#34;lang&#34;
type contextKeyLang string

ctx := context.WithValue(r.Context(), contextLang, targetLang)
next.ServeHTTP(w, r.WithContext(ctx))
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="parse templates fs" value="var templ *template.Template

var parseErr error
templ, parseErr = template.New(&#34;&#34;).ParseFS(f, &#34;templates/*.tmpl&#34;, &#34;templates/**/*.tmpl&#34;)
if parseErr != nil {
    slog.Error(&#34;Failed to parse templates&#34;, &#34;error&#34;, parseErr)
    os.Exit(1)
}


err := templ.ExecuteTemplate(w, &#34;lang.tmpl&#34;, data)
if err != nil {
    slog.Error(&#34;Failed to execute template lang.tmpl&#34;, &#34;error&#34;, err, &#34;lang&#34;, lang)
    http.Error(w, &#34;Internal Server Error&#34;, http.StatusInternalServerError)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="context get" value="lang := r.Context().Value(contextLang).(string)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="middleware concatenation" value="var finalHandler http.Handler = mux
finalHandler = languageMiddleware(finalHandler)
finalHandler = gzipMiddleware(finalHandler)
finalHandler = recoveryMiddleware(finalHandler)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="embedd extract subfolder" value="//go:embed assets/* templates/*
var f embed.FS

assetsFS, fsErr := fs.Sub(f, &#34;assets&#34;)
if fsErr != nil {
    slog.Error(&#34;Failed to get sub FS for assets&#34;, &#34;error&#34;, fsErr)
    os.Exit(1)
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="wr" value="func $START(w http.ResponseWriter, r *http.Request) {
	$END$
}
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
  <template name="path value from url" value="dynamic := r.PathValue(&#34;dynamic&#34;)
" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true"/>
    </context>
  </template>
</templateSet>
