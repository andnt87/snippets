{
  "base64 encoding and decoding": {
    "body": [
      "// using encoder/ decoder\nbuffer := bytes.Buffer{}\n\n// encode into the buffer\nencoder := base64.NewEncoder(base64.StdEncoding, \u0026buffer)\n\nif _, err := encoder.Write([]byte(\"encoding some other data\")); err != nil {\n    log.Fatalln(err)\n}\n\n// be sure to close\nif err := encoder.Close(); err != nil {\n    log.Fatalln(err)\n}\n\nfmt.Println(\"Using encoder and StdEncoding: \", buffer.String())\n\n// decoder \ndecoder := base64.NewDecoder(base64.StdEncoding, \u0026buffer)\nresults, err := ioutil.ReadAll(decoder)\nif err != nil {\n    log.Fatalln(err)\n}\n\nfmt.Println(\"Using decoder and StdEncoding: \", string(results))\n"
    ],
    "description": "",
    "prefix": "base64 encoding and decoding"
  },
  "benchmark example": {
    "body": [
      "func BenchmarkAll(b *testing.B) {\n\t// Ensure some data exists for a meaningful benchmark,\n\t// or benchmark the \"no data\" case if that's intended.\n\t// For example, you might add a setup step here or in TestMain\n\t// to populate the DB if benchmarking retrieval from a populated DB.\n\n\t// Example: Add a dummy user if the DB is empty for this benchmark\n\t// This setup should ideally be outside the b.N loop for accurate benchmarking\n\t// or done once in TestMain if the data should persist across all benchmarks.\n\t// For simplicity here, we'll assume the DB might be empty or have data.\n\n\tb.ResetTimer() // Reset timer to exclude setup time if any was done before this line\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tvar users []User // Use var to avoid re-declaration issues in loop if not careful\n\t\tif err := db.All(\u0026users); err != nil {\n\t\t\t// In benchmarks, b.Fatal or b.Error is preferred over panic\n\t\t\t// as it integrates better with the testing framework.\n\t\t\tb.Fatalf(\"db.All() failed: %v\", err)\n\t\t}\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "benchmark example"
  },
  "binance connect": {
    "body": [
      "func binanceConnect() *bc.Client {\n\tapiKey := os.Getenv(\"BINANCE_PUBLIC\")\n\tsecretKey := os.Getenv(\"BINANCE_SECRET\")\n\tbaseURL := \"https://api.binance.com\"\n\treturn bc.NewClient(apiKey, secretKey, baseURL)\n}\n\nfunc binanceConnectTest() *bc.Client {\n\tapiKey := os.Getenv(\"BINANCE_PUBLIC_TEST\")\n\tsecretKey := os.Getenv(\"BINANCE_SECRET_TEST\")\n\tbaseURL := \"https://testnet.binance.vision\"\n\treturn bc.NewClient(apiKey, secretKey, baseURL)\n}\n"
    ],
    "description": "",
    "prefix": "binance connect"
  },
  "cache event (avoid duplicates)": {
    "body": [
      "eventCache := make(map[string]time.Time)\n\nnow := time.Now()\nif lastEventTime, exists := eventCache[event.Name]; exists \u0026\u0026 now.Sub(lastEventTime) \u003c 100*time.Millisecond {\n    continue\n}\neventCache[event.Name] = now\n"
    ],
    "description": "",
    "prefix": "cache event (avoid duplicates)"
  },
  "cache in memory": {
    "body": [
      "// Create a cache with a default expiration time of 5 minutes, and which\n// purges expired items every 10 minutes\nc := cache.New(5*time.Minute, 10*time.Minute)\n\n// Set the value of the key \"foo\" to \"bar\", with the default expiration time\nc.Set(\"foo\", \"bar\", cache.DefaultExpiration)\n"
    ],
    "description": "",
    "prefix": "cache in memory"
  },
  "comment for goland (TIP)": {
    "body": [
      "//TIP \u003cp\u003eTo run your code, right-click the code and select \u003cb\u003eRun\u003c/b\u003e.\u003c/p\u003e \u003cp\u003eAlternatively, click\n// the \u003cicon src=\"AllIcons.Actions.Execute\"/\u003e icon in the gutter and select the \u003cb\u003eRun\u003c/b\u003e menu item from here.\u003c/p\u003e\n"
    ],
    "description": "",
    "prefix": "comment for goland (TIP)"
  },
  "concurrency channel range and close": {
    "body": [
      "func fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i \u003c n; i++ {\n\t\tc \u003c- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc rangeEx() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "concurrency channel range and close"
  },
  "concurrency channels semaphore balance": {
    "body": [
      "var (\n\tsema    = make(chan struct{}, 1) // a binary semaphore guarding balance\n\tbalance int\n)\n\nfunc Deposit(amount int) {\n\tsema \u003c- struct{}{} // acquire token\n\tbalance = balance + amount\n\t\u003c-sema // release token\n}\n\nfunc Balance() int {\n\tsema \u003c- struct{}{} // acquire token\n\tb := balance\n\t\u003c-sema // release token\n\treturn b\n}\n"
    ],
    "description": "",
    "prefix": "concurrency channels semaphore balance"
  },
  "concurrency channels tick and after": {
    "body": [
      "tick := time.Tick(100 * time.Millisecond)\nboom := time.After(500 * time.Millisecond)\nfor {\n    select {\n    case \u003c-tick:\n        fmt.Println(\"tick.\")\n    case \u003c-boom:\n        fmt.Println(\"BOOM!\")\n        return\n    default:\n        fmt.Println(\"    .\")\n        time.Sleep(50 * time.Millisecond)\n    }\n}\n"
    ],
    "description": "",
    "prefix": "concurrency channels tick and after"
  },
  "concurrency rw mutex (RWMutex)": {
    "body": [
      "// sync.RWMutex is bad for performance. (Use sync.Map)\n"
    ],
    "description": "",
    "prefix": "concurrency rw mutex (RWMutex)"
  },
  "concurrency sync mutex balance": {
    "body": [
      "var (\n\tmu      sync.Mutex // guards balance\n\tbalance int\n)\n\nfunc Deposit(amount int) {\n\tmu.Lock()\n\tbalance = balance + amount\n\tmu.Unlock()\n}\n\nfunc Balance() int {\n\tmu.Lock()\n\tb := balance\n\tmu.Unlock()\n\treturn b\n}\n"
    ],
    "description": "",
    "prefix": "concurrency sync mutex balance"
  },
  "context check if authenticated": {
    "body": [
      "user, ok := r.Context().Value(\"auth\").(db.User)\nif !ok || user.Email == \"\" {\n    cookies.FlashSetWithRedirect(w, r, \"Please login\", \"/login\")\n    return\n}\n"
    ],
    "description": "",
    "prefix": "context check if authenticated"
  },
  "context get": {
    "body": [
      "lang := r.Context().Value(contextLang).(string)\n"
    ],
    "description": "",
    "prefix": "context get"
  },
  "context set": {
    "body": [
      "const contextLang contextKeyLang = \"lang\"\ntype contextKeyLang string\n\nctx := context.WithValue(r.Context(), contextLang, targetLang)\nnext.ServeHTTP(w, r.WithContext(ctx))\n"
    ],
    "description": "",
    "prefix": "context set"
  },
  "cookie package": {
    "body": [
      "package cookies\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar (\n\tErrValueTooLong = errors.New(\"cookie value too long\")\n\tErrInvalidValue = errors.New(\"invalid cookie value\")\n)\n\nfunc Write(w http.ResponseWriter, cookie http.Cookie) error {\n\tcookie.Value = base64.URLEncoding.EncodeToString([]byte(cookie.Value))\n\n\tif len(cookie.String()) \u003e 4096 {\n\t\treturn ErrValueTooLong\n\t}\n\n\thttp.SetCookie(w, \u0026cookie)\n\n\treturn nil\n}\n\nfunc Read(r *http.Request, name string) (string, error) {\n\tcookie, err := r.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvalue, err := base64.URLEncoding.DecodeString(cookie.Value)\n\tif err != nil {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\treturn string(value), nil\n}\n\nfunc WriteSigned(w http.ResponseWriter, cookie http.Cookie, secretKey string) error {\n\tmac := hmac.New(sha256.New, []byte(secretKey))\n\tmac.Write([]byte(cookie.Name))\n\tmac.Write([]byte(cookie.Value))\n\tsignature := mac.Sum(nil)\n\n\tcookie.Value = string(signature) + cookie.Value\n\n\treturn Write(w, cookie)\n}\n\nfunc ReadSigned(r *http.Request, name string, secretKey string) (string, error) {\n\tsignedValue, err := Read(r, name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(signedValue) \u003c sha256.Size {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\tsignature := signedValue[:sha256.Size]\n\tvalue := signedValue[sha256.Size:]\n\n\tmac := hmac.New(sha256.New, []byte(secretKey))\n\tmac.Write([]byte(name))\n\tmac.Write([]byte(value))\n\texpectedSignature := mac.Sum(nil)\n\n\tif !hmac.Equal([]byte(signature), expectedSignature) {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\treturn value, nil\n}\n\nfunc WriteEncrypted(w http.ResponseWriter, cookie http.Cookie, secretKey string) error {\n\tblock, err := aes.NewCipher([]byte(secretKey))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\t_, err = io.ReadFull(rand.Reader, nonce)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tplaintext := fmt.Sprintf(\"%s:%s\", cookie.Name, cookie.Value)\n\n\tencryptedValue := aesGCM.Seal(nonce, nonce, []byte(plaintext), nil)\n\n\tcookie.Value = string(encryptedValue)\n\n\treturn Write(w, cookie)\n}\n\nfunc ReadEncrypted(r *http.Request, name string, secretKey string) (string, error) {\n\tencryptedValue, err := Read(r, name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher([]byte(secretKey))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\n\tif len(encryptedValue) \u003c nonceSize {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\tnonce := encryptedValue[:nonceSize]\n\tciphertext := encryptedValue[nonceSize:]\n\n\tplaintext, err := aesGCM.Open(nil, []byte(nonce), []byte(ciphertext), nil)\n\tif err != nil {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\texpectedName, value, ok := strings.Cut(string(plaintext), \":\")\n\tif !ok {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\tif expectedName != name {\n\t\treturn \"\", ErrInvalidValue\n\t}\n\n\treturn value, nil\n}\n\n"
    ],
    "description": "",
    "prefix": "cookie package"
  },
  "cookie set flash and get flash": {
    "body": [
      "const flashCookie = \"flash\"\n\n// setFlash sets a flash message in a cookie\nfunc setFlash(w http.ResponseWriter, name, value string) {\n\tc := \u0026http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     \"/\",\n\t\tMaxAge:   1, // The cookie will be deleted after 1 second\n\t\tHttpOnly: true,\n\t\tSecure:   true,\n\t}\n\thttp.SetCookie(w, c)\n}\n\n// getFlash retrieves and clears a flash message from a cookie\nfunc getFlash(w http.ResponseWriter, r *http.Request, name string) (string, error) {\n\tc, err := r.Cookie(name)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase http.ErrNoCookie:\n\t\t\treturn \"\", nil // No flash message\n\t\tdefault:\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\t// Clear the cookie\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tPath:     \"/\",\n\t\tMaxAge:   -1, // Delete the cookie\n\t\tHttpOnly: true,\n\t\tSecure:   true,\n\t})\n\n\treturn c.Value, nil\n}\n\nsetFlash(w, flashCookie, \"Invalid credentials\")\n\nflashMsg, _ := getFlash(w, r, flashCookie)\n\ndata := map[string]interface{}{\n    \"FlashMsg\":  flashMsg,\n}\n\n{{if .FlashMsg}}\n    \u003cp style=\"color: green;\"\u003e{{.FlashMsg}}\u003c/p\u003e\n{{end}}\n"
    ],
    "description": "",
    "prefix": "cookie set flash and get flash"
  },
  "cookies and flash (package)": {
    "body": [
      "package cookies\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"play/internals/config\"\n\t\"time\"\n)\n\n// Configurable settings (inject via config package or constants)\nvar (\n\tsecureCookies bool\n)\n\nfunc init() {\n\tif config.Config.IsProd {\n\t\tsecureCookies = true\n\t}\n}\n\n// Set sets a secure cookie with optional expiration.\nfunc Set(w http.ResponseWriter, name, value string, expiry time.Time) {\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tValue:    base64.URLEncoding.EncodeToString([]byte(value)),\n\t\tPath:     \"/\",\n\t\tDomain:   config.Config.Domain,\n\t\tExpires:  expiry,\n\t\tSecure:   secureCookies,\n\t\tHttpOnly: true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t})\n}\n\n// Get retrieves a cookie by name without modifying it.\nfunc Get(r *http.Request, name string) (*http.Cookie, error) {\n\treturn r.Cookie(name)\n}\n\nfunc GetValue(r *http.Request, name string) (string, error) {\n\tcookie, err := r.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvalue, err := base64.URLEncoding.DecodeString(cookie.Value)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(value), nil\n}\n\n// Delete removes a cookie immediately.\nfunc Delete(w http.ResponseWriter, name string) {\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tPath:     \"/\",\n\t\tDomain:   config.Config.Domain,\n\t\tMaxAge:   -1,\n\t\tSecure:   secureCookies,\n\t\tHttpOnly: true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t})\n}\n\n// FlashSet sets a short-lived flash cookie.\nfunc FlashSet(w http.ResponseWriter, name, value string) {\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tValue:    base64.URLEncoding.EncodeToString([]byte(value)),\n\t\tPath:     \"/\",\n\t\tDomain:   config.Config.Domain,\n\t\tMaxAge:   10,\n\t\tSecure:   secureCookies,\n\t\tHttpOnly: true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t})\n}\n\n// FlashGet retrieves a flash message and deletes it in the same request cycle.\nfunc FlashGet(w http.ResponseWriter, r *http.Request, name string) (string, error) {\n\tcookie, err := r.Cookie(name)\n\tif err != nil {\n\t\tif err == http.ErrNoCookie {\n\t\t\treturn \"\", nil\n\t\t}\n\t\treturn \"\", err\n\t}\n\n\t// Immediately clear after reading\n\tDelete(w, name)\n\n\tvalue, err := base64.URLEncoding.DecodeString(cookie.Value)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(value), nil\n}\n\n"
    ],
    "description": "",
    "prefix": "cookies and flash (package)"
  },
  "crawl goquery get links": {
    "body": [
      "// \"github.com/PuerkitoBio/goquery\"\n\n// extractLinks extracts the data-href attributes from the buttons with the specified class.\n// button has classes: button-as-link get-code-btn\nfunc extractLinks(page string) []string {\n\t// Use the goquery package to parse the HTML page\n\tdoc, err := goquery.NewDocumentFromReader(strings.NewReader(page))\n\tif err != nil {\n\t\tlog.Fatalln(\"Error parsing HTML:\", err)\n\t}\n\n\t// Create a slice to store the links\n\tvar links []string\n\n\t// Find all buttons with the specified class and extract their data-href attributes\n\tdoc.Find(\"button.button-as-link.get-code-btn\").Each(func(i int, s *goquery.Selection) {\n\t\tif href, exists := s.Attr(\"data-href\"); exists {\n\t\t\tlinks = append(links, href)\n\t\t}\n\t})\n\n\treturn links\n}\n"
    ],
    "description": "",
    "prefix": "crawl goquery get links"
  },
  "crawl goquery nested example": {
    "body": [
      "/*\n\n// \"github.com/PuerkitoBio/goquery\"\n\n\u003cul id=\"stitch-list\"\u003e\n    \u003cli class=\"dropdown\"\u003e\n        \u003cspan class=\"category category_toggle\"\u003eE-Commerce\u003c/span\u003e\n        \u003cul class=\"child_list\"\u003e\n            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/100\"\u003eAll \u003cspan class=\"cat-options\"\u003e(23)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/232\"\u003eCollections \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli class=\"dropdown\"\u003e\n        \u003cspan class=\"category category_toggle\"\u003eButtons\u003c/span\u003e\n        \u003cul class=\"child_list\"\u003e\n            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/22\"\u003eAll \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n*/\n\ndoc, err := goquery.NewDocumentFromReader(bytes.NewReader(htmlFile))\nif err != nil {\n    log.Fatalln(\"Error loading HTML:\", err)\n}\n\ndoc.Find(\"li.dropdown\").Each(func(i int, s *goquery.Selection) {\n    name := s.Find(\"span.category_toggle\").Text()\n    fmt.Println(\"Element:\", name)\n\n    // Find sub-items\n    s.Find(\"ul.child_list a\").Each(func(j int, a *goquery.Selection) {\n        href, exists := a.Attr(\"href\")\n        if exists {\n            value := a.Find(\"span.cat-options\").Text()\n            fmt.Printf(\"  - Link: %s | Value: %s\\n\", href, value)\n        }\n    })\n})\n"
    ],
    "description": "",
    "prefix": "crawl goquery nested example"
  },
  "crawl html, scrap example": {
    "body": [
      "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\n// Structure to hold extracted data\ntype Item struct {\n\tCategory string\n\tLinks    []LinkInfo\n}\n\ntype LinkInfo struct {\n\tHref  string\n\tCount string\n}\n\nfunc main() {\n\thtmlContent := `\n\t\u003cul id=\"stitch-list\"\u003e\n\t\t\u003cli class=\"dropdown \"\u003e\n\t\t\t\u003cspan class=\"category category_toggle\"\u003eE-Commerce\u003c/span\u003e\n\t\t\t\u003cul class=\"child_list\"\u003e\n\t\t\t\t\u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/100\"\u003eAll \u003cspan class=\"cat-options\"\u003e(23)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t\t\t\u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/232\"\u003eCollections \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t\t\u003c/ul\u003e\n\t\t\u003c/li\u003e\n\t\t\u003cli class=\"dropdown \"\u003e\n\t\t\t\u003cspan class=\"category category_toggle\"\u003eButtons\u003c/span\u003e\n\t\t\t\u003cul class=\"child_list\"\u003e\n\t\t\t\t\u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/22\"\u003eAll \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t\t\u003c/ul\u003e\n\t\t\u003c/li\u003e\n\t\u003c/ul\u003e`\n\n\tdoc, err := html.Parse(strings.NewReader(htmlContent))\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing HTML:\", err)\n\t\treturn\n\t}\n\n\t// Extract categories with links dynamically\n\tdata := extractItems(doc, \"li\", \"dropdown \", \"span\", \"category category_toggle\", \"a\", \"href\", \"span\", \"cat-options\")\n\n\t// Print extracted data\n\tfor _, item := range data {\n\t\tfmt.Println(\"Category:\", item.Category)\n\t\tfor _, link := range item.Links {\n\t\t\tfmt.Printf(\"  - URL: %s | Count: %s\\n\", link.Href, link.Count)\n\t\t}\n\t}\n}\n\n// extractItems extracts data based on provided HTML structure details\nfunc extractItems(n *html.Node, parentTag, parentClass, categoryTag, categoryClass, linkTag, linkAttr, countTag, countClass string) []Item {\n\tvar items []Item\n\n\t// Traverse and find elements\n\tvar traverse func(*html.Node)\n\ttraverse = func(n *html.Node) {\n\t\tif n.Type == html.ElementNode \u0026\u0026 n.Data == parentTag {\n\t\t\tif getAttribute(n, \"class\") == parentClass {\n\t\t\t\tcategory := extractTextByClass(n, categoryTag, categoryClass)\n\t\t\t\tlinks := extractLinks(n, linkTag, linkAttr, countTag, countClass)\n\t\t\t\titems = append(items, Item{Category: category, Links: links})\n\t\t\t}\n\t\t}\n\t\t// Recursively check child nodes\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\ttraverse(c)\n\t\t}\n\t}\n\n\ttraverse(n)\n\treturn items\n}\n\n// extractLinks finds all links and their counts within a section\nfunc extractLinks(n *html.Node, linkTag, linkAttr, countTag, countClass string) []LinkInfo {\n\tvar links []LinkInfo\n\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif c.Type == html.ElementNode \u0026\u0026 c.Data == \"ul\" {\n\t\t\tfor li := c.FirstChild; li != nil; li = li.NextSibling {\n\t\t\t\tif li.Type == html.ElementNode \u0026\u0026 li.Data == \"li\" {\n\t\t\t\t\thref, count := extractLinkAndCount(li, linkTag, linkAttr, countTag, countClass)\n\t\t\t\t\tif href != \"\" \u0026\u0026 count != \"\" {\n\t\t\t\t\t\tlinks = append(links, LinkInfo{Href: href, Count: count})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn links\n}\n\n// extractLinkAndCount extracts href and count values\nfunc extractLinkAndCount(n *html.Node, linkTag, linkAttr, countTag, countClass string) (string, string) {\n\tvar href, count string\n\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif c.Type == html.ElementNode \u0026\u0026 c.Data == linkTag {\n\t\t\thref = getAttribute(c, linkAttr)\n\t\t\tcount = extractTextByClass(c, countTag, countClass)\n\t\t}\n\t}\n\n\treturn href, count\n}\n\n// extractTextByClass finds text within an element of a specific class\nfunc extractTextByClass(n *html.Node, tag, class string) string {\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tif c.Type == html.ElementNode \u0026\u0026 c.Data == tag {\n\t\t\tif getAttribute(c, \"class\") == class {\n\t\t\t\treturn getText(c)\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// getAttribute returns the value of a given attribute\nfunc getAttribute(n *html.Node, key string) string {\n\tfor _, attr := range n.Attr {\n\t\tif attr.Key == key {\n\t\t\treturn attr.Val\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// getText retrieves all text from a node\nfunc getText(n *html.Node) string {\n\tif n.Type == html.TextNode {\n\t\treturn strings.TrimSpace(n.Data)\n\t}\n\n\tvar text string\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\ttext += getText(c)\n\t}\n\treturn strings.TrimSpace(text)\n}\n\n"
    ],
    "description": "",
    "prefix": "crawl html, scrap example"
  },
  "decimal from string": {
    "body": [
      "money, _ := decimal.NewFromString(moneyStr)\n"
    ],
    "description": "",
    "prefix": "decimal from string"
  },
  "decrypt int": {
    "body": [
      "func decryptTokenId(token string, secretKey []byte) (uint, error) {\n\tciphertext, err := base64.URLEncoding.DecodeString(token)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"base64 decode error: %w\", err)\n\t}\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"cipher error: %w\", err)\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"GCM error: %w\", err)\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\tif len(ciphertext) \u003c nonceSize {\n\t\treturn 0, fmt.Errorf(\"ciphertext too short\")\n\t}\n\n\tnonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n\tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"decryption failed: %w\", err)\n\t}\n\n\tparts := strings.SplitN(string(plaintext), \"|\", 2)\n\tif len(parts) != 2 {\n\t\treturn 0, fmt.Errorf(\"invalid token format\")\n\t}\n\n\tid64, err := strconv.ParseUint(parts[0], 10, 0)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"invalid user ID: %w\", err)\n\t}\n\n\texpiry, err := time.Parse(time.RFC3339, parts[1])\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"invalid timestamp: %w\", err)\n\t}\n\n\tif time.Now().After(expiry) {\n\t\treturn 0, fmt.Errorf(\"token expired\")\n\t}\n\n\treturn uint(id64), nil\n}\n"
    ],
    "description": "",
    "prefix": "decrypt int"
  },
  "decrypt string": {
    "body": [
      "func decryptToken(token string, secretKey []byte) (string, error) {\n\tciphertext, err := base64.URLEncoding.DecodeString(token)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\tif len(ciphertext) \u003c nonceSize {\n\t\treturn \"\", fmt.Errorf(\"ciphertext too short\")\n\t}\n\n\tnonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n\tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparts := strings.SplitN(string(plaintext), \"|\", 2)\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid token format\")\n\t}\n\n\texpiry, err := time.Parse(time.RFC3339, parts[1])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif time.Now().After(expiry) {\n\t\treturn \"\", fmt.Errorf(\"token has expired\")\n\t}\n\n\treturn parts[0], nil\n}\n"
    ],
    "description": "",
    "prefix": "decrypt string"
  },
  "dir walk (filepath)": {
    "body": [
      "var staticFiles []string\nerr = filepath.WalkDir(\".\", func(path string, d fs.DirEntry, err error) error {  \n   if !d.IsDir() {  \n      ext := filepath.Ext(d.Name())  \n      if ext == \".html\" || ext == \".css\" || ext == \".js\" {  \n         // open html file  \n         staticFiles = append(staticFiles, path)  \n      }  \n   }  \n   return nil  \n})  \n  \nif err != nil {  \n   panic(err)  \n}\n"
    ],
    "description": "",
    "prefix": "dir walk (filepath)"
  },
  "embedd extract subfolder": {
    "body": [
      "//go:embed assets/* templates/*\nvar f embed.FS\n\nassetsFS, fsErr := fs.Sub(f, \"assets\")\nif fsErr != nil {\n    slog.Error(\"Failed to get sub FS for assets\", \"error\", fsErr)\n    os.Exit(1)\n}\n"
    ],
    "description": "",
    "prefix": "embedd extract subfolder"
  },
  "encrypt int": {
    "body": [
      "func encryptTokenId(id uint, secretKey []byte) (string, error) {\n\t// Convert uint to string safely\n\tidStr := strconv.FormatUint(uint64(id), 10)\n\tplaintext := []byte(idStr + \"|\" + time.Now().Add(1*time.Hour).Format(time.RFC3339))\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"cipher error: %w\", err)\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"GCM error: %w\", err)\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", fmt.Errorf(\"nonce error: %w\", err)\n\t}\n\n\tciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)\n\treturn base64.URLEncoding.EncodeToString(ciphertext), nil\n}\n"
    ],
    "description": "",
    "prefix": "encrypt int"
  },
  "encrypt string": {
    "body": [
      "func encryptToken(email string, secretKey []byte) (string, error) {\n\tplaintext := []byte(email + \"|\" + time.Now().Add(1*time.Hour).Format(time.RFC3339))\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)\n\treturn base64.URLEncoding.EncodeToString(ciphertext), nil\n}\n"
    ],
    "description": "",
    "prefix": "encrypt string"
  },
  "env get from file + config": {
    "body": [
      "import (\n\t\"github.com/joho/godotenv\"\n\t\"log\"\n)\n\nfunc init() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file\")\n\t}\n}\n\ntype config struct {\n\tbaseURL   string\n\thttpPort  int\n\tbasicAuth struct {\n\t\tusername       string\n\t\thashedPassword string\n\t}\n\tcookie struct {\n\t\tsecretKey string\n\t}\n\tdb struct {\n\t\tdsn         string\n\t\tautomigrate bool\n\t}\n\tnotifications struct {\n\t\temail string\n\t}\n\tsession struct {\n\t\tsecretKey    string\n\t\toldSecretKey string\n\t}\n\tsmtp struct {\n\t\thost     string\n\t\tport     int\n\t\tusername string\n\t\tpassword string\n\t\tfrom     string\n\t}\n}\n\nvar cfg config\n\ncfg.baseURL = os.Getenv(\"BASE_URL\")\ncfg.httpPort = os.Getenv(\"HTTP_PORT\") // Parse if integer\ncfg.basicAuth.username = os.Getenv(\"BASIC_AUTH_USERNAME\")\ncfg.basicAuth.hashedPassword = os.Getenv(\"BASIC_AUTH_HASHED_PASSWORD\")\ncfg.cookie.secretKey = os.Getenv(\"COOKIE_SECRET_KEY\")\ncfg.db.dsn = os.Getenv(\"DB_DSN\")\ncfg.db.automigrate = os.Getenv(\"DB_AUTOMIGRATE\") // Parse if boolean\ncfg.notifications.email = os.Getenv(\"NOTIFICATIONS_EMAIL\")\ncfg.session.secretKey = os.Getenv(\"SESSION_SECRET_KEY\")\ncfg.session.oldSecretKey = os.Getenv(\"SESSION_OLD_SECRET_KEY\")\ncfg.smtp.host = os.Getenv(\"SMTP_HOST\")\ncfg.smtp.port = os.Getenv(\"SMTP_PORT\") // Parse if integer\ncfg.smtp.username = os.Getenv(\"SMTP_USERNAME\")\ncfg.smtp.password = os.Getenv(\"SMTP_PASSWORD\")\ncfg.smtp.from = os.Getenv(\"SMTP_FROM\")\n"
    ],
    "description": "",
    "prefix": "env get from file + config"
  },
  "env helpers": {
    "body": [
      "\nfunc GetString(key, defaultValue string) string {\n\tvalue, exists := os.LookupEnv(key)\n\tif !exists {\n\t\treturn defaultValue\n\t}\n\n\treturn value\n}\n\nfunc GetInt(key string, defaultValue int) int {\n\tvalue, exists := os.LookupEnv(key)\n\tif !exists {\n\t\treturn defaultValue\n\t}\n\n\tintValue, err := strconv.Atoi(value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn intValue\n}\n\nfunc GetBool(key string, defaultValue bool) bool {\n\tvalue, exists := os.LookupEnv(key)\n\tif !exists {\n\t\treturn defaultValue\n\t}\n\n\tboolValue, err := strconv.ParseBool(value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn boolValue\n}\n"
    ],
    "description": "",
    "prefix": "env helpers"
  },
  "envirment get value": {
    "body": [
      "apiKey := os.Getenv(\"BINANCE_PUBLIC\")\n"
    ],
    "description": "",
    "prefix": "envirment get value"
  },
  "err error inline if": {
    "body": [
      "err != nil {\n    $END$\n}\n"
    ],
    "description": "",
    "prefix": "err error inline if"
  },
  "errgroup example": {
    "body": [
      "errg, ctx := errgroup.WithContext(context.Background())\nstepSize, minNotional, priceStr := decimal.Decimal{}, decimal.Decimal{}, []*bc.TickerPriceResponse{}\n\nerrg.Go(func() error {\n    if ctx.Err() != nil {\n        return ctx.Err()\n    }\n    var err error\n    // Fetch symbol info (precision, minNotional)\n    stepSize, minNotional, err = getSymbolFilters(client, symbol)\n    if err != nil {\n        return err\n    }\n    return nil\n})\n\nerrg.Go(func() error {\n    if ctx.Err() != nil {\n        return ctx.Err()\n    }\n    var err error\n    // Fetch latest price\n    priceStr, err = getLatestPrice(client, symbol)\n    if err != nil {\n        return err\n    }\n    return nil\n})\n\nif err := errg.Wait(); err != nil {\n    return 0, err\n}\n"
    ],
    "description": "",
    "prefix": "errgroup example"
  },
  "file append": {
    "body": [
      "f, err := os.OpenFile(cssPath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)\nif err != nil {\n    log.Fatal(err)\n}\ndefer f.Close()\n\nif _, err := f.Write([]byte(css)); err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file append"
  },
  "file change permission": {
    "body": [
      "// Change perrmissions using Linux style\nerr := os.Chmod(\"test.txt\", 0777)\nif err != nil {\n    log.Println(err)\n}\n"
    ],
    "description": "",
    "prefix": "file change permission"
  },
  "file copy content of file to another file": {
    "body": [
      "// Open original file\noriginalFile, err := os.Open(\"test.txt\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer originalFile.Close()\n\n// Create new file\nnewFile, err := os.Create(\"test_copy.txt\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer newFile.Close()\n\n// Copy the bytes to destination from source\nbytesWritten, err := io.Copy(newFile, originalFile)\nif err != nil {\n    log.Fatal(err)\n}\nlog.Printf(\"Copied %d bytes.\", bytesWritten)\n\n// Commit the file contents\n// Flushes memory to disk\nerr = newFile.Sync()\nif err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file copy content of file to another file"
  },
  "file copy from src to dst": {
    "body": [
      "// CopyFileFromSrcToDst copies pathSrcFile to pathDstFile\nfunc CopyFileFromSrcToDst(pathSrcFile, pathDstFile string) error {\n\t// Open original file\n\toriginalFile, err := os.Open(pathSrcFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer originalFile.Close()\n\n\t// Create new file\n\tnewFile, err := os.Create(pathDstFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer newFile.Close()\n\n\t// Copy the bytes to destination from source\n\tbytesWritten, err := io.Copy(newFile, originalFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Printf(\"Copied %d bytes.\", bytesWritten)\n\n\t// Commit the file contents\n\t// Flushes memory to disk\n\terr = newFile.Sync()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
    ],
    "description": "",
    "prefix": "file copy from src to dst"
  },
  "file cross platform path": {
    "body": [
      "examplePath2 := filepath.FromSlash(\"dir/example\")\n"
    ],
    "description": "",
    "prefix": "file cross platform path"
  },
  "file delete single": {
    "body": [
      "if err := os.Remove(\"file1.txt\"); err != nil {\n  return err\n}\n"
    ],
    "description": "",
    "prefix": "file delete single"
  },
  "file dir !exist": {
    "body": [
      "if _, err := os.Stat(\"dirPath\"); err != nil {\n    fmt.Println(\"dirPath does not exist\")\n}\n"
    ],
    "description": "",
    "prefix": "file dir !exist"
  },
  "file dir exist": {
    "body": [
      "if info, err := os.Stat(\"mydir\"); err == nil \u0026\u0026 info.IsDir() {\n    fmt.Println(\"mydir exists and is a directory\")\n}\n"
    ],
    "description": "",
    "prefix": "file dir exist"
  },
  "file embedding([]byte) and write": {
    "body": [
      "//go:embed reload.html\nvar reloadHtmlFile []byte\n\nhttp.HandleFunc(\"/reload\", func(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/html\")\n    w.Write(reloadHtmlFile)\n})\n"
    ],
    "description": "",
    "prefix": "file embedding([]byte) and write"
  },
  "file embedding(embed.FS) and static serve embedded directory": {
    "body": [
      "//go:embed public/*\nvar publicFiles embed.FS\n\n// root folder\npublicFiles, err := fs.Sub(publicFiles, \"public\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// public/favicon.ico\nhttp.Handle(\"/public/\", http.StripPrefix(\"/public/\", http.FileServer(http.FS(publicFiles))))\n"
    ],
    "description": "",
    "prefix": "file embedding(embed.FS) and static serve embedded directory"
  },
  "file exist": {
    "body": [
      "if info, err := os.Stat(\"go.mod\"); err == nil \u0026\u0026 !info.IsDir() {\n    fmt.Println(\"go.mod exists and is a file\")\n}\n"
    ],
    "description": "",
    "prefix": "file exist"
  },
  "file exist not": {
    "body": [
      "if _, err := os.Stat(\"myfile.txt\"); errors.Is(err, fs.ErrNotExist) {\n\t\tfmt.Println(\"myfile.txt does not exist\")\n\t}\n"
    ],
    "description": "",
    "prefix": "file exist not"
  },
  "file link": {
    "body": [
      "// Create a hard link\n// You will have two file names that point to the same contents\n// Changing the contents of one will change the other\n// Deleting/renaming one will not affect the other\nerr := os.Link(\"test.txt\", \"test_also.txt\")\nif err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file link"
  },
  "file open": {
    "body": [
      "file, err := os.Open(filePath)\nif err != nil {\n    log.Fatalln(\"Error opening file:\", err)\n}\ndefer file.Close()\n"
    ],
    "description": "",
    "prefix": "file open"
  },
  "file open (os)": {
    "body": [
      "file, err := os.OpenFile(\"test.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\nif err != nil {\n    log.Fatal(err)\n}\ndefer file.Close()\n"
    ],
    "description": "",
    "prefix": "file open (os)"
  },
  "file os path compatible": {
    "body": [
      "pathToEncrypt := filepath.ToSlash(*terminalPath)\n"
    ],
    "description": "",
    "prefix": "file os path compatible"
  },
  "file quick read (ioutil)": {
    "body": [
      "data, err := os.ReadFile(\"test.txt\")\nif err != nil {\n    log.Fatal(err)\n}\n\nlog.Printf(\"Data read: %s\\n\", data)\n"
    ],
    "description": "",
    "prefix": "file quick read (ioutil)"
  },
  "file quick write": {
    "body": [
      "err := os.WriteFile($1$, $2$, 0644)\nif err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file quick write"
  },
  "file read at least (os)": {
    "body": [
      "func FileReadAtLeastNbytes(pathFile string, minBytesToRead int) ([]byte, error) {\n\t// Open file for reading\n\tfile, err := os.Open(pathFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tminBytes := minBytesToRead\n\tbyteSlice := make([]byte, minBytesToRead*64)\n\t// io.ReadAtLeast() will return an error if it cannot\n\t// find at least minBytes to read. It will read as\n\t// many bytes as byteSlice can hold.\n\t_, err = io.ReadAtLeast(file, byteSlice, minBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn byteSlice, err\n}\n"
    ],
    "description": "",
    "prefix": "file read at least (os)"
  },
  "file read exacty": {
    "body": [
      "// FileReadExactlyNbytes reads exactly numBytesToRead from pathFile\nfunc FileReadExactlyNbytes(pathFile string, numBytesToRead int) ([]byte, error) {\n\t// Open file for reading\n\tfile, err := os.Open(pathFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t// The file.Read() function will happily read a tiny file in to a large\n\t// byte slice, but io.ReadFull() will return an\n\t// error if the file is smaller than the byte slice.\n\tbyteSlice := make([]byte, numBytesToRead)\n\t_, err = io.ReadFull(file, byteSlice)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn byteSlice, err\n}\n"
    ],
    "description": "",
    "prefix": "file read exacty"
  },
  "file read with scanner (bufio)": {
    "body": [
      "input := bufio.NewScanner(os.Stdin)\nfor input.Scan() {\n    //input.Text()\n}\nif err := input.Err(); err != nil {\n    // TODO: scanner error\n}\n"
    ],
    "description": "",
    "prefix": "file read with scanner (bufio)"
  },
  "file rename or remove": {
    "body": [
      "originalPath := \"test.txt\"\nnewPath := \"test2.txt\"\nerr := os.Rename(originalPath, newPath)\nif err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file rename or remove"
  },
  "file stat (os)": {
    "body": [
      "// Stat returns file info. It will return\n// an error if there is no file.\nfileInfo, err := os.Stat(\"test.txt\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"File name:\", fileInfo.Name())\nfmt.Println(\"Size in bytes:\", fileInfo.Size())\nfmt.Println(\"Permissions:\", fileInfo.Mode())\nfmt.Println(\"Last modified:\", fileInfo.ModTime())\nfmt.Println(\"Is Directory: \", fileInfo.IsDir())\nfmt.Printf(\"System interface type: %T\\n\", fileInfo.Sys())\nfmt.Printf(\"System info: %+v\\n\\n\", fileInfo.Sys())\n"
    ],
    "description": "",
    "prefix": "file stat (os)"
  },
  "file temporary file": {
    "body": [
      "// Create a temp dir in the system default temp folder\ntempDirPath, err := ioutil.TempDir(\"\", \"myTempDir\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"Temp dir created:\", tempDirPath)\n\n// Create a file in new temp directory\ntempFile, err := ioutil.TempFile(tempDirPath, \"myTempFile.txt\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"Temp file created:\", tempFile.Name())\n\n// ... do something with temp file/dir ...\n\n// Close file\nerr = tempFile.Close()\nif err != nil {\n    log.Fatal(err)\n}\n\n// Delete the resources we created\nerr = os.Remove(tempFile.Name())\nif err != nil {\n    log.Fatal(err)\n}\nerr = os.Remove(tempDirPath)\nif err != nil {\n    log.Fatal(err)\n}\n"
    ],
    "description": "",
    "prefix": "file temporary file"
  },
  "file write with validation": {
    "body": [
      "// FileWriteWithValidation writes content to filePath and validates that the writing was successful\nfunc FileWriteWithValidation(f *os.File, content string) error {\n\tvalue := []byte(content)\n\tcount, err := f.Write(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif count != len(value) {\n\t\treturn errors.New(\"incorrect length returned from write\")\n\t}\n\treturn nil\n}\n"
    ],
    "description": "",
    "prefix": "file write with validation"
  },
  "form bcrypt compare passwords": {
    "body": [
      "// Verify the old password\nif err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(oldPassword)); err != nil {\n    return errors.New(\"old password is incorrect\")\n}\n"
    ],
    "description": "",
    "prefix": "form bcrypt compare passwords"
  },
  "form decode and validate": {
    "body": [
      "if err := r.ParseForm(); err != nil {\n    cookies.FlashSetWithRedirect(w, r, \"There was an error processing your request. Please try again.\", \"/register\")\n    return\n}\n\n// Define an inline struct for signup, with validation tags.\nvar signupReq = struct {\n    Email           string `schema:\"email\" validate:\"required,email\"`\n    Password        string `schema:\"password\" validate:\"required,min=8\"`\n    ConfirmPassword string `schema:\"confirm_password\" validate:\"eqfield=Password\"`\n}{}\n\n// Decode the form values.\nif err := decoder.Decode(\u0026signupReq, r.PostForm); err != nil {\n    cookies.FlashSetWithRedirect(w, r, \"Unexpected error. Please try again later.\", \"/register\")\n    return\n}\n\n// Validate the fields.\nif err := validate.Struct(signupReq); err != nil {\n    friendlyErrors := []string{}\n    // Loop through each validation error and translate it.\n    for _, err := range err.(validator.ValidationErrors) {\n        switch err.Field() {\n        case \"Email\":\n            friendlyErrors = append(friendlyErrors, \"A valid email address is required.\")\n        case \"Password\":\n            friendlyErrors = append(friendlyErrors, \"Your password must be at least 8 characters long.\")\n        case \"ConfirmPassword\":\n            friendlyErrors = append(friendlyErrors, \"The confirmation password must match your password.\")\n        default:\n            friendlyErrors = append(friendlyErrors, \"Invalid input for \"+err.Field()+\".\")\n        }\n    }\n    cookies.FlashSetWithRedirect(w, r, strings.Join(friendlyErrors, \" \"), \"/register\")\n    return\n}\n"
    ],
    "description": "",
    "prefix": "form decode and validate"
  },
  "form init  decoder and validate": {
    "body": [
      "//\"github.com/go-playground/validator/v10\"\n//\"github.com/gorilla/schema\"\n\n// form processing\nvar decoder = schema.NewDecoder()\nvar validate = validator.New()\n\nfunc init() {\n\t// This tells the decoder to silently ignore form valuesthat don't correspond to a struct field.\n\tdecoder.IgnoreUnknownKeys(true)\n}\n"
    ],
    "description": "",
    "prefix": "form init  decoder and validate"
  },
  "gin add func template": {
    "body": [
      "router.SetFuncMap(template.FuncMap{\n    \"formatAsDate\": formatAsDate,\n})\n\nfunc formatAsDate(t time.Time) string {\n\tyear, month, day := t.Date()\n\treturn fmt.Sprintf(\"%d%02d/%02d\", year, month, day)\n}\n"
    ],
    "description": "",
    "prefix": "gin add func template"
  },
  "gin basic auth on group": {
    "body": [
      "authorized := g.Group(\"/auth\")\nauthorized.Use(gin.BasicAuth(gin.Accounts{\n    \"foo\":  \"bar\",\n    \"manu\": \"123\",\n}))\n\nauthorized.GET(\"admin\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"admin\")\n})\n\n/* example curl for /admin with basicauth header\n\t   Zm9vOmJhcg== is base64(\"foo:bar\")\n\n\t\tcurl -X POST \\\n\t  \thttp://localhost:8080/auth/admin \\\n\t  \t-H 'authorization: Basic Zm9vOmJhcg==' \\\n\t  \t-H 'content-type: application/json' \\\n\t  \t-d '{\"value\":\"bar\"}'\n\t*/\n\tauthorized.POST(\"admin\", func(c *gin.Context) {\n\t\tuser := c.MustGet(gin.AuthUserKey).(string)\n\t\tc.String(http.StatusOK, \"user: \"+user)\n\t})\n"
    ],
    "description": "",
    "prefix": "gin basic auth on group"
  },
  "gin bind file (upload)": {
    "body": [
      "type BindFile struct {\n\tName  string                `form:\"name\" binding:\"required\"`\n\tEmail string                `form:\"email\" binding:\"required\"`\n\tFile  *multipart.FileHeader `form:\"file\" binding:\"required\"`\n}\n\n/*\n\u003ch1\u003eBind file with fields\u003c/h1\u003e\n\u003cform action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"\u003e\n    Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e\n    Email: \u003cinput type=\"email\" name=\"email\"\u003e\u003cbr\u003e\n    File: \u003cinput type=\"file\" name=\"file\"\u003e\u003cbr\u003e\u003cbr\u003e\n    \u003cinput type=\"submit\" value=\"Submit\"\u003e\n\u003c/form\u003e\n*/\n\nrouter.POST(\"/upload\", func(c *gin.Context) {\n    var bindFile BindFile\n\n    // Bind file\n    if err := c.ShouldBind(\u0026bindFile); err != nil {\n        c.String(http.StatusBadRequest, fmt.Sprintf(\"err: %s\", err.Error()))\n        return\n    }\n\n    // Save uploaded file\n    file := bindFile.File\n    dst := filepath.Base(file.Filename)\n    if err := c.SaveUploadedFile(file, dst); err != nil {\n        c.String(http.StatusBadRequest, fmt.Sprintf(\"upload file err: %s\", err.Error()))\n        return\n    }\n\n    c.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, bindFile.Name, bindFile.Email))\n})\n"
    ],
    "description": "",
    "prefix": "gin bind file (upload)"
  },
  "gin favicon": {
    "body": [
      "g.GET(\"favicon.ico\", func(c *gin.Context) {\n    file, _ := f.ReadFile(\"assets/favicon.ico\")\n    c.Data(http.StatusOK, \"image/x-icon\", file)\n})\n"
    ],
    "description": "",
    "prefix": "gin favicon"
  },
  "gin form set memory": {
    "body": [
      "// Set a lower memory limit for multipart forms (default is 32 MiB)\ng.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB\n"
    ],
    "description": "",
    "prefix": "gin form set memory"
  },
  "gin get embedded folders": {
    "body": [
      "//go:embed assets/* templates/*\nvar f embed.FS\n\n// example: /public/assets/images/example.png\nassets, _ := fs.Sub(f, \"assets\")\ng.StaticFS(\"/public\", http.FS(assets))\n\ng.GET(\"favicon.ico\", func(c *gin.Context) {\n    file, _ := f.ReadFile(\"assets/favicon.ico\")\n    c.Data(http.StatusOK, \"image/x-icon\", file)\n})\n"
    ],
    "description": "",
    "prefix": "gin get embedded folders"
  },
  "gin handler POST save form": {
    "body": [
      "g.POST(\"/upload\", func(c *gin.Context) {\n    // single file\n    file, _ := c.FormFile(\"file\")\n    log.Println(file.Filename)\n\n    // Upload the file to specific dst.\n    log.Println(c.SaveUploadedFile(file, \"./files/\"+file.Filename))\n\n    c.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename))\n})\n"
    ],
    "description": "",
    "prefix": "gin handler POST save form"
  },
  "gin handler html": {
    "body": [
      "g.GET(\"/\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n        \"title\": \"Main website\",\n    })\n})\n"
    ],
    "description": "",
    "prefix": "gin handler html"
  },
  "gin handler with middleware example": {
    "body": [
      "route.GET(\"/home\", CookieTool(), func(c *gin.Context) {\n    c.JSON(200, gin.H{\"data\": \"Your home page\"})\n})\n"
    ],
    "description": "",
    "prefix": "gin handler with middleware example"
  },
  "gin https": {
    "body": [
      "log.Fatal(autotls.RunWithContext(ctx, g, domain...))\n\n"
    ],
    "description": "",
    "prefix": "gin https"
  },
  "gin init": {
    "body": [
      "g := gin.New()        // Creates a new Gin router without the default logger\ng.Use(gin.Recovery()) // Adds only the recovery middleware\ngin.SetMode(gin.ReleaseMode)\n"
    ],
    "description": "",
    "prefix": "gin init"
  },
  "gin middleware (cookie validate example)": {
    "body": [
      "func CookieTool() gin.HandlerFunc {\n  return func(c *gin.Context) {\n    // Get cookie\n    if cookie, err := c.Cookie(\"label\"); err == nil {\n      if cookie == \"ok\" {\n        c.Next()\n        return\n      }\n    }\n\n    // Cookie verification failed\n    c.JSON(http.StatusForbidden, gin.H{\"error\": \"Forbidden with no cookie\"})\n    c.Abort()\n  }\n}\n\nroute.GET(\"/home\", CookieTool(), func(c *gin.Context) {\nc.JSON(200, gin.H{\"data\": \"Your home page\"})\n})\n"
    ],
    "description": "",
    "prefix": "gin middleware (cookie validate example)"
  },
  "gin middleware security": {
    "body": [
      "// Setup Security Headers\nrouter.Use(func(c *gin.Context) {\n    if c.Request.Host != expectedHost {\n        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid host header\"})\n        return\n    }\n    c.Header(\"X-Frame-Options\", \"DENY\")\n    c.Header(\"Content-Security-Policy\", \"default-src 'self'; connect-src *; font-src *; script-src-elem * 'unsafe-inline'; img-src * data:; style-src * 'unsafe-inline';\")\n    c.Header(\"X-XSS-Protection\", \"1; mode=block\")\n    c.Header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains; preload\")\n    c.Header(\"Referrer-Policy\", \"strict-origin\")\n    c.Header(\"X-Content-Type-Options\", \"nosniff\")\n    c.Header(\"Permissions-Policy\", \"geolocation=(),midi=(),sync-xhr=(),microphone=(),camera=(),magnetometer=(),gyroscope=(),fullscreen=(self),payment=()\")\n    c.Next()\n})\n"
    ],
    "description": "",
    "prefix": "gin middleware security"
  },
  "gin multiple servers": {
    "body": [
      "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nvar errg errgroup.Group\n\nfunc router01() http.Handler {\n\te := gin.New()\n\te.Use(gin.Recovery())\n\te.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(\n\t\t\thttp.StatusOK,\n\t\t\tgin.H{\n\t\t\t\t\"code\":  http.StatusOK,\n\t\t\t\t\"error\": \"Welcome server 01\",\n\t\t\t},\n\t\t)\n\t})\n\n\treturn e\n}\n\nfunc router02() http.Handler {\n\te := gin.New()\n\te.Use(gin.Recovery())\n\te.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(\n\t\t\thttp.StatusOK,\n\t\t\tgin.H{\n\t\t\t\t\"code\":  http.StatusOK,\n\t\t\t\t\"error\": \"Welcome server 02\",\n\t\t\t},\n\t\t)\n\t})\n\n\treturn e\n}\n\nfunc main() {\n\tserver01 := \u0026http.Server{\n\t\tAddr:         \":8080\",\n\t\tHandler:      router01(),\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t}\n\n\tserver02 := \u0026http.Server{\n\t\tAddr:         \":8081\",\n\t\tHandler:      router02(),\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t}\n\n\terrg.Go(func() error {\n\t\treturn server01.ListenAndServe()\n\t})\n\n\terrg.Go(func() error {\n\t\treturn server02.ListenAndServe()\n\t})\n\n\tif err := errg.Wait(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "gin multiple servers"
  },
  "gin push": {
    "body": [
      "if pusher := c.Writer.Pusher(); pusher != nil {\n    // use pusher.Push() to do server push\n    if err := pusher.Push(\"/assets/app.js\", nil); err != nil {\n        log.Printf(\"Failed to push: %v\", err)\n    }\n}\n"
    ],
    "description": "",
    "prefix": "gin push"
  },
  "gin upload multiple filess": {
    "body": [
      "router.POST(\"/upload\", func(c *gin.Context) {\n    name := c.PostForm(\"name\")\n    email := c.PostForm(\"email\")\n\n    // Multipart form\n    form, err := c.MultipartForm()\n    if err != nil {\n        c.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n        return\n    }\n    files := form.File[\"files\"]\n\n    for _, file := range files {\n        filename := filepath.Base(file.Filename)\n        if err := c.SaveUploadedFile(file, filename); err != nil {\n            c.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n            return\n        }\n    }\n\n    c.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n})\n\n/*\n\u003ch1\u003eUpload multiple files with fields\u003c/h1\u003e\n\n\u003cform action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"\u003e\n    Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e\n    Email: \u003cinput type=\"email\" name=\"email\"\u003e\u003cbr\u003e\n    Files: \u003cinput type=\"file\" name=\"files\" multiple\u003e\u003cbr\u003e\u003cbr\u003e\n    \u003cinput type=\"submit\" value=\"Submit\"\u003e\n\u003c/form\u003e\n*/\n"
    ],
    "description": "",
    "prefix": "gin upload multiple filess"
  },
  "gin validate custom and bind": {
    "body": [
      "// \"github.com/gin-gonic/gin/binding\"\n// \"github.com/go-playground/validator/v10\"\n\n// Booking contains binded and validated data.\ntype Booking struct {\n\tCheckIn  time.Time `form:\"check_in\" binding:\"required,bookabledate\" time_format:\"2006-01-02\"`\n\tCheckOut time.Time `form:\"check_out\" binding:\"required,gtfield=CheckIn\" time_format:\"2006-01-02\"`\n}\n\nvar bookableDate validator.Func = func(fl validator.FieldLevel) bool {\n\tdate, ok := fl.Field().Interface().(time.Time)\n\tif ok {\n\t\ttoday := time.Now()\n\t\tif today.After(date) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nif v, ok := binding.Validator.Engine().(*validator.Validate); ok {\n    v.RegisterValidation(\"bookabledate\", bookableDate)\n}\n\nfunc getBookable(c *gin.Context) {\n\tvar b Booking\n\tif err := c.ShouldBindWith(\u0026b, binding.Query); err == nil {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Booking dates are valid!\"})\n\t} else {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "gin validate custom and bind"
  },
  "go build ignore": {
    "body": [
      "//go:build ignore\n"
    ],
    "description": "",
    "prefix": "go build ignore"
  },
  "gor get struct by email": {
    "body": [
      "var user User\nif err := auth.Where(\"email = ?\", email).First(\u0026user).Error; err != nil {\n    return err\n}\n"
    ],
    "description": "",
    "prefix": "gor get struct by email"
  },
  "gorm create": {
    "body": [
      "type Page struct {\n\tID         uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName       string `gorm:\"index\"`\n\tURL        string\n\tHTML       []byte\n\tCategoryID uint\n}\n\ntype Category struct {\n\tID    uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName  string `gorm:\"index\"`\n\tPages []Page\n}\n\nif err := d.DB.Create(\u0026category).Error; err != nil {\n    log.Println(\"Error saving category:\", err)\n}\n"
    ],
    "description": "",
    "prefix": "gorm create"
  },
  "gorm create struct": {
    "body": [
      "if err := auth.Create(\u0026user).Error; err != nil {\n    return User{}, err\n}\n"
    ],
    "description": "",
    "prefix": "gorm create struct"
  },
  "gorm delete": {
    "body": [
      "if err = auth.Delete(\u0026User{}, userID).Error; err != nil {\n    return\n}\n"
    ],
    "description": "",
    "prefix": "gorm delete"
  },
  "gorm get all join": {
    "body": [
      "type Page struct {\n\tID         uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName       string `gorm:\"index\"`\n\tURL        string\n\tHTML       []byte\n\tCategoryID uint\n}\n\ntype Category struct {\n\tID    uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName  string `gorm:\"index\"`\n\tPages []Page\n}\n\nvar categories []Category\n// Retrieve the categories and their pages from the database\nerr := d.DB.Preload(\"Pages\").Find(\u0026categories).Error\nif err != nil {\n    return nil, err\n}\n"
    ],
    "description": "",
    "prefix": "gorm get all join"
  },
  "gorm get all structs": {
    "body": [
      "if err = auth.Find(\u0026users).Error; err != nil {\n    return nil, err\n}\n"
    ],
    "description": "",
    "prefix": "gorm get all structs"
  },
  "gorm get struct by id": {
    "body": [
      "var user User\nif err := auth.First(\u0026user, id).Error; err != nil {\n    return \"\", err\n}\n"
    ],
    "description": "",
    "prefix": "gorm get struct by id"
  },
  "gorm init": {
    "body": [
      "// \"gorm.io/driver/sqlite\"\n// \"gorm.io/gorm\"\n\ntype Page struct {\n\tID         uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName       string `gorm:\"index\"`\n\tURL        string\n\tHTML       []byte\n\tCategoryID uint\n}\n\ntype Category struct {\n\tID    uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName  string `gorm:\"index\"`\n\tPages []Page\n}\n\ntype Database struct {\n\tDB *gorm.DB\n}\n\nfunc (d *Database) Connect() {\n\tvar err error\n\td.DB, err = gorm.Open(sqlite.Open(\"file:codestitch.db?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\"), \u0026gorm.Config{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to SQLite database: %v\", err)\n\t}\n\n\t// Drop existing tables to start fresh\n\terr = d.DB.Migrator().DropTable(\u0026Category{}, \u0026Page{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to drop existing tables: %v\", err)\n\t}\n\n\t// Migrate the schema automatically, create tables, etc.\n\terr = d.DB.AutoMigrate(\u0026Category{}, \u0026Page{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to migrate database: %v\", err)\n\t}\n\n\tfmt.Println(\"Connected to SQLite database:\", \"codestitch.db\")\n}\n\nfunc (d *Database) Close() {\n\t// SQLite doesn't require explicit closing with GORM.\n\t// The connection will be closed automatically when the program ends.\n\t// Retrieve the underlying SQL DB connection.\n\tdb, err := d.DB.DB()\n\tif err != nil {\n\t\tlog.Println(\"Error getting database connection:\", err)\n\t\treturn\n\t}\n\n\t// Attempt to close the connection.\n\tif err = db.Close(); err != nil {\n\t\tlog.Println(\"Error closing database connection:\", err)\n\t} else {\n\t\tfmt.Println(\"Database connection closed.\")\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "gorm init"
  },
  "gorm literal: ID": {
    "body": [
      "uint `gorm:\"primaryKey;autoIncrement\"`\n"
    ],
    "description": "",
    "prefix": "gorm literal: ID"
  },
  "gorm literal: unique, not null": {
    "body": [
      "`gorm:\"unique;not null\"`\n"
    ],
    "description": "",
    "prefix": "gorm literal: unique, not null"
  },
  "gorm transaction": {
    "body": [
      "type Page struct {\n\tID         uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName       string `gorm:\"index\"`\n\tURL        string\n\tHTML       []byte\n\tCategoryID uint\n}\n\ntype Category struct {\n\tID    uint   `gorm:\"primaryKey;autoIncrement\"`\n\tName  string `gorm:\"index\"`\n\tPages []Page\n}\n\nfor _, category := range categories {\n    // Save category and its pages in a single transaction\n    d.DB.Transaction(func(tx *gorm.DB) error {\n        if err := tx.Create(\u0026category).Error; err != nil {\n            return err\n        }\n        return nil\n    })\n}\n"
    ],
    "description": "",
    "prefix": "gorm transaction"
  },
  "gorm update value/values": {
    "body": [
      "if err := auth.Model(\u0026User{}).\n    Where(\"id = ?\", id).\n    Update(\"verified\", true).Error; err != nil {\n    return err\n}\n"
    ],
    "description": "",
    "prefix": "gorm update value/values"
  },
  "handler example": {
    "body": [
      "func homeHandler(w http.ResponseWriter, r *http.Request) {\n\trenderHTMLAuthFlashCSRF(w, r, \"pages/index.html\", nil)\n}\n"
    ],
    "description": "",
    "prefix": "handler example"
  },
  "handler login": {
    "body": [
      "http.HandleFunc(\"/login\", loginHandler)\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tflashMsg, _ := getFlash(w, r, flashCookie)\n\tif r.Method == http.MethodGet {\n\t\ttmpl := `\n\t\t\u003c!DOCTYPE html\u003e\n\t\t\u003chtml\u003e\n\t\t\u003chead\u003e\n\t\t\t\u003ctitle\u003eLogin\u003c/title\u003e\n\t\t\u003c/head\u003e\n\t\t\u003cbody\u003e\n\t\t\t\u003ch1\u003eLogin\u003c/h1\u003e\n\t\t\t{{if .FlashMsg}}\n\t\t\t\t\u003cp style=\"color: green;\"\u003e{{.FlashMsg}}\u003c/p\u003e\n\t\t\t{{end}}\n\t\t\t\u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\n\t\t\t\u003ca href=\"/signup\"\u003eSignup\u003c/a\u003e\n\t\t\t\u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\n\t\t\t\u003cform action=\"/login\" method=\"post\"\u003e\n\t\t\t\t{{ .csrfField }}\n\t\t\t\t\u003cinput type=\"email\" name=\"email\" placeholder=\"Email\" required\u003e\n\t\t\t\t\u003cinput type=\"password\" name=\"password\" placeholder=\"Password\" required\u003e\n\t\t\t\t\u003cbutton type=\"submit\"\u003eLogin\u003c/button\u003e\n\t\t\t\u003c/form\u003e\n\t\t\t\u003ca href=\"/change-password\"\u003eForgot password?\u003c/a\u003e\n\t\t\u003c/body\u003e\n\t\t\u003c/html\u003e`\n\n\t\tdata := map[string]interface{}{\n\t\t\tcsrf.TemplateTag: csrf.TemplateField(r),\n\t\t\t\"FlashMsg\":       flashMsg,\n\t\t}\n\n\t\terr := RenderTemplateInline(w, tmpl, data)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try letter\", http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\tuser := User{\n\t\t\tEmail:    r.FormValue(\"email\"),\n\t\t\tPassword: r.FormValue(\"password\"),\n\t\t}\n\n\t\tvar hashedPassword string\n\t\terr := dbAuth.QueryRow(\"SELECT password FROM users WHERE email = ?\", user.Email).Scan(\u0026hashedPassword)\n\t\tif err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password)) != nil {\n\t\t\tsetFlash(w, flashCookie, \"Invalid credentials\")\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// Create a JWT\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"email\": user.Email,\n\t\t\t\"exp\":   time.Now().Add(24 * 30 * time.Hour).Unix(),\n\t\t})\n\n\t\t// Sign the JWT with a secret key\n\t\ttokenString, err := token.SignedString([]byte(secretKey))\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the JWT in an HTTP-only cookie\n\t\thttp.SetCookie(w, \u0026http.Cookie{\n\t\t\tName:     \"jwt\",\n\t\t\tValue:    tokenString,\n\t\t\tExpires:  time.Now().Add(24 * time.Hour),\n\t\t\tHttpOnly: true,\n\t\t\tSecure:   true, // Enable in production (HTTPS only)\n\t\t})\n\t\tsetFlash(w, flashCookie, \"Login successful!\")\n\t\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n\t}\n}\n\n"
    ],
    "description": "",
    "prefix": "handler login"
  },
  "handler logout": {
    "body": [
      "http.HandleFunc(\"/logout\", logoutHandler)\n\nfunc logoutHandler(w http.ResponseWriter, r *http.Request) {\n\t// Clear the JWT cookie by setting an expired cookie with the same name\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     \"jwt\",\n\t\tValue:    \"\",\n\t\tExpires:  time.Now().Add(-time.Hour), // Set the expiration time in the past\n\t\tHttpOnly: true,\n\t\tSecure:   true, // Enable in production (HTTPS only)\n\t})\n\n\tsetFlash(w, flashCookie, \"You have been logged out.\")\n\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n}\n"
    ],
    "description": "",
    "prefix": "handler logout"
  },
  "handler password reset": {
    "body": [
      "\"github.com/domodwyer/mailyak/v3\"\n\nconst domain = \"http://localhost:8080\"\n\nhttp.HandleFunc(\"/change-password\", changePasswordHandler)\nhttp.HandleFunc(\"/reset-password\", resetPasswordHandler)\n\nfunc changePasswordHandler(w http.ResponseWriter, r *http.Request) {\n\tflashMsg, _ := getFlash(w, r, flashCookie)\n\n\tif r.Method == http.MethodGet {\n\t\ttmpl := `\n        \u003c!DOCTYPE html\u003e\n        \u003chtml\u003e\n        \u003chead\u003e\n            \u003ctitle\u003eChange Password\u003c/title\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003ch1\u003eChange Password\u003c/h1\u003e\n\t\t\t{{if .FlashMsg}}\n                \u003cp style=\"color: green;\"\u003e{{.FlashMsg}}\u003c/p\u003e\n            {{end}}\n            \u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\n            \u003ca href=\"/signup\"\u003eSignup\u003c/a\u003e\n            \u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\n            \u003cform action=\"/change-password\" method=\"post\"\u003e\n                {{ .csrfField }}\n                \u003cinput type=\"email\" name=\"email\" placeholder=\"Email\" required\u003e\n                \u003cbutton type=\"submit\"\u003eChange Password\u003c/button\u003e\n            \u003c/form\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e`\n\n\t\tdata := map[string]interface{}{\n\t\t\tcsrf.TemplateTag: csrf.TemplateField(r),\n\t\t\t\"FlashMsg\":       flashMsg,\n\t\t}\n\n\t\terr := RenderTemplateInline(w, tmpl, data)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t}\n\t} else if r.Method == http.MethodPost {\n\t\temail := r.FormValue(\"email\")\n\t\tvar exists bool\n\t\terr := dbAuth.QueryRow(\"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", email).Scan(\u0026exists)\n\t\tif err != nil || !exists {\n\t\t\tsetFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tresetToken, err := encryptToken(email, []byte(secretKey))\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Send a password reset email\n\t\tresetLink := fmt.Sprintf(domain+\"/reset-password?token=%s\u0026email=%s\", resetToken, email)\n\t\t//go sendResetEmail(email, resetLink)\n\t\tgo sendResetPassword(email, resetLink)\n\n\t\thttp.SetCookie(w, \u0026http.Cookie{\n\t\t\tName:     \"reset_token\",\n\t\t\tValue:    resetToken,\n\t\t\tExpires:  time.Now().Add(1 * time.Hour),\n\t\t\tHttpOnly: true,\n\t\t\tSecure:   true,\n\t\t})\n\n\t\tsetFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t}\n}\n\nfunc resetPasswordHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\ttmpl := `\n        \u003c!DOCTYPE html\u003e\n        \u003chtml\u003e\n        \u003chead\u003e\n            \u003ctitle\u003eReset Password\u003c/title\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003ch1\u003eReset Password\u003c/h1\u003e\n            {{if .FlashMsg}}\n                \u003cp style=\"color: green;\"\u003e{{.FlashMsg}}\u003c/p\u003e\n            {{end}}\n            \u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\n            \u003ca href=\"/signup\"\u003eSignup\u003c/a\u003e\n            \u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\n            \u003cform action=\"/reset-password\" method=\"post\"\u003e\n\t\t\t\t{{ .csrfField }}\n                \u003cinput type=\"hidden\" name=\"token\" value=\"{{.Token}}\"\u003e\n                \u003cinput type=\"password\" name=\"password\" placeholder=\"New Password\" required\u003e\n                \u003cbutton type=\"submit\"\u003eReset Password\u003c/button\u003e\n            \u003c/form\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e`\n\t\tflash, _ := getFlash(w, r, flashCookie)\n\t\tdata := map[string]interface{}{\n\t\t\tcsrf.TemplateTag: csrf.TemplateField(r),\n\t\t\t\"FlashMsg\":       flash,\n\t\t\t\"Token\":          r.URL.Query().Get(\"token\"),\n\t\t}\n\n\t\tif data[\"Token\"] == nil {\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t}\n\n\t\terr := RenderTemplateInline(w, tmpl, data)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\ttoken := r.FormValue(\"token\")\n\t\tnewPassword := r.FormValue(\"password\")\n\n\t\temail, err := decryptToken(token, []byte(secretKey))\n\t\tif err != nil {\n\t\t\tsetFlash(w, flashCookie, \"Invalid or expired token\")\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t_, err = dbAuth.Exec(\"UPDATE users SET password = ? WHERE email = ?\", string(hashedPassword), email)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsetFlash(w, flashCookie, \"Password reset successful!\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t}\n}\n\nfunc sendResetPassword(email, link string) error {\n\t// Create a new email - specify the SMTP host:port and auth (if needed)\n\tmail := mailyak.New(\"smtp.mail.me.com:587\", smtp.PlainAuth(\"\", \"andreinita@icloud.com\", \"kqfp-sdar-bxzw-awfu\", \"smtp.mail.me.com\"))\n\n\tmail.To(email)\n\tmail.From(\"andreinita@icloud.com\")\n\tmail.FromName(\"Localhost\")\n\n\tmail.Subject(\"Password Reset\")\n\n\t// Or set the body using a string setter\n\tmail.Plain().Set(\"Click the link to reset your password: \" + link)\n\n\t// And you're done!\n\tif err := mail.Send(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc encryptToken(email string, secretKey []byte) (string, error) {\n\tplaintext := []byte(email + \"|\" + time.Now().Add(1*time.Hour).Format(time.RFC3339))\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)\n\treturn base64.URLEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc decryptToken(token string, secretKey []byte) (string, error) {\n\tciphertext, err := base64.URLEncoding.DecodeString(token)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\tif len(ciphertext) \u003c nonceSize {\n\t\treturn \"\", fmt.Errorf(\"ciphertext too short\")\n\t}\n\n\tnonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n\tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparts := strings.SplitN(string(plaintext), \"|\", 2)\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid token format\")\n\t}\n\n\texpiry, err := time.Parse(time.RFC3339, parts[1])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif time.Now().After(expiry) {\n\t\treturn \"\", fmt.Errorf(\"token has expired\")\n\t}\n\n\treturn parts[0], nil\n}\n"
    ],
    "description": "",
    "prefix": "handler password reset"
  },
  "handler signup": {
    "body": [
      "http.HandleFunc(\"/signup\", signupHandler)\n\nfunc signupHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\ttmpl := `\n\t\u003c!DOCTYPE html\u003e\n\t\u003chtml\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eSignup\u003c/title\u003e\n\t\u003c/head\u003e\n\t\u003cbody\u003e\n\t\t\u003ch1\u003eSignup\u003c/h1\u003e\n\t\t\u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\n\t\t\u003ca href=\"/signup\"\u003eSignup\u003c/a\u003e\n\t\t\u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\n\t\t\u003cform action=\"/signup\" method=\"post\"\u003e\n\t\t\t{{ .csrfField }}\n\t\t\t\u003cinput type=\"email\" name=\"email\" placeholder=\"Email\" required\u003e\n\t\t\t\u003cinput type=\"password\" name=\"password\" placeholder=\"Password\" required\u003e\n\t\t\t\u003cbutton type=\"submit\"\u003eSignup\u003c/button\u003e\n\t\t\u003c/form\u003e\n\t\u003c/body\u003e\n\t\u003c/html\u003e`\n\n\t\tdata := map[string]interface{}{\n\t\t\tcsrf.TemplateTag: csrf.TemplateField(r),\n\t\t}\n\n\t\terr := RenderTemplateInline(w, tmpl, data)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try letter\", http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\tuser := User{\n\t\t\tEmail:    r.FormValue(\"email\"),\n\t\t\tPassword: r.FormValue(\"password\"),\n\t\t}\n\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t_, err = dbAuth.Exec(\"INSERT INTO users (email, password) VALUES (?, ?)\", user.Email, string(hashedPassword))\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsetFlash(w, flashCookie, \"Account successfully created! Please login\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "handler signup"
  },
  "hash password bcrypt": {
    "body": [
      "\"golang.org/x/crypto/bcrypt\"\n\nhashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "hash password bcrypt"
  },
  "hash sha256": {
    "body": [
      "c1 := sha256.Sum256([]byte(\"x\"))\nc2 := sha256.Sum256([]byte(\"X\"))\nfmt.Printf(\"%x\\n%x\\n%t\\n%T\\n\", c1, c2, c1 == c2, c1)\n// Output:\n// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881\n// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015\n// false\n// [32]uint8\n"
    ],
    "description": "",
    "prefix": "hash sha256"
  },
  "http csrf": {
    "body": [
      "const secretKey = \"\u003c!32trentadue!\u003e\u003c!treizecisidoi!\u003e\" // 32 characters as required by csrf\n\n// Set up CSRF protection\nCSRF := csrf.Protect(\n    []byte(secretKey),  // Replace with a secure key\n    csrf.Secure(false), // TODO: Set to true in production (HTTPS only)\n)\n\n// Graceful shutdown handling\nserver := http.Server{Addr: \":8080\"}\nserver.Handler = CSRF(http.DefaultServeMux)\n\ngo func() {\n    fmt.Println(\"Starting server @ http://localhost:8080\")\n    if err := server.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n        log.Fatalf(\"Server failed: %v\", err)\n    }\n}()\n\nstop := make(chan os.Signal, 1)\nsignal.Notify(stop, os.Interrupt, syscall.SIGTERM)\n\n\u003c-stop\nlog.Println(\"Shutting down server...\")\nif err := server.Close(); err != nil {\n    log.Fatalf(\"Server shutdown error: %v\", err)\n}\nlog.Println(\"Server gracefully stopped.\")\n"
    ],
    "description": "",
    "prefix": "http csrf"
  },
  "http get url": {
    "body": [
      "resp, err := http.Get(\"https://andrei.website\")\nif err != nil {\n    // TODO\n}\nb, err := ioutil.ReadAll(resp.Body)\ndefer resp.Body.Close()\nif err != nil {\n    // TODO\n}\nfmt.Printf(\"%s\", b)\n"
    ],
    "description": "",
    "prefix": "http get url"
  },
  "http get url data with cookie and token from browser": {
    "body": [
      "var codestichUsername string\nvar codestichPassword string\nvar codestichSession string\nvar xsrfToken string\nvar scrapData = false\n\nfunc init() {\n\tcodestichUsername = os.Getenv(\"codestichUsername\")\n\tif codestichUsername == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichUsername is not set\")\n\t}\n\n\tcodestichPassword = os.Getenv(\"codestichPassword\")\n\tif codestichPassword == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichPassword is not set\")\n\t}\n\n\t// Retrieve session and XSRF tokens from environment variables\n\tcodestichSession = os.Getenv(\"codestich_session\")\n\tif codestichSession == \"\" {\n\t\tlog.Fatal(\"Environment variable codestich_session is not set\")\n\t}\n\n\txsrfToken = os.Getenv(\"XSRF_TOKEN\")\n\tif xsrfToken == \"\" {\n\t\tlog.Fatal(\"Environment variable XSRF_TOKEN is not set\")\n\t}\n}\n\nreq, err := http.NewRequest(\"GET\", pageLink, nil)\nif err != nil {\n    log.Fatalln(err)\n}\n// Manually set the Cookie header using the values retrieved from your browser.\n// Depending on the site's requirements, you might need to include additional cookies.\ncookieHeader := fmt.Sprintf(\"codestitch_session=%s; XSRF-TOKEN=%s\", codestichSession, xsrfToken)\nreq.Header.Set(\"Cookie\", cookieHeader)\n\n// Set a typical browser User-Agent header.\nreq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124\")\n\n// Optionally, add Referer and Origin headers if needed.\nreq.Header.Set(\"Referer\", \"https://codestitch.app/login\")\nreq.Header.Set(\"Origin\", \"https://codestitch.app\")\n\nclient := \u0026http.Client{}\nresp, err := client.Do(req)\nif err != nil {\n    log.Fatalln(err)\n}\ndefer resp.Body.Close()\n"
    ],
    "description": "",
    "prefix": "http get url data with cookie and token from browser"
  },
  "http get url with password": {
    "body": [
      "username := \"your_username\"\npassword := \"your_password\"\nauth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\nreq, err := http.NewRequest(\"GET\", pageLink, nil)\nif err != nil {\n    log.Fatalln(err)\n}\nreq.Header.Add(\"Authorization\", auth)\n\nclient := \u0026http.Client{}\nresp, err := client.Do(req)\nif err != nil {\n    log.Fatalln(err)\n}\ndefer resp.Body.Close()\n"
    ],
    "description": "",
    "prefix": "http get url with password"
  },
  "http handle with handler (ServeHTTP)": {
    "body": [
      "type HelloHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello!\")\n}\n\nhello := HelloHandler{}\nhttp.Handle(\"/hello\", \u0026hello)\n"
    ],
    "description": "",
    "prefix": "http handle with handler (ServeHTTP)"
  },
  "http handle with handlerfunc": {
    "body": [
      "type dollars float32\n\nfunc (d dollars) String() string { return fmt.Sprintf(\"$%.2f\", d) }\n\ntype database map[string]dollars\n\nfunc (db database) list(w http.ResponseWriter, req *http.Request) {\n\tfor item, price := range db {\n\t\tfmt.Fprintf(w, \"%s: %s\\n\", item, price)\n\t}\n}\n\nfunc (db database) price(w http.ResponseWriter, req *http.Request) {\n\titem := req.URL.Query().Get(\"item\")\n\tprice, ok := db[item]\n\tif !ok {\n\t\tw.WriteHeader(http.StatusNotFound) // 404\n\t\tfmt.Fprintf(w, \"no such item: %q\\n\", item)\n\t\treturn\n\t}\n\tfmt.Fprintf(w, \"%s\\n\", price)\n}\n\ndb := database{\"shoes\": 50, \"socks\": 5}\nhttp.Handle(\"/list\", http.HandlerFunc(db.list))\nhttp.Handle(\"/price\", http.HandlerFunc(db.price))\nlog.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n"
    ],
    "description": "",
    "prefix": "http handle with handlerfunc"
  },
  "http hanler (ServeHTTP)": {
    "body": [
      "type dollars float32\n\nfunc (d dollars) String() string { return fmt.Sprintf(\"$%.2f\", d) }\n\ntype database map[string]dollars\n\n//!+handler\nfunc (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tswitch req.URL.Path {\n\tcase \"/list\":\n\t\tfor item, price := range db {\n\t\t\tfmt.Fprintf(w, \"%s: %s\\n\", item, price)\n\t\t}\n\tcase \"/price\":\n\t\titem := req.URL.Query().Get(\"item\")\n\t\tprice, ok := db[item]\n\t\tif !ok {\n\t\t\tw.WriteHeader(http.StatusNotFound) // 404\n\t\t\tfmt.Fprintf(w, \"no such item: %q\\n\", item)\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprintf(w, \"%s\\n\", price)\n\tdefault:\n\t\tw.WriteHeader(http.StatusNotFound) // 404\n\t\tfmt.Fprintf(w, \"no such page: %s\\n\", req.URL)\n\t}\n}\n\ndb := database{\"shoes\": 50, \"socks\": 5}\nlog.Fatal(http.ListenAndServe(\"localhost:8000\", db))\n"
    ],
    "description": "",
    "prefix": "http hanler (ServeHTTP)"
  },
  "http https production": {
    "body": [
      "// production SSL: \"golang.org/x/crypto/acme/autocert\"\nhttp.HandleFunc(\"/\", home)\n\n// production SSL\ncertManager := autocert.Manager{\n    Prompt:     autocert.AcceptTOS,\n    HostPolicy: autocert.HostWhitelist(fmt.Sprint(\"andrei.website\")), // Your domain here\n    Cache:      autocert.DirCache(\"certs\"),                             // Folder for storing certificates\n}\n\n// starting up the server\nhttpsServer := \u0026http.Server{\n    Addr:           server.Config.PortSSL,\n    TLSConfig:      \u0026tls.Config{GetCertificate: certManager.GetCertificate},\n    //Handler:        new(middlewares.GzipMiddleware),\n    ReadTimeout:    time.Duration(60 * int64(time.Second)),\n    WriteTimeout:   time.Duration(60 * int64(time.Second)),\n    MaxHeaderBytes: 1 \u003c\u003c 20,\n}\n\ngo httpsServer.ListenAndServeTLS(\"\", \"\")\nlog.Fatalln(http.ListenAndServe(\":http\", certManager.HTTPHandler(nil)))\n"
    ],
    "description": "",
    "prefix": "http https production"
  },
  "http https production and localhost (needs improvment)": {
    "body": [
      "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/andrei/_skeleton/middlewares\"\n\t\"github.com/andrei/_skeleton/routes\"\n\t\"github.com/andrei/_skeleton/server\"\n\t\"github.com/andrei/_skeleton/server/dev\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc init() {\n\tif server.Config.Dev.IsActive {\n\t\tif _, err := os.Stat(\"server/dev/cert.pem\"); os.IsNotExist(err) {\n\t\t\t// file does not exist\n\t\t\tdev.GenerateSSL4Dev()\n\t\t\tfmt.Println(\" SSL for localhost created\")\n\t\t\tfmt.Println(\" Add server/dev/cert.pem to keychain certificates and always trust\")\n\t\t}\n\t}\n\tfmt.Printf(\"Navigate to: http://%s\\n\", server.Config.Host)\n}\n\nfunc main() {\n\n\t// routes\n\thttp.HandleFunc(\"/\", routes.Home)\n\t//http.HandleFunc(\"/favicon.ico\", routes.FaviconHandler)\n\thttp.HandleFunc(\"/robots.txt\", routes.RobotsText)\n\n\t// static files\n\thttp.Handle(\"/public/\", middlewares.Cache(http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"static/public\")))))\n\n\t// localhost SSL\n\tif server.Config.Dev.IsActive {\n\t\thttpServer := \u0026http.Server{\n\t\t\tAddr:           server.Config.Port,\n\t\t\tHandler:        http.HandlerFunc(redirectToHTTPS),\n\t\t\tReadTimeout:    time.Duration(60 * int64(time.Second)),\n\t\t\tWriteTimeout:   time.Duration(60 * int64(time.Second)),\n\t\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t\t}\n\n\t\t// starting up the server\n\t\thttpsServer := \u0026http.Server{\n\t\t\tAddr:           server.Config.PortSSL,\n\t\t\tHandler:        new(middlewares.GzipMiddleware),\n\t\t\tReadTimeout:    time.Duration(60 * int64(time.Second)),\n\t\t\tWriteTimeout:   time.Duration(60 * int64(time.Second)),\n\t\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t\t}\n\n\t\tgo httpsServer.ListenAndServeTLS(\"server/dev/cert.pem\", \"server/dev/key.pem\")\n\t\tlog.Fatalln(httpServer.ListenAndServe())\n\t}\n\n\t// production SSL\n\tcertManager := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(fmt.Sprint(server.Config.Host)), // Your domain here\n\t\tCache:      autocert.DirCache(\"certs\"),                             // Folder for storing certificates\n\t}\n\n\t// starting up the server\n\thttpsServer := \u0026http.Server{\n\t\tAddr:           server.Config.PortSSL,\n\t\tTLSConfig:      \u0026tls.Config{GetCertificate: certManager.GetCertificate},\n\t\tHandler:        new(middlewares.GzipMiddleware),\n\t\tReadTimeout:    time.Duration(60 * int64(time.Second)),\n\t\tWriteTimeout:   time.Duration(60 * int64(time.Second)),\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\n\tgo httpsServer.ListenAndServeTLS(\"\", \"\")\n\tlog.Fatalln(http.ListenAndServe(\":http\", certManager.HTTPHandler(nil)))\n}\n\n// redirectToHTTPS redirects HTTP connections to HTTPS on localhost\nfunc redirectToHTTPS(w http.ResponseWriter, r *http.Request) {\n\thttp.Redirect(w, r, \"https://\"+server.Config.Host+server.Config.PortSSL+r.RequestURI, http.StatusMovedPermanently)\n}\n"
    ],
    "description": "",
    "prefix": "http https production and localhost (needs improvment)"
  },
  "http redirect to ssl": {
    "body": [
      "url := \"https://\" + r.Host + r.URL.String()\nhttp.Redirect(w, r, url, http.StatusMovedPermanently)\n"
    ],
    "description": "",
    "prefix": "http redirect to ssl"
  },
  "http serve static from folder": {
    "body": [
      "http.Handle(\"/static\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"static\"))))\n"
    ],
    "description": "",
    "prefix": "http serve static from folder"
  },
  "http serve static with embedd": {
    "body": [
      "//go:embed public/*\nvar publicFiles embed.FS\n\npublicFiles, err := fs.Sub(publicFiles, \"public\")\nif err != nil {\n    log.Fatal(err)\n}\n\nhttp.Handle(\"/public/\", http.StripPrefix(\"/public/\", http.FileServer(http.FS(publicFiles))))\n"
    ],
    "description": "",
    "prefix": "http serve static with embedd"
  },
  "http with graceful shutdown": {
    "body": [
      "/* index functionality */\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    // TODO\n})\n\n// Graceful shutdown handling\nserver := \u0026http.Server{Addr: \":8000\"}\n\ngo func() {\n    log.Println(\"Starting server on :8000\")\n    if err := server.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n        log.Fatalf(\"Server failed: %v\", err)\n    }\n}()\n\nstop := make(chan os.Signal, 1)\nsignal.Notify(stop, os.Interrupt, syscall.SIGTERM)\n\n\u003c-stop\nlog.Println(\"Shutting down server...\")\nif err := server.Close(); err != nil {\n    log.Fatalf(\"Server shutdown error: %v\", err)\n}\nlog.Println(\"Server gracefully stopped.\")\n"
    ],
    "description": "",
    "prefix": "http with graceful shutdown"
  },
  "htttp and https localhost": {
    "body": [
      "// localhost SSL\nlocalhost := true\n\nhttp.HandleFunc(\"/\", home)\n\nif localhost {\n    httpServer := \u0026http.Server{\n        Addr: \":80\",\n        Handler:        http.HandlerFunc(redirectToHTTPS),\n        ReadTimeout:    time.Duration(60 * int64(time.Second)),\n        WriteTimeout:   time.Duration(60 * int64(time.Second)),\n        MaxHeaderBytes: 1 \u003c\u003c 20,\n    }\n\n    httpsServer := \u0026http.Server{\n        Addr: \":443\",\n        //Handler:        new(middlewares.GzipMiddleware),\n        ReadTimeout:    time.Duration(60 * int64(time.Second)),\n        WriteTimeout:   time.Duration(60 * int64(time.Second)),\n        MaxHeaderBytes: 1 \u003c\u003c 20,\n    }\n\n    go log.Fatalln(httpsServer.ListenAndServeTLS(\"cert.pem\", \"key.pem\"))\n    log.Fatalln(httpServer.ListenAndServe())\n}\n"
    ],
    "description": "",
    "prefix": "htttp and https localhost"
  },
  "ile permissions": {
    "body": [
      "Use these attributes individually or combined with an OR (|) for second arg of OpenFile().\n\n    e.g. os.O_CREATE|os.O_APPEND, os.O_CREATE|os.O_TRUNC|os.O_WRONLY\n\n    os.O_RDONLY \t// Read only\n    os.O_WRONLY \t// Write only\n    os.O_RDWR \t\t// Read and write\n    os.O_APPEND \t// Append to end of file\n    os.O_CREATE \t// Create is none exist\n    os.O_TRUNC \t    // Truncate file when opening\n\n### ile permissions\n\n    0\tNo permission\t                                            ---\n    1\tExecute permission\t                                        --x\n    2\tWrite permission\t                                        -w-\n    3\tExecute and write permission: 1 (execute) + 2 (write) = 3   -wx\n    4\tRead permission\t                                            r--\n    5\tRead and execute permission: 4 (read) + 1 (execute) = 5\t    r-x\n    6\tRead and write permission: 4 (read) + 2 (write) = 6\t        rw-\n    7\tAll permissions: 4 (read) + 2 (write) + 1 (execute) = 7\t    rwx\n"
    ],
    "description": "",
    "prefix": "ile permissions"
  },
  "import": {
    "body": [
      "bc \"github.com/binance/binance-connector-go\"\n"
    ],
    "description": "",
    "prefix": "import"
  },
  "import bcrypt": {
    "body": [
      "\"golang.org/x/crypto/bcrypt\"\n"
    ],
    "description": "",
    "prefix": "import bcrypt"
  },
  "import cache in memory": {
    "body": [
      "\"github.com/patrickmn/go-cache\"\n"
    ],
    "description": "",
    "prefix": "import cache in memory"
  },
  "import errgroup": {
    "body": [
      "\"golang.org/x/sync/errgroup\"\n"
    ],
    "description": "",
    "prefix": "import errgroup"
  },
  "import fsnotify": {
    "body": [
      "\"github.com/fsnotify/fsnotify\"\n"
    ],
    "description": "",
    "prefix": "import fsnotify"
  },
  "import gin": {
    "body": [
      "\"github.com/gin-gonic/gin\"\n"
    ],
    "description": "",
    "prefix": "import gin"
  },
  "import gin autotls https": {
    "body": [
      "\"github.com/gin-gonic/autotls\"\n"
    ],
    "description": "",
    "prefix": "import gin autotls https"
  },
  "import gorilla websocket": {
    "body": [
      "\"github.com/gorilla/websocket\"\n"
    ],
    "description": "",
    "prefix": "import gorilla websocket"
  },
  "import storm": {
    "body": [
      "\"github.com/asdine/storm/v3\"\n"
    ],
    "description": "",
    "prefix": "import storm"
  },
  "init get variables from os variables": {
    "body": [
      "func init() {\n\t// Attempt to load the secret key from the environment variable.\n\tsecretKey = os.Getenv(\"secretKey\")\n\tif secretKey == \"\" {\n\t\tlog.Fatal(\"Environment variable secretKey is not set\")\n\t}\n\n\t// Attempt to load the email password from the environment variable.\n\temailPassword = os.Getenv(\"emailPassword\")\n\tif emailPassword == \"\" {\n\t\tlog.Fatal(\"Environment variable emailPassword is not set\")\n\t}\n\n\tfmt.Println(\"Successfully loaded secretKey and emailPassword from environment variables\")\n}\n"
    ],
    "description": "",
    "prefix": "init get variables from os variables"
  },
  "io pipe (multiple writer)": {
    "body": [
      "// the pipe reader and pipe writer implement\n// io.Reader and io.Writer\nr, w := io.Pipe()\n\n// this needs to be run in a separate go routine\n// as it will block waiting for the reader\n// close at the end for cleanup\ngo func() {\n  // for now we'll write something basic,\n  // this could also be used to encode json\n  // base64 encode, etc.\n  w.Write([]byte(\"test\\n\"))\n  w.Close()\n}()\n\nif _, err := io.Copy(os.Stdout, r); err != nil {\n  log.Fatalln(err)\n}\n"
    ],
    "description": "",
    "prefix": "io pipe (multiple writer)"
  },
  "json decode": {
    "body": [
      "var m map[string]string\ndecoder := json.NewDecoder(file)\nerr = decoder.Decode(\u0026m)\nif err != nil {\n    log.Fatalln(\"Error decoding JSON to map:\", err)\n}\n"
    ],
    "description": "",
    "prefix": "json decode"
  },
  "json encode": {
    "body": [
      "var m map[string]string\nencoder := json.NewEncoder(file)\nerr = encoder.Encode(m)\nif err != nil {\n    log.Fatalln(\"Error encoding map to JSON:\", err)\n}\n"
    ],
    "description": "",
    "prefix": "json encode"
  },
  "json marshal memory to json": {
    "body": [
      "type Employee struct {\n\tID                            int\n\tFirstName, LastName, JobTitle string\n}\n\nemp := Employee{\n    ID:        100,\n    FirstName: \"Shiju\",\n    LastName:  \"Varghese\",\n    JobTitle:  \"Architect\",\n}\n\n// Encoding to JSON\ndata, err := json.Marshal(emp)\nif err != nil {\n    fmt.Println(err.Error())\n    return\n}\n\njsonStr := string(data)\nfmt.Println(\"The JSON data is:\")\nfmt.Println(jsonStr)\n"
    ],
    "description": "",
    "prefix": "json marshal memory to json"
  },
  "json unmarshal json to memory": {
    "body": [
      "type Employee struct {\n\tID                            int\n\tFirstName, LastName, JobTitle string\n}\n\nb := []byte(`{\"ID\":101,\"FirstName\":\"Irene\",\"LastName\":\"Rose\",\"JobTitle\":\"Developer\"}`)\nvar emp1 Employee\n// Decoding JSON data to a value of struct type\nerr := json.Unmarshal(b, \u0026emp1)\nif err != nil {\n    fmt.Println(err.Error())\n    return\n}\nfmt.Println(\"The Employee value is:\")\nfmt.Printf(\"ID:%d, Name:%s %s, JobTitle:%s\", emp1.ID, emp1.FirstName, emp1.LastName, emp1.JobTitle)\n\n\n"
    ],
    "description": "",
    "prefix": "json unmarshal json to memory"
  },
  "log set flags": {
    "body": [
      "log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n"
    ],
    "description": "",
    "prefix": "log set flags"
  },
  "log slog with multiple writers and line number": {
    "body": [
      "// NewLog creates and returns a new slog.Logger instance along with a cleanup function.\n// The cleanup must be called when the application is shutting down to close the log file.\nfunc NewLog(production bool) (logger *slog.Logger, cleanup func(), err error) {\n\tvar logFile *os.File\n\tlogFile, err = os.OpenFile(\"app.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcleanup = func() {\n\t\tif err := logFile.Close(); err != nil {\n\t\t\tlog.Printf(\"Error closing log file: %v\", err)\n\t\t}\n\t}\n\n\topts := \u0026slog.HandlerOptions{\n\t\tLevel:     slog.LevelDebug,\n\t\tAddSource: true, //  This line enables source info (file:line)\n\t}\n\n\tif production {\n\t\tlogger = slog.New(slog.NewTextHandler(logFile, opts))\n\t} else {\n\t\tmultiWriter := io.MultiWriter(os.Stdout, logFile)\n\t\tmultiHandler := slog.NewTextHandler(multiWriter, opts)\n\t\tlogger = slog.New(multiHandler)\n\t}\n\treturn\n}\n"
    ],
    "description": "",
    "prefix": "log slog with multiple writers and line number"
  },
  "log to memory": {
    "body": [
      "// we'll configure the logger to write\n// to a bytes.Buffer\nbuf := bytes.Buffer{}\n\n// second argument is the prefix last argument is about options\n// you combine them with a logical or.\nlogger := log.New(\u0026buf, \"logger: \", log.Lshortfile|log.Ldate)\nlogger.Println(\"test\")\nlogger.SetPrefix(\"new logger: \")\nlogger.Printf(\"you can also add args(%v) and use Fatalln to log and crash\", true)\n\nfmt.Println(buf.String())\n"
    ],
    "description": "",
    "prefix": "log to memory"
  },
  "log with caller": {
    "body": [
      "func logWithCaller(msg string) {\n\tpc, file, line, ok := runtime.Caller(1)\n\tif !ok {\n\t\tlog.Println(\"Failed to get caller info\")\n\t\treturn\n\t}\n\tfuncName := runtime.FuncForPC(pc).Name()\n\tlog.Printf(\"[%s:%d %s] %s\\n\", file, line, funcName, msg)\n}\n"
    ],
    "description": "",
    "prefix": "log with caller"
  },
  "log with multiple writers and line numbers": {
    "body": [
      "// NewLog creates and returns a new *log.Logger instance and a cleanup function.\n// Logs are written to both app.log and stdout unless production is true.\nfunc NewLog(production bool) (logger *log.Logger, cleanup func(), err error) {\n\tvar logFile *os.File\n\tlogFile, err = os.OpenFile(\"app.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcleanup = func() {\n\t\tif cerr := logFile.Close(); cerr != nil {\n\t\t\tlog.Printf(\"Error closing log file: %v\", cerr)\n\t\t}\n\t}\n\n\tvar writer io.Writer\n\tif production {\n\t\twriter = logFile\n\t} else {\n\t\twriter = io.MultiWriter(os.Stdout, logFile)\n\t}\n\n\tlogger = log.New(writer, \"\", log.Ldate|log.Ltime|log.Lshortfile) // adds timestamp + file:line\n\treturn\n}\n"
    ],
    "description": "",
    "prefix": "log with multiple writers and line numbers"
  },
  "mail read": {
    "body": [
      "// an example email message\nconst msg string = `Date: Thu, 24 Jul 2019 08:00:00 -0700\nFrom: Aaron \u003cfake_sender@example.com\u003e\nTo: Reader \u003cfake_receiver@example.com\u003e\nSubject: Gophercon 2019 is going to be awesome!\n\nFeel free to share my book with others if you're attending.\nThis recipe can be used to process and parse email information.\n`\n\nr := strings.NewReader(msg)\nm, err := mail.ReadMessage(r)\nif err != nil {\n    log.Fatal(err)\n}\n\nprintHeaderInfo(m.Header)\n\n// after printing the header, dump the body to stdout\nif _, err := io.Copy(os.Stdout, m.Body); err != nil {\n    log.Fatal(err)\n}\n\n// extract header info and print it nicely\nfunc printHeaderInfo(header mail.Header) {\n\t// this works because we know it's a single address\n\t// otherwise use ParseAddressList\n\ttoAddress, err := mail.ParseAddress(header.Get(\"To\"))\n\tif err == nil {\n\t\tfmt.Printf(\"To: %s \u003c%s\u003e\\n\", toAddress.Name, toAddress.Address)\n\t}\n\tfromAddress, err := mail.ParseAddress(header.Get(\"From\"))\n\tif err == nil {\n\t\tfmt.Printf(\"From: %s \u003c%s\u003e\\n\", fromAddress.Name, fromAddress.Address)\n\t}\n\n\tfmt.Println(\"Subject:\", header.Get(\"Subject\"))\n\n\t// this works for a valid RFC5322 date\n\t// it does a header.Get(\"Date\"), then a\n\t// mail.ParseDate(that_result)\n\tif date, err := header.Date(); err == nil {\n\t\tfmt.Println(\"Date:\", date)\n\t}\n\n\tfmt.Println(strings.Repeat(\"=\", 40))\n\tfmt.Println()\n}\n"
    ],
    "description": "",
    "prefix": "mail read"
  },
  "mail send link": {
    "body": [
      "\"github.com/domodwyer/mailyak/v3\"\n\nfunc sendResetPassword(email, link string) error {\n\t// Create a new email - specify the SMTP host:port and auth (if needed)\n\tmail := mailyak.New(\"smtp.mail.me.com:587\", smtp.PlainAuth(\"\", \"andreinita@icloud.com\", \"kqfp-sdar-bxzw-awfu\", \"smtp.mail.me.com\"))\n\n\tmail.To(email)\n\tmail.From(\"andreinita@icloud.com\")\n\tmail.FromName(\"Localhost\")\n\n\tmail.Subject(\"Password Reset\")\n\n\t// Or set the body using a string setter\n\tmail.Plain().Set(\"Click the link to reset your password: \" + link)\n\n\t// And you're done!\n\tif err := mail.Send(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
    ],
    "description": "",
    "prefix": "mail send link"
  },
  "mail send template with data": {
    "body": [
      "package smtp\n\nimport (\n\t\"bytes\"\n\t\"time\"\n\n\t\"gostart/assets\"\n\t\"gostart/internal/funcs\"\n\n\t\"github.com/wneessen/go-mail\"\n\n\thtmlTemplate \"html/template\"\n\ttextTemplate \"text/template\"\n)\n\nconst defaultTimeout = 10 * time.Second\n\ntype Mailer struct {\n\tclient *mail.Client\n\tfrom   string\n}\n\nfunc NewMailer(host string, port int, username, password, from string) (*Mailer, error) {\n\tclient, err := mail.NewClient(host, mail.WithTimeout(defaultTimeout), mail.WithSMTPAuth(mail.SMTPAuthLogin), mail.WithPort(port), mail.WithUsername(username), mail.WithPassword(password))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmailer := \u0026Mailer{\n\t\tclient: client,\n\t\tfrom:   from,\n\t}\n\n\treturn mailer, nil\n}\n\nfunc (m *Mailer) Send(recipient string, data any, patterns ...string) error {\n\tfor i := range patterns {\n\t\tpatterns[i] = \"emails/\" + patterns[i]\n\t}\n\tmsg := mail.NewMsg()\n\n\terr := msg.To(recipient)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = msg.From(m.from)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tts, err := textTemplate.New(\"\").Funcs(funcs.TemplateFuncs).ParseFS(assets.EmbeddedFiles, patterns...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsubject := new(bytes.Buffer)\n\terr = ts.ExecuteTemplate(subject, \"subject\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmsg.Subject(subject.String())\n\n\tplainBody := new(bytes.Buffer)\n\terr = ts.ExecuteTemplate(plainBody, \"plainBody\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmsg.SetBodyString(mail.TypeTextPlain, plainBody.String())\n\n\tif ts.Lookup(\"htmlBody\") != nil {\n\t\tts, err := htmlTemplate.New(\"\").Funcs(funcs.TemplateFuncs).ParseFS(assets.EmbeddedFiles, patterns...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thtmlBody := new(bytes.Buffer)\n\t\terr = ts.ExecuteTemplate(htmlBody, \"htmlBody\", data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmsg.AddAlternativeString(mail.TypeTextHTML, htmlBody.String())\n\t}\n\n\tfor i := 1; i \u003c= 3; i++ {\n\t\terr = m.client.DialAndSend(msg)\n\n\t\tif nil == err {\n\t\t\treturn nil\n\t\t}\n\n\t\tif i != 3 {\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}\n\n\treturn err\n}\n\n/*\n\npackage main\n\nimport (\n\t\"log\"\n\n\t\"gostart/internal/smtp\"\n)\n\nfunc main() {\n\t// Initialize SMTP settings for the mailer\n\thost := \"smtp.example.com\"\n\tport := 587\n\tusername := \"user@example.com\"\n\tpassword := \"password\"\n\tfrom := \"Example \u003cno_reply@example.com\u003e\"\n\n\tmailer, err := smtp.NewMailer(host, port, username, password, from)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create mailer: %v\", err)\n\t}\n\n\t// Data for the email templates. Fields must match the template placeholders.\n\tdata := struct {\n\t\tBaseURL       string\n\t\tMessage       string\n\t\tRequestMethod string\n\t\tRequestURL    string\n\t\tTrace         string\n\t}{\n\t\tBaseURL:       \"http://localhost:8080\",\n\t\tMessage:       \"An error occurred while processing your request.\",\n\t\tRequestMethod: \"GET\",\n\t\tRequestURL:    \"http://localhost:8080/home\",\n\t\tTrace:         \"example stack trace information\",\n\t}\n\n\t// Send email using the template file 'assets/emails/error-notification.tmpl'\n\terr = mailer.Send(\"recipient@example.com\", data, \"error-notification.tmpl\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send email: %v\", err)\n\t}\n\n\tlog.Println(\"Email sent successfully.\")\n}\n\n*/\n\n"
    ],
    "description": "",
    "prefix": "mail send template with data"
  },
  "middleware auth with context": {
    "body": [
      "\"github.com/golang-jwt/jwt\"\n\nfunc authMiddleware(next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"jwt\")\n\t\tif err != nil {\n\t\t\tctx := context.WithValue(r.Context(), \"user_email\", \"\")\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Parse and validate the JWT\n\t\ttoken, err := jwt.Parse(cookie.Value, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn []byte(secretKey), nil\n\t\t})\n\t\tif err != nil || !token.Valid {\n\t\t\tctx := context.WithValue(r.Context(), \"user_email\", \"\")\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the email from the JWT claims\n\t\tclaims := token.Claims.(jwt.MapClaims)\n\t\tuserEmail := claims[\"email\"].(string)\n\n\t\t// Attach the user email to the request context for use in handlers\n\t\tctx := context.WithValue(r.Context(), \"user_email\", userEmail)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t}\n}\n\nhttp.HandleFunc(\"/\", authMiddleware(homeHandler))\n\nuserEmail, ok := r.Context().Value(\"user_email\").(string)\nif !ok {\n    http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n    return\n}\n\ndata := map[string]interface{}{\n    \"UserEmail\": userEmail,\n}\n\n{{if .UserEmail}}\n    \u003cp\u003eWelcome, {{.UserEmail}}!\u003c/p\u003e\n{{else}}\n    \u003cp\u003eWelcome, Guest!\u003c/p\u003e\n{{end}}\n"
    ],
    "description": "",
    "prefix": "middleware auth with context"
  },
  "middleware cache static files": {
    "body": [
      "package middleware\n\nimport \"net/http\"\n\nfunc Cache(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Vary\", \"Accept-Encoding\")\n\t\tw.Header().Set(\"Cache-Control\", \"public, max-age=7776000\")\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nhttp.Handle(\"/public/\", middlewares.Cache(http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"static/public\")))))\n"
    ],
    "description": "",
    "prefix": "middleware cache static files"
  },
  "middleware concatenation": {
    "body": [
      "var finalHandler http.Handler = mux\nfinalHandler = languageMiddleware(finalHandler)\nfinalHandler = gzipMiddleware(finalHandler)\nfinalHandler = recoveryMiddleware(finalHandler)\n"
    ],
    "description": "",
    "prefix": "middleware concatenation"
  },
  "middleware gzip": {
    "body": [
      "type GzipMiddleware struct {\n\tNext http.Handler\n}\n\ntype gzipResponseWriter struct {\n\thttp.ResponseWriter\n\tio.Writer\n}\n\ntype gzipPusherResponseWriter struct {\n\tgzipResponseWriter\n\thttp.Pusher\n}\n\nfunc (gm *GzipMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif gm.Next == nil {\n\t\tgm.Next = http.DefaultServeMux\n\t}\n\n\tencodings := r.Header.Get(\"Accept-Encoding\")\n\tif !strings.Contains(encodings, \"gzip\") {\n\t\tgm.Next.ServeHTTP(w, r)\n\t\treturn\n\t}\n\tw.Header().Add(\"Content-Encoding\", \"gzip\")\n\tgzipWriter := gzip.NewWriter(w)\n\tdefer gzipWriter.Close()\n\tvar rw http.ResponseWriter\n\tif pusher, ok := w.(http.Pusher); ok { // see if original writer implements server push\n\t\trw = gzipPusherResponseWriter{\n\t\t\tgzipResponseWriter: gzipResponseWriter{\n\t\t\t\tResponseWriter: w,\n\t\t\t\tWriter:         gzipWriter,\n\t\t\t},\n\t\t\tPusher: pusher,\n\t\t}\n\t} else {\n\t\trw = gzipResponseWriter{\n\t\t\tResponseWriter: w,\n\t\t\tWriter:         gzipWriter,\n\t\t}\n\t}\n\tgm.Next.ServeHTTP(rw, r)\n}\n\nfunc (grw gzipResponseWriter) Write(data []byte) (int, error) {\n\treturn grw.Writer.Write(data)\n}\n"
    ],
    "description": "",
    "prefix": "middleware gzip"
  },
  "middleware gzip simple": {
    "body": [
      "type gzipResponseWriter struct {\n\tio.Writer\n\thttp.ResponseWriter\n}\n\nfunc (w gzipResponseWriter) Write(b []byte) (int, error) {\n\treturn w.Writer.Write(b)\n}\n\nfunc (w gzipResponseWriter) Header() http.Header {\n\treturn w.ResponseWriter.Header()\n}\n\nfunc (w gzipResponseWriter) WriteHeader(statusCode int) {\n\tw.ResponseWriter.WriteHeader(statusCode)\n}\n\nfunc gzipMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !strings.Contains(r.Header.Get(\"Accept-Encoding\"), \"gzip\") {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Encoding\", \"gzip\")\n\t\tgz := gzip.NewWriter(w)\n\t\tdefer gz.Close()\n\t\tgzw := gzipResponseWriter{Writer: gz, ResponseWriter: w}\n\t\tnext.ServeHTTP(gzw, r)\n\t})\n}\n"
    ],
    "description": "",
    "prefix": "middleware gzip simple"
  },
  "middleware handle (handler ServeHTTP) with chain": {
    "body": [
      "type HelloHandler struct{}\n\nfunc (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello!\")\n}\n\nfunc log(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Printf(\"Handler called - %T\\n\", h)\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\nfunc protect(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// some code to make sure the user is authorized\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\nhello := HelloHandler{}\nhttp.Handle(\"/hello\", protect(log(hello)))\n"
    ],
    "description": "",
    "prefix": "middleware handle (handler ServeHTTP) with chain"
  },
  "middleware handler func (HandlerFunc) with chain": {
    "body": [
      "func hello(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello!\")\n}\n\nfunc log(h http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tname := runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()\n\t\tfmt.Println(\"Handler function called - \" + name)\n\t\th(w, r)\n\t}\n}\n\nhttp.HandleFunc(\"/hello\", log(hello)) \n"
    ],
    "description": "",
    "prefix": "middleware handler func (HandlerFunc) with chain"
  },
  "middleware recovery with  slog": {
    "body": [
      "func recoveryMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tslog.Error(\"Panic recovered\", \"error\", err, \"path\", r.URL.Path)\n\t\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\t}\n\t\t}()\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n"
    ],
    "description": "",
    "prefix": "middleware recovery with  slog"
  },
  "middleware secure headers": {
    "body": [
      "// Custom middleware handler logs user agent\nfunc addSecureHeaders(h http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"Content-Security-Policy\", \"default-src 'self'\")\n\t\tw.Header().Add(\"X-Frame-Options\", \"SAMEORIGIN\")\n\t\tw.Header().Add(\"X-XSS-Protection\", \"1; mode=block\")\n\t\tw.Header().Add(\"Strict-Transport-Security\", \"max-age=10000, includeSubdomains; preload\")\n\t\tw.Header().Add(\"X-Content-Type-Options\", \"nosniff\")\n\t\th(w, r)\n\t}\n}\n\nhttp.HandleFunc(\"/\", addSecureHeaders(index))\n"
    ],
    "description": "",
    "prefix": "middleware secure headers"
  },
  "mod replace": {
    "body": [
      "replace github.com/binance/binance-connector-go =\u003e github.com/andnt87/binance-connector-go v0.0.0-20250527153907-9d7a2c7a6f22\n\n"
    ],
    "description": "",
    "prefix": "mod replace"
  },
  "os get environment variable": {
    "body": [
      "// Attempt to load the email password from the environment variable.\nemailPassword = os.Getenv(\"emailPassword\")\nif emailPassword == \"\" {\n    log.Fatal(\"Environment variable emailPassword is not set\")\n}\n\nfmt.Println(\"Successfully loaded secretKey and emailPassword from environment variables\")\n"
    ],
    "description": "",
    "prefix": "os get environment variable"
  },
  "os signal": {
    "body": [
      "//initialize our channels\nsignals := make(chan os.Signal)\ndone := make(chan bool)\n\n//hook them up to the signals lib\nsignal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)\n\n//if a signal is caught by this go routine\n//it will write to done\ngo CatchSig(signals, done)\n\nfmt.Println(\"Press ctrl-c to terminate...\")\n\u003c-done\nfmt.Println(\"Done!\")\n\n\n// CatchSig sets up a listener for\n// SIGINT interrupts\nfunc CatchSig(ch chan os.Signal, done chan bool) {\n\t// block on waiting for a signal\n\tsig := \u003c-ch\n\t// print it when it's received\n\tfmt.Println(\"\\nsig received:\", sig)\n\n\t// we can set up handlers for all types of\n\t// sigs here\n\tswitch sig {\n\tcase syscall.SIGINT:\n\t\tfmt.Println(\"handling a SIGINT now!\")\n\tcase syscall.SIGTERM:\n\t\tfmt.Println(\"handling a SIGTERM in an entirely different way!\")\n\tdefault:\n\t\tfmt.Println(\"unexpected signal received\")\n\t}\n\n\t// terminate\n\tdone \u003c- true\n}\n"
    ],
    "description": "",
    "prefix": "os signal"
  },
  "panic recover": {
    "body": [
      "// Panic panics with a divide by zero\nfunc Panic() {\n\tzero := 0\n\ta := 1 / zero\n\tfmt.Println(\"we'll never get here\", a)\n}\n\n// Catcher calls Panic\nfunc Recover() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"panic occurred:\", r)\n\t\t}\n\t}()\n\tPanic()\n}\n"
    ],
    "description": "",
    "prefix": "panic recover"
  },
  "parse templates fs": {
    "body": [
      "var templ *template.Template\n\nvar parseErr error\ntempl, parseErr = template.New(\"\").ParseFS(f, \"templates/*.tmpl\", \"templates/**/*.tmpl\")\nif parseErr != nil {\n    slog.Error(\"Failed to parse templates\", \"error\", parseErr)\n    os.Exit(1)\n}\n\n\nerr := templ.ExecuteTemplate(w, \"lang.tmpl\", data)\nif err != nil {\n    slog.Error(\"Failed to execute template lang.tmpl\", \"error\", err, \"lang\", lang)\n    http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n}\n"
    ],
    "description": "",
    "prefix": "parse templates fs"
  },
  "path normalize for both windows and linux": {
    "body": [
      "path = filepath.ToSlash(path)\n"
    ],
    "description": "",
    "prefix": "path normalize for both windows and linux"
  },
  "path value from url": {
    "body": [
      "dynamic := r.PathValue(\"dynamic\")\n"
    ],
    "description": "",
    "prefix": "path value from url"
  },
  "reflect get values and names of a struct": {
    "body": [
      "type Student struct {\n    Fname  string\n    Lname  string\n    City   string\n    Mobile int64\n}\n\ns := Student{\"Chetan\", \"Kumar\", \"Bangalore\", 7777777777}\nv := reflect.ValueOf(s)\ntypeOfS := v.Type()\n\nfor i := 0; i\u003c v.NumField(); i++ {\n    fmt.Printf(\"Field: %s\\tValue: %v\\n\", typeOfS.Field(i).Name, v.Field(i).Interface())\n}\n"
    ],
    "description": "",
    "prefix": "reflect get values and names of a struct"
  },
  "regex match parameter": {
    "body": [
      "var (\n\tregexPath *regexp.Regexp\n)\n\nfunc init() {\n\tregexPath = regexp.MustCompile(\"^/(evenimente)/([a-zA-Z0-9-]+)$\")\n\n}\n\n// inside route\nif match := regexPath.FindString(r.URL.Path); match != \"\" {\n    fmt.Fprintln(w, path.Base(match))\n    return\n}\n"
    ],
    "description": "",
    "prefix": "regex match parameter"
  },
  "regex match string": {
    "body": [
      "// only letter and numbers. No space, /, # ecc.\nmatch, err := regexp.MatchString(\"[A-Za-z0-9]+$\", projectname)\nif err != nil {\n    log.Fatalln(err)\n}\n"
    ],
    "description": "",
    "prefix": "regex match string"
  },
  "regex valigate email": {
    "body": [
      "var emailRegex = regexp.MustCompile(\"^[a-zA-Z0-9.!#$%\u0026'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\")\n\n// isEmailValid checks if the email provided passes the required structure and length.\nfunc isEmailValid(e string) bool {\n\tif len(e) \u003c 3 \u0026\u0026 len(e) \u003e 254 {\n\t\treturn false\n\t}\n\treturn emailRegex.MatchString(e)\n}\n"
    ],
    "description": "",
    "prefix": "regex valigate email"
  },
  "request base url path": {
    "body": [
      "//   / \t\t\t =\u003e /\n//   /ciao \t\t =\u003e ciao\n//   /ciao/Andrei   =\u003e Andrei\nlocal := path.Base(r.URL.Path)\n"
    ],
    "description": "",
    "prefix": "request base url path"
  },
  "request get form value": {
    "body": [
      "email := r.FormValue(\"email\")\n"
    ],
    "description": "",
    "prefix": "request get form value"
  },
  "request get url parametr as integer": {
    "body": [
      "parse url parameter as int (/ciao?id=1)\n"
    ],
    "description": "",
    "prefix": "request get url parametr as integer"
  },
  "request isAuth (is authenticated)": {
    "body": [
      "user, ok := r.Context().Value(\"auth\").(User)\nif !ok || !user.IsAuth {\n    setFlash(w, flashCookie, \"Please login\")\n    http.Redirect(w, r, \"/login\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "request isAuth (is authenticated)"
  },
  "request method post (not allow if not post)": {
    "body": [
      "if r.Method != http.MethodPost {\n    w.Header().Set(\"Allow\", \"POST\")\n    http.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n    return\n\n}\n"
    ],
    "description": "",
    "prefix": "request method post (not allow if not post)"
  },
  "request url get parameter": {
    "body": [
      "// ?token=\nr.URL.Query().Get(\"token\"),\n\n"
    ],
    "description": "",
    "prefix": "request url get parameter"
  },
  "runtime check memory": {
    "body": [
      "func printStats(mem runtime.MemStats) {\n\truntime.ReadMemStats(\u0026mem)\n\tfmt.Println(\"mem.Alloc:\", mem.Alloc)\n\tfmt.Println(\"mem.TotalAlloc:\", mem.TotalAlloc)\n\tfmt.Println(\"mem.HeapAlloc:\", mem.HeapAlloc)\n\tfmt.Println(\"mem.NumGC:\", mem.NumGC)\n\tfmt.Println(\"-----\")\n}\n\nvar mem runtime.MemStats\nprintStats(mem)\n"
    ],
    "description": "",
    "prefix": "runtime check memory"
  },
  "runtime file get path at runtime": {
    "body": [
      "_, filename, _, _ := runtime.Caller(0) // get full path of this file\nfmt.Println(filename)\n"
    ],
    "description": "",
    "prefix": "runtime file get path at runtime"
  },
  "runtime info (compiler, goarch, version, num pcu, num goroutines)": {
    "body": [
      "fmt.Print(\"You are using \", runtime.Compiler, \" \")\nfmt.Println(\"on a\", runtime.GOARCH, \"machine\")\nfmt.Println(\"Using Go version\", runtime.Version())\nfmt.Println(\"Number of CPUs:\", runtime.NumCPU())\nfmt.Println(\"Number of Goroutines:\", runtime.NumGoroutine())\n"
    ],
    "description": "",
    "prefix": "runtime info (compiler, goarch, version, num pcu, num goroutines)"
  },
  "runtime os (operating system)": {
    "body": [
      "if runtime.GOOS == \"windows\" {\n    fmt.Println(\"Hello from Windows\")\n}\n"
    ],
    "description": "",
    "prefix": "runtime os (operating system)"
  },
  "sass example": {
    "body": [
      "transpiler, _ := libsass.New(libsass.Options{OutputStyle: libsass.CompressedStyle})\n\n\tstart := time.Now()\n\tresult, _ := transpiler.Execute(`\n$font-stack:    Helvetica, sans-serif;\n$primary-color: #321;\n\nbody {\n  font: 100% $font-stack;\n  color: $primary-color;\n}\n`)\n\n\tfmt.Println(time.Since(start))\n\tfmt.Println(result.CSS)\n\t// Output: body{font:100% Helvetica,sans-serif;color:#333}\n"
    ],
    "description": "",
    "prefix": "sass example"
  },
  "server get ip": {
    "body": [
      "func getIP() string {\n\thost, _ := os.Hostname()\n\taddrs, _ := net.LookupIP(host)\n\tip := \"\"\n\tfor _, addr := range addrs {\n\t\tif ipv4 := addr.To4(); ipv4 != nil {\n\t\t\tif ipv4.String() == \"127.0.0.1\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ipv4.String()\n\t\t\tbreak\n\t\t}\n\t}\n\treturn ip\n}\n"
    ],
    "description": "",
    "prefix": "server get ip"
  },
  "slog setup": {
    "body": [
      "func setupLogger(isProd bool) slog.Handler {\n\tif isProd {\n\t\tlogFile, err := os.OpenFile(\"app.json\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to open log file: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\treturn slog.NewJSONHandler(logFile, \u0026slog.HandlerOptions{\n\t\t\tAddSource: true,\n\t\t\tLevel:     slog.LevelInfo,\n\t\t})\n\t}\n\treturn slog.NewTextHandler(os.Stdout, \u0026slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t})\n}\n\n// handler := setupLogger(*isProd)\n// logger := slog.New(handler)\n// slog.SetDefault(logger)\n"
    ],
    "description": "",
    "prefix": "slog setup"
  },
  "snippet app": {
    "body": [
      "package main\n\nimport (\n\t\"database/sql\"\n\t_ \"embed\"\n\t\"fmt\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\nconst isProduction = false\n\nvar db *sql.DB\nvar logger *log.Logger\n\ntype Component struct {\n\tID        int    `json:\"id\"`\n\tURL       string `json:\"url\"`\n\tName      string `json:\"name\"`\n\tHTML      string `json:\"html\"`\n\tJS        string `json:\"js\"`\n\tCSS       string `json:\"css\"`\n\tLess      string `json:\"less\"`\n\tSass      string `json:\"sass\"`\n\tCSSDark   string `json:\"css_dark\"`\n\tLessDark  string `json:\"less_dark\"`\n\tSassDark  string `json:\"sass_dark\"`\n\tCreatedAt string `json:\"created_at\"`\n\tUpdatedAt string `json:\"updated_at\"`\n}\n\nfunc initDB() {\n\tvar err error\n\tdb, err = sql.Open(\"sqlite3\", \"file:codestich.db?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\n\t// Configure connection pool\n\tdb.SetMaxOpenConns(25)\n\tdb.SetMaxIdleConns(25)\n\tdb.SetConnMaxLifetime(5 * time.Minute)\n\n\t_, err = db.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS components (\n\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\turl TEXT UNIQUE NOT NULL,\n\t\t\tname TEXT NOT NULL,\n\t\t\thtml TEXT NOT NULL,\n\t\t\tjs TEXT NOT NULL,\n\t\t\tcss TEXT NOT NULL,\n\t\t\tless TEXT NOT NULL,\n\t\t\tsass TEXT NOT NULL,\n\t\t\tcss_dark TEXT NOT NULL,\n\t\t\tless_dark TEXT NOT NULL,\n\t\t\tsass_dark TEXT NOT NULL,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\t\t\tupdated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t);\n\t`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc closeDB() {\n\terr := db.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Closing database without errors\")\n}\n\nfunc main() {\n\t// Open a file for logging\n\tfile, err := os.OpenFile(\"logfile.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open log file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\t// Create a multi-writer to log to both file and stdout\n\tvar multiWriter io.Writer\n\tif !isProduction {\n\t\tmultiWriter = io.MultiWriter(file, os.Stdout)\n\t} else {\n\t\tmultiWriter = file\n\t}\n\n\t// Create a new logger\n\tlogger = log.New(multiWriter, \"\", log.LstdFlags)\n\n\tinitDB()\n\tdefer closeDB()\n}\n\n"
    ],
    "description": "",
    "prefix": "snippet app"
  },
  "snippet binance calculate quantity": {
    "body": [
      "// calculateValidQuantity computes valid quantity for a custom USDC amount.\n// Args:\n//\n//\tsymbol: Trading pair (e.g., \"BTCUSDC\").\n//\tmoneyStr: Desired USDC amount (e.g., \"10.5\").\nfunc calculateValidQuantity(client *bc.Client, symbol, moneyStr string) (float64, error) {\n\terrg, ctx := errgroup.WithContext(context.Background())\n\tstepSize, minNotional, priceStr := decimal.Decimal{}, decimal.Decimal{}, []*bc.TickerPriceResponse{}\n\n\terrg.Go(func() error {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tvar err error\n\t\t// Fetch symbol info (precision, minNotional)\n\t\tstepSize, minNotional, err = getSymbolFilters(client, symbol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\n\terrg.Go(func() error {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tvar err error\n\t\t// Fetch latest price\n\t\tpriceStr, err = marketGetLastPrice(client, symbol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err := errg.Wait(); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Parse inputs\n\tmoney, _ := decimal.NewFromString(moneyStr)\n\tprice, _ := decimal.NewFromString(priceStr[0].Price)\n\tif money.IsZero() || price.IsZero() {\n\t\treturn 0, fmt.Errorf(\"invalid money/price\")\n\t}\n\n\t// Calculate quantity and round UP to stepSize precision\n\tquantity := money.Div(price)\n\tquantity = adjustToStepSize(quantity, stepSize)\n\n\t// Ensure notional  max(minNotional, money)\n\tminNotionalVal := decimal.Max(minNotional, money)\n\tif notional := quantity.Mul(price); notional.LessThan(minNotionalVal) {\n\t\treturn 0, fmt.Errorf(\"notional too small (need %s, got %s)\", minNotionalVal, notional)\n\t}\n\n\treturn quantity.InexactFloat64(), nil\n}\n\n// getSymbolFilters retrieves precision (stepSize) and minNotional from Binance\nfunc getSymbolFilters(client *bc.Client, symbol string) (stepSize, minNotional decimal.Decimal, err error) {\n\tres, err := client.NewExchangeInfoService().Symbol(symbol).Do(context.Background())\n\tif err != nil {\n\t\treturn decimal.Zero, decimal.Zero, fmt.Errorf(\"failed to fetch symbol info: %v\", err)\n\t}\n\n\tfor _, s := range res.Symbols {\n\t\tif s.Symbol == symbol {\n\t\t\tfor _, filter := range s.Filters {\n\t\t\t\t// Extract LOT_SIZE (stepSize)\n\t\t\t\tif filter.FilterType == \"LOT_SIZE\" {\n\t\t\t\t\tstepSize = decimal.RequireFromString(filter.StepSize)\n\t\t\t\t}\n\t\t\t\t// Extract MIN_NOTIONAL or NOTIONAL filter\n\t\t\t\tif filter.FilterType == \"MIN_NOTIONAL\" || filter.FilterType == \"NOTIONAL\" {\n\t\t\t\t\tminNotional = decimal.RequireFromString(filter.MinNotional)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stepSize, minNotional, nil\n\t\t}\n\t}\n\treturn decimal.Zero, decimal.Zero, fmt.Errorf(\"symbol %s not found\", symbol)\n}\n\n// adjustToStepSize rounds UP to Binance's allowed stepSize precision\nfunc adjustToStepSize(qty, stepSize decimal.Decimal) decimal.Decimal {\n\tif stepSize.IsZero() {\n\t\treturn qty\n\t}\n\t// Calculate precision from stepSize (e.g., \"0.001\"  3 decimals)\n\tstepFloat, _ := stepSize.Float64()\n\tprecision := -decimal.NewFromFloat(stepFloat).Exponent()\n\n\t// Round up to stepSize multiple (e.g., 0.123456  0.124)\n\treturn qty.Div(stepSize).Ceil().Mul(stepSize).Truncate(int32(precision))\n}\n\nfunc parseStrNumToFloat(qtyStr string) (float64, error) {\n\tqty, _ := decimal.NewFromString(qtyStr)\n\tif qty.IsZero() {\n\t\treturn 0, fmt.Errorf(\"invalid money/price\")\n\t}\n\n\treturn qty.InexactFloat64(), nil\n}\n\n// Function to calculate and force correct float64 format\nfunc calculateTargetSellPrice(buyPrice, quantity, buyFeeRate, sellFeeRate float64) float64 {\n\t// Convert values to decimal for precision\n\tbuyPriceDec := decimal.NewFromFloat(buyPrice)\n\tquantityDec := decimal.NewFromFloat(quantity)\n\tbuyFeeRateDec := decimal.NewFromFloat(buyFeeRate)\n\tsellFeeRateDec := decimal.NewFromFloat(sellFeeRate)\n\n\t// Calculate buy fee\n\tbuyFee := buyPriceDec.Mul(quantityDec).Mul(buyFeeRateDec)\n\n\t// Calculate target price with 2% profit\n\ttargetPrice := buyPriceDec.Mul(decimal.NewFromFloat(1.02))\n\n\t// Estimate sell fee\n\tsellFee := targetPrice.Mul(quantityDec).Mul(sellFeeRateDec)\n\n\t// Final target price including fees\n\tfinalPrice := targetPrice.Add(buyFee.Div(quantityDec)).Add(sellFee.Div(quantityDec)).Round(8)\n\n\t// Format as a string to remove scientific notation\n\tstrPrice := finalPrice.String() // Guarantees a fixed decimal format\n\n\t// Convert back to float64 properly\n\tfinalFloat, _ := strconv.ParseFloat(strPrice, 64)\n\n\treturn finalFloat\n}\n\n// Function to format float as a proper decimal before passing to Binance API\nfunc formatDecimalForBinance(value float64, precision int) string {\n\t// Convert to decimal for precision control\n\tdec := decimal.NewFromFloat(value)\n\n\t// Format as a fixed decimal string with correct precision\n\treturn dec.Round(int32(precision)).String() // Keeps trailing zeros\n}\n"
    ],
    "description": "",
    "prefix": "snippet binance calculate quantity"
  },
  "snippet boileprlate + auth system": {
    "body": [
      "package main\n\nimport (\n\t\"context\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"database/sql\"\n\t_ \"embed\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/NYTimes/gziphandler\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/gorilla/csrf\"\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"html/template\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/smtp\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n\n\t\"github.com/domodwyer/mailyak/v3\"\n\t\"github.com/golang-jwt/jwt\"\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nconst isProduction = false\nconst domain = \"http://localhost:8080\"\n\n// rate limit middleware\nconst rateLimitDuration = 1 * time.Minute // Time frame for rate limiting\nconst maxRequests = 100                   // Maximum number of requests per time frame\n\n// rate limit signup\nconst rateLimitDurationSignup = 1 * time.Minute // Time frame for rate limiting\nconst maxRequestsSignup = 1                     // Maximum number of requests per time frame\n\nconst flashCookie = \"flash\"\nconst tokenCookieValidate = \"token_validate\"\n\nconst levelInfo = \"info\"\nconst levelWarning = \"warning\"\nconst levelError = \"error\"\n\nvar secretKey string\nvar smtpPass string\nvar smtpUser string\n\n//go:embed reload.html\nvar reloadHtmlFile []byte\n\nvar dbAuth *sql.DB\nvar logger *log.Logger\n\n// templates\nvar templates *template.Template\nvar templateDir = \"app/src\"\nvar templateFiles = make(map[string]bool)\n\n// websocket\nvar upgrader = websocket.Upgrader{}\nvar connections = make(map[*websocket.Conn]bool)\nvar mu sync.Mutex\n\n// rate limit middleware\nvar muRateLimit sync.Mutex\nvar rateLimitMap = make(map[string]int)\n\n// signupRateLimitMax\nvar muSignupRateLimit sync.Mutex\nvar rateSignupLimitMap = make(map[string]int)\n\ntype User struct {\n\tId        string    `json:\"id\"`\n\tIsAuth    bool      `json:\"isAuth\"`\n\tEmail     string    `json:\"email\"`\n\tPassword  string    `json:\"password\"`\n\tUserType  string    `json:\"user_type\"`\n\tVerified  bool      `json:\"verified\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}\n\nfunc init() {\n\t// Attempt to load the secret key from the environment variable.\n\tsecretKey = os.Getenv(\"secretKey\")\n\tif secretKey == \"\" {\n\t\tlog.Fatal(\"Environment variable secretKey is not set\")\n\t}\n\n\t// Attempt to load the email password from the environment variable.\n\tsmtpPass = os.Getenv(\"smtpPass\")\n\tif smtpPass == \"\" {\n\t\tlog.Fatal(\"Environment variable emailPassword is not set\")\n\t}\n\n\tsmtpUser = os.Getenv(\"smtpUser\")\n\tif smtpUser == \"\" {\n\t\tlog.Fatal(\"Environment variable emailPassword is not set\")\n\t}\n\n\tfmt.Println(\"Successfully loaded secretKey and emailPassword from environment variables\")\n}\n\nfunc watchDirectory(directory string) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Close()\n\n\terr = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.IsDir() {\n\t\t\tif err := watcher.Add(path); err != nil {\n\t\t\t\tlog.Printf(\"Error watching directory: %s, %v\", path, err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Watching:\", path)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Watching directory:\", directory)\n\tfor {\n\t\tselect {\n\t\tcase event, ok := \u003c-watcher.Events:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif event.Op\u0026(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 \u0026\u0026 strings.HasSuffix(event.Name, \".html\") {\n\t\t\t\tfmt.Println(\"HTML file changed:\", event.Name)\n\t\t\t\tif err := loadTemplates(); err != nil {\n\t\t\t\t\tlog.Println(\"Failed to reload templates:\", err)\n\t\t\t\t}\n\t\t\t\tnotifyClients()\n\t\t\t}\n\t\t\tif event.Op\u0026fsnotify.Create == fsnotify.Create {\n\t\t\t\tfileInfo, err := os.Stat(event.Name)\n\t\t\t\tif err == nil \u0026\u0026 fileInfo.IsDir() {\n\t\t\t\t\twatcher.Add(event.Name)\n\t\t\t\t\tfmt.Println(\"Added new directory to watch:\", event.Name)\n\t\t\t\t}\n\t\t\t}\n\t\tcase err, ok := \u003c-watcher.Errors:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Println(\"Error watching files:\", err)\n\t\t}\n\t}\n}\n\nfunc renderHTML(w http.ResponseWriter, page string, data map[string]interface{}) {\n\terr := templates.ExecuteTemplate(w, page, data)\n\tif err != nil {\n\t\tlogToFileWithCaller(levelError, err.Error())\n\t\thttp.Error(w, \"Please try letter\", http.StatusInternalServerError)\n\t}\n}\n\n// renderHTMLAuthFlashCSRF renders the html checking for authentication and flash cookie\nfunc renderHTMLAuthFlashCSRF(w http.ResponseWriter, r *http.Request, page string, data map[string]interface{}) {\n\tif data == nil {\n\t\tdata = make(map[string]interface{})\n\t}\n\n\t// Retrieve authentication details from the context\n\tuser, ok := r.Context().Value(\"auth\").(User)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tflashMsg, _ := getFlash(w, r, flashCookie)\n\n\tdata[\"UserEmail\"] = user.Email\n\tdata[\"UserType\"] = user.UserType\n\tdata[\"UserVerified\"] = user.Verified\n\tdata[\"IsAuth\"] = user.IsAuth\n\tdata[\"FlashMsg\"] = flashMsg\n\tdata[csrf.TemplateTag] = csrf.TemplateField(r)\n\n\terr := templates.ExecuteTemplate(w, page, data)\n\tif err != nil {\n\t\tlogToFileWithCaller(levelError, err.Error())\n\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t}\n}\n\nfunc loadTemplates() error {\n\ttmpl := template.New(\"\")\n\n\terr := filepath.WalkDir(templateDir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Ext(path) == \".html\" {\n\t\t\trelPath, err := filepath.Rel(templateDir, path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trelPath = filepath.ToSlash(relPath) // Ensure cross-platform compatibility\n\t\t\tif strings.HasPrefix(relPath, \"pages/\") {\n\t\t\t\ttemplateFiles[relPath] = true\n\t\t\t}\n\t\t\tcontent, err := os.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = tmpl.New(relPath).Parse(string(content))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\ttemplates = tmpl\n\tlog.Println(\"Templates reloaded successfully.\")\n\treturn nil\n}\n\nfunc notifyClients() {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tfor conn := range connections {\n\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(\"reload\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Deleting connection:\", err)\n\t\t\tconn.Close()\n\t\t\tdelete(connections, conn)\n\t\t}\n\t}\n}\n\n// CORS Middleware\nfunc cors(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\torigin := domain\n\t\tif isProduction {\n\t\t\torigin = \"https://\" + strings.TrimPrefix(domain, \"http://\")\n\t\t}\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", origin)\n\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, X-CSRF-Token\")\n\t\t\tw.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc securityHeaders(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Strict-Transport-Security\", \"max-age=63072000; includeSubDomains; preload\")\n\t\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\t\tif isProduction {\n\t\t\tw.Header().Set(\"X-Frame-Options\", \"DENY\")\n\t\t}\n\t\tw.Header().Set(\"X-XSS-Protection\", \"0\") // Deprecated, modern browsers ignore it\n\t\tw.Header().Set(\"Content-Security-Policy\", \"default-src 'self'; style-src 'self' 'unsafe-inline'\")\n\t\tw.Header().Set(\"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// Error Handling Middleware\nfunc errorHandling(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\t}\n\t\t}()\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// Example Rate Limiting Middleware\nfunc rateLimiting(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tmuRateLimit.Lock()\n\t\tdefer muRateLimit.Unlock()\n\n\t\tclientIP := r.RemoteAddr\n\t\tcount, exists := rateLimitMap[clientIP]\n\n\t\tif exists \u0026\u0026 count \u003e= maxRequests {\n\t\t\thttp.Error(w, \"Rate limit exceeded. Please try again later.\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\tif !exists {\n\t\t\tgo resetRateLimit(clientIP)\n\t\t}\n\n\t\trateLimitMap[clientIP]++\n\t\t//fmt.Println(\"Rate Limit Logic: \", clientIP, rateLimitMap[clientIP])\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc resetRateLimit(clientIP string) {\n\ttime.Sleep(rateLimitDuration)\n\tmuRateLimit.Lock()\n\tdefer muRateLimit.Unlock()\n\tdelete(rateLimitMap, clientIP)\n}\n\nfunc authMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"jwt\")\n\t\tif err != nil {\n\t\t\tctx := context.WithValue(r.Context(), \"auth\", User{})\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Parse and validate the JWT\n\t\ttoken, err := jwt.Parse(cookie.Value, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid signing method\")\n\t\t\t}\n\t\t\treturn []byte(secretKey), nil\n\t\t})\n\t\tif err != nil || !token.Valid {\n\t\t\tctx := context.WithValue(r.Context(), \"auth\", User{})\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Extract claims from the JWT\n\t\tclaims, ok := token.Claims.(jwt.MapClaims)\n\t\tif !ok {\n\t\t\tctx := context.WithValue(r.Context(), \"auth\", User{})\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Check expiration\n\t\tif exp, ok := claims[\"exp\"].(float64); ok \u0026\u0026 time.Now().Unix() \u003e int64(exp) {\n\t\t\tctx := context.WithValue(r.Context(), \"auth\", User{})\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\n\t\t// Create User struct from claims\n\t\tauthData := User{\n\t\t\tEmail:    claims[\"email\"].(string),\n\t\t\tUserType: claims[\"user_type\"].(string),\n\t\t\tVerified: claims[\"verified\"].(bool),\n\t\t\tIsAuth:   claims[\"isAuth\"].(bool),\n\t\t}\n\n\t\t// Attach the auth data to the request context\n\t\tctx := context.WithValue(r.Context(), \"auth\", authData)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\n// Custom logger to include file and line number\nfunc logToFileWithCaller(level string, msg string) {\n\t_, file, line, ok := runtime.Caller(2)\n\tif !ok {\n\t\tfile = \"unknown\"\n\t\tline = 0\n\t}\n\tlogger.Printf(\"%s: %s [%s:%d]\\n\", level, msg, file, line)\n}\n\nfunc initAuthDB() {\n\tvar err error\n\tdbAuth, err = sql.Open(\"sqlite3\", \"file:auth.db?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\n\t// Configure connection pool\n\tdbAuth.SetMaxOpenConns(25)\n\tdbAuth.SetMaxIdleConns(25)\n\tdbAuth.SetConnMaxLifetime(5 * time.Minute)\n\n\t_, err = dbAuth.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\temail TEXT UNIQUE NOT NULL,\n\t\t\tpassword TEXT NOT NULL,\n\t\t\tuser_type TEXT NOT NULL DEFAULT 'user', -- Can be 'admin', 'user', etc\n\t\t\tverified BOOLEAN NOT NULL DEFAULT 0,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\t\t\tupdated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t);\n\t`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc closeAuthDB() {\n\terr := dbAuth.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Closing database without errors\")\n}\n\nfunc setCookie(w http.ResponseWriter, name, value string, expiry time.Time) {\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tExpires:  expiry,\n\t\tHttpOnly: true,\n\t\tSecure:   true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t})\n}\n\nfunc getCookie(w http.ResponseWriter, r *http.Request, name string) (*http.Cookie, error) {\n\tcookie, err := r.Cookie(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsetCookie(w, name, \"\", time.Now().Add(-1*time.Hour))\n\treturn cookie, nil\n}\n\n// setFlash sets a flash message in a cookie\nfunc setFlash(w http.ResponseWriter, name, value string) {\n\tc := \u0026http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     \"/\",\n\t\tMaxAge:   10, // The cookie will be deleted after 10 seconds\n\t\tHttpOnly: true,\n\t\tSecure:   true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t}\n\thttp.SetCookie(w, c)\n}\n\n// getFlash retrieves and clears a flash message from a cookie\nfunc getFlash(w http.ResponseWriter, r *http.Request, name string) (string, error) {\n\tc, err := r.Cookie(name)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase http.ErrNoCookie:\n\t\t\treturn \"\", nil // No flash message\n\t\tdefault:\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\thttp.SetCookie(w, \u0026http.Cookie{\n\t\tName:     name,\n\t\tPath:     \"/\",\n\t\tMaxAge:   -1, // Delete the cookie\n\t\tHttpOnly: true,\n\t\tSecure:   true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t})\n\n\treturn c.Value, nil\n}\n\nfunc encryptToken(email string, secretKey []byte) (string, error) {\n\tplaintext := []byte(email + \"|\" + time.Now().Add(1*time.Hour).Format(time.RFC3339))\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)\n\treturn base64.URLEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc decryptToken(token string, secretKey []byte) (string, error) {\n\tciphertext, err := base64.URLEncoding.DecodeString(token)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\tif len(ciphertext) \u003c nonceSize {\n\t\treturn \"\", fmt.Errorf(\"ciphertext too short\")\n\t}\n\n\tnonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n\tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparts := strings.SplitN(string(plaintext), \"|\", 2)\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid token format\")\n\t}\n\n\texpiry, err := time.Parse(time.RFC3339, parts[1])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif time.Now().After(expiry) {\n\t\treturn \"\", fmt.Errorf(\"token has expired\")\n\t}\n\n\treturn parts[0], nil\n}\n\nfunc verifyTokens(token1, token2 string) (string, error) {\n\temail1, err := decryptToken(token1, []byte(secretKey))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\temail2, err := decryptToken(token2, []byte(secretKey))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif email1 != email2 {\n\t\treturn \"\", errors.New(\"tokens don't match\")\n\t}\n\treturn email1, nil\n}\n\nfunc emailSendLink(email, link string) error {\n\t// Create a new email - specify the SMTP host:port and auth (if needed)\n\tmail := mailyak.New(\"smtp.mail.me.com:587\", smtp.PlainAuth(\"\", smtpUser, smtpPass, \"smtp.mail.me.com\"))\n\n\tmail.To(email)\n\tmail.From(smtpUser)\n\tmail.FromName(\"Localhost\")\n\n\tmail.Subject(\"Password Reset\")\n\n\t// Or set the body using a string setter\n\tmail.Plain().Set(\"Click the link to reset your password: \" + link)\n\n\t// And you're done!\n\tif err := mail.Send(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// verifyUserEmail sends a verification email: verifyUserEmail(w, user, \"/urlPath\")\nfunc verifyUserEmail(w http.ResponseWriter, email, urlPath string) error {\n\tresetToken, err := encryptToken(email, []byte(secretKey))\n\tif err != nil {\n\t\tlogToFileWithCaller(levelError, err.Error())\n\t\treturn err\n\t}\n\n\t// Send a password reset email\n\tresetLink := fmt.Sprintf(domain+urlPath+\"?token=%s\", resetToken)\n\tsetCookie(w, tokenCookieValidate, resetToken, time.Now().Add(1*time.Hour)) // TODO: insert to verification_tokens\n\n\tif isProduction {\n\t\tgo func() {\n\t\t\terr = emailSendLink(email, resetLink)\n\t\t\tif err != nil {\n\t\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\t\tsetCookie(w, tokenCookieValidate, \"\", time.Now().Add(-time.Hour))\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tlogToFileWithCaller(levelInfo, resetLink)\n\t}\n\treturn err\n}\n\nfunc signupRateLimitMax(r *http.Request) {\n\tmuSignupRateLimit.Lock()\n\tdefer muSignupRateLimit.Unlock()\n\n\tclientIP := r.RemoteAddr\n\t_, exists := rateSignupLimitMap[clientIP]\n\n\tif !exists {\n\t\tgo resetSignupRateLimit(clientIP)\n\t}\n\n\trateSignupLimitMap[clientIP]++\n}\n\nfunc checkSignupRateLimit(r *http.Request) bool {\n\tmuSignupRateLimit.Lock()\n\tdefer muSignupRateLimit.Unlock()\n\tclientIP := r.RemoteAddr\n\tcount, exists := rateSignupLimitMap[clientIP]\n\tif exists \u0026\u0026 count \u003e= maxRequestsSignup {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc resetSignupRateLimit(clientIP string) {\n\ttime.Sleep(rateLimitDurationSignup)\n\tmuSignupRateLimit.Lock()\n\tdefer muSignupRateLimit.Unlock()\n\tdelete(rateSignupLimitMap, clientIP)\n}\n\nfunc checkPasswordStrength(password string) bool {\n\tif len(password) \u003c 12 {\n\t\treturn false\n\t}\n\tvar hasUpper, hasLower, hasNumber, hasSpecial bool\n\tfor _, r := range password {\n\t\tswitch {\n\t\tcase unicode.IsUpper(r):\n\t\t\thasUpper = true\n\t\tcase unicode.IsLower(r):\n\t\t\thasLower = true\n\t\tcase unicode.IsNumber(r):\n\t\t\thasNumber = true\n\t\tcase unicode.IsPunct(r) || unicode.IsSymbol(r):\n\t\t\thasSpecial = true\n\t\t}\n\t}\n\treturn hasUpper \u0026\u0026 hasLower \u0026\u0026 hasNumber \u0026\u0026 hasSpecial\n}\n\nfunc main() {\n\t// Open a file for logging\n\tfile, err := os.OpenFile(\"logfile.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open log file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\t// Create a multi-writer to log to both file and stdout\n\tvar multiWriter io.Writer\n\tif !isProduction {\n\t\tmultiWriter = io.MultiWriter(file, os.Stdout)\n\t} else {\n\t\tmultiWriter = file\n\t}\n\n\t// Create a new logger\n\tlogger = log.New(multiWriter, \"\", log.LstdFlags)\n\n\tinitAuthDB()\n\tdefer closeAuthDB()\n\n\tif err := loadTemplates(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/public/\", http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"./public\"))))\n\tmux.HandleFunc(\"/favicon.ico\", func(w http.ResponseWriter, r *http.Request) { // avoid duplicate request\n\t\thttp.ServeFile(w, r, \"./public/favicon.ico\")\n\t})\n\n\tmux.HandleFunc(\"/\", homeHandler)\n\tmux.HandleFunc(\"/login\", loginHandler)\n\tmux.HandleFunc(\"/signup\", signupHandler)\n\tmux.HandleFunc(\"/logout\", logoutHandler)\n\tmux.HandleFunc(\"/change-password\", changePasswordHandler)\n\tmux.HandleFunc(\"/reset-password\", resetPasswordHandler)\n\tmux.HandleFunc(\"/delete-account\", deleteAccountHandler)\n\tmux.HandleFunc(\"/confirm-account\", confirmAccountHandler)\n\tmux.HandleFunc(\"/make-admin\", makeAdminHandler)\n\tmux.HandleFunc(\"/users\", getAllUsersHandler)\n\n\tmux.HandleFunc(\"/blog/\", handleDynamic)\n\n\tvar handler http.Handler = mux\n\thandler = gziphandler.GzipHandler(handler)\n\thandler = cors(handler)\n\thandler = securityHeaders(handler)\n\thandler = errorHandling(handler)\n\t//handler = rateLimiting(handler)\n\thandler = authMiddleware(handler)\n\tCSRF := csrf.Protect(\n\t\t[]byte(secretKey),\n\t\tcsrf.Secure(isProduction),\n\t)\n\thandler = CSRF(handler)\n\n\tserver := \u0026http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        handler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   15 * time.Second,\n\t\tIdleTimeout:    60 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20, // 1MB\n\t}\n\n\tif !isProduction {\n\t\tgo watchDirectory(templateDir)\n\n\t\tmux.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupgrader.CheckOrigin = func(r *http.Request) bool { return true }\n\t\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"WebSocket upgrade error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmu.Lock()\n\t\t\tconnections[conn] = true\n\t\t\tmu.Unlock()\n\n\t\t\tfmt.Println(\"New WebSocket connection\")\n\t\t})\n\n\t\tmux.HandleFunc(\"/reload\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\tw.Write(reloadHtmlFile)\n\t\t})\n\n\t\tgo func() {\n\t\t\tlog.Println(\"Starting server on :8080\")\n\t\t\tif err := server.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t\t}\n\t\t}()\n\t} else { // production\n\t\t// Set up autocert for Let's Encrypt\n\t\tm := autocert.Manager{\n\t\t\tPrompt:     autocert.AcceptTOS,\n\t\t\tHostPolicy: autocert.HostWhitelist(domain),\n\t\t\tCache:      autocert.DirCache(\"/var/www/.cache\"), // Ensure this directory is writable\n\t\t}\n\n\t\t// Start HTTP server on port 80 for challenges and redirection\n\t\tgo func() {\n\t\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { // '/' is set on http (and not mux)\n\t\t\t\ttarget := \"https://\" + r.Host + r.URL.Path\n\t\t\t\tif r.URL.RawQuery != \"\" {\n\t\t\t\t\ttarget += \"?\" + r.URL.RawQuery\n\t\t\t\t}\n\t\t\t\thttp.Redirect(w, r, target, http.StatusPermanentRedirect)\n\t\t\t})\n\t\t\tlog.Fatal(http.ListenAndServe(\":80\", m.HTTPHandler(nil)))\n\t\t}()\n\n\t\tserver.Addr = \":443\"\n\t\tserver.Handler = handler\n\t\tserver.TLSConfig = \u0026tls.Config{GetCertificate: m.GetCertificate}\n\n\t\tgo func() {\n\t\t\tlog.Println(\"Starting secure server on :443\")\n\t\t\tif err := server.ListenAndServeTLS(\"\", \"\"); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Graceful shutdown handling\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, os.Interrupt, syscall.SIGTERM)\n\n\t\u003c-stop\n\tlog.Println(\"Shutting down server...\")\n\tif err := server.Close(); err != nil {\n\t\tlog.Fatalf(\"Server shutdown error: %v\", err)\n\t}\n\tlog.Println(\"Server gracefully stopped.\")\n}\n\nfunc handleDynamic(w http.ResponseWriter, r *http.Request) {\n\tpath := strings.TrimPrefix(r.URL.Path, \"/\")\n\tpath = filepath.ToSlash(path) // Ensure cross-platform compatibility\n\ttemplateFile := fmt.Sprintf(\"pages/%s.html\", path)\n\n\tif ok := templateFiles[templateFile]; !ok {\n\t\tif strings.HasSuffix(path, \"/\") {\n\t\t\tpath += \"index\" // route is like /blog/tennis/\n\t\t} else {\n\t\t\tpath += \"/index\" // route is like /blog/tennis\n\t\t}\n\t\ttemplateFile = fmt.Sprintf(\"pages/%s.html\", path)\n\t}\n\n\trenderHTMLAuthFlashCSRF(w, r, templateFile, nil)\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\trenderHTMLAuthFlashCSRF(w, r, \"pages/index.html\", nil)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/login.html\", nil)\n\t\treturn\n\t}\n\n\tif r.Method == http.MethodPost {\n\t\tuser := User{\n\t\t\tEmail:    r.FormValue(\"email\"),\n\t\t\tPassword: r.FormValue(\"password\"),\n\t\t}\n\n\t\tvar dbUser struct {\n\t\t\tPassword string\n\t\t\tUserType string\n\t\t\tVerified bool\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\terr := dbAuth.QueryRowContext(ctx, \"SELECT password, user_type, verified FROM users WHERE email = ?\", user.Email).\n\t\t\tScan(\u0026dbUser.Password, \u0026dbUser.UserType, \u0026dbUser.Verified)\n\t\tif err != nil || bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(user.Password)) != nil {\n\t\t\tsetFlash(w, flashCookie, \"Invalid credentials\")\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// Check if account is verified\n\t\tif !dbUser.Verified {\n\t\t\t// Send verification email again\n\t\t\tif err = verifyUserEmail(w, user.Email, \"/confirm-account\"); err != nil {\n\t\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsetFlash(w, flashCookie, \"Account not verified. We've sent a new verification email.\")\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// Create a JWT with additional claims\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"email\":     user.Email,\n\t\t\t\"user_type\": dbUser.UserType,\n\t\t\t\"verified\":  dbUser.Verified,\n\t\t\t\"isAuth\":    true,\n\t\t\t\"iat\":       time.Now().Unix(),                          // Issued at\n\t\t\t\"exp\":       time.Now().Add(24 * 30 * time.Hour).Unix(), // Expiry (30 days)\n\t\t\t\"nbf\":       time.Now().Unix(),                          // Not before\n\t\t})\n\n\t\t// Sign the JWT with a strong secret key\n\t\ttokenString, err := token.SignedString([]byte(secretKey))\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the JWT in a secure cookie\n\t\tsetCookie(w, \"jwt\", tokenString, time.Now().Add(24*time.Hour))\n\t\tsetFlash(w, flashCookie, \"Login successful!\")\n\n\t\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n\t}\n}\n\nfunc signupHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/signup.html\", nil)\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\tif checkSignupRateLimit(r) {\n\t\t\tsetFlash(w, flashCookie, \"Too many attempts to signup. Please try again after 24 hours.\")\n\t\t\thttp.Redirect(w, r, \"/signup\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tuser := User{\n\t\t\tEmail:    r.FormValue(\"email\"),\n\t\t\tPassword: r.FormValue(\"password\"),\n\t\t}\n\n\t\t// TODO: validate email\n\n\t\tif !checkPasswordStrength(user.Password) {\n\t\t\tsetFlash(w, flashCookie, \"Password must be at least 8 characters long and contain at least one uppercase letter and one lowercase letter.\")\n\t\t\thttp.Redirect(w, r, \"/signup\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\ttx, err := dbAuth.BeginTx(ctx, nil)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar exists bool\n\t\terr = tx.QueryRowContext(ctx, \"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", user.Email).Scan(\u0026exists)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif exists {\n\t\t\terr = tx.QueryRowContext(ctx, \"SELECT verified FROM users WHERE email = ?\", user.Email).Scan(\u0026user.Verified)\n\t\t\tif err != nil {\n\t\t\t\ttx.Rollback()\n\t\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif user.Verified {\n\t\t\t\ttx.Rollback()\n\t\t\t\tsetFlash(w, flashCookie, \"Login! An account with the provided email address already exists.\")\n\t\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif !exists {\n\t\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\t\t\tif err != nil {\n\t\t\t\ttx.Rollback()\n\t\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = tx.ExecContext(ctx, \"INSERT INTO users (email, password) VALUES (?, ?)\", user.Email, string(hashedPassword))\n\t\t\tif err != nil {\n\t\t\t\ttx.Rollback()\n\t\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// TODO: insert into verification_tokens\n\t\t}\n\n\t\tif err = verifyUserEmail(w, user.Email, \"/confirm-account\"); err != nil {\n\t\t\ttx.Rollback()\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsignupRateLimitMax(r)\n\n\t\tsetFlash(w, flashCookie, \"An activation email has been sent to your provided email address.\")\n\t\thttp.Redirect(w, r, \"/signup\", http.StatusSeeOther)\n\t}\n}\n\nfunc logoutHandler(w http.ResponseWriter, r *http.Request) {\n\t// Clear the JWT cookie by setting an expired cookie with the same name\n\tsetCookie(w, \"jwt\", \"\", time.Now().Add(-time.Hour))\n\tsetFlash(w, flashCookie, \"Successfully logout\")\n\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n}\n\nfunc changePasswordHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/change-password.html\", nil)\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\temail := r.FormValue(\"email\")\n\n\t\tvar exists bool\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\terr := dbAuth.QueryRowContext(ctx, \"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", email).Scan(\u0026exists)\n\t\tif err != nil || !exists {\n\t\t\tsetFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tif err = verifyUserEmail(w, email, \"/reset-password\"); err != nil {\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsetFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t}\n}\n\nfunc resetPasswordHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\tdata := map[string]interface{}{\n\t\t\t\"Token\": r.URL.Query().Get(\"token\"),\n\t\t}\n\n\t\tif data[\"Token\"] == nil {\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t}\n\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/reset-password.html\", data)\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\ttoken := r.FormValue(\"token\")\n\t\tnewPassword := r.FormValue(\"password\")\n\t\ttokenFromCookie, err := getCookie(w, r, \"reset_token\")\n\t\tif err != nil {\n\t\t\tsetFlash(w, flashCookie, \"Invalid or expired token\")\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\temail, err := verifyTokens(token, tokenFromCookie.Value)\n\t\tif err != nil || email == \"\" {\n\t\t\tsetFlash(w, flashCookie, \"Invalid or expired token\")\n\t\t\thttp.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\t_, err = dbAuth.ExecContext(ctx, \"UPDATE users SET password = ? WHERE email = ?\", string(hashedPassword), email)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsetFlash(w, flashCookie, \"Password reset successful!\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t}\n}\n\nfunc getAllUsersHandler(w http.ResponseWriter, r *http.Request) {\n\tuser, ok := r.Context().Value(\"auth\").(User)\n\tif !ok || !user.IsAuth {\n\t\tsetFlash(w, flashCookie, \"Please login\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\treturn\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\trows, err := dbAuth.QueryContext(ctx, \"SELECT id, email, user_type FROM users\")\n\tif err != nil {\n\t\tlogToFileWithCaller(levelError, err.Error())\n\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\tif err := rows.Scan(\u0026user.Id, \u0026user.Email, \u0026user.UserType); err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"users\": users,\n\t}\n\n\trenderHTMLAuthFlashCSRF(w, r, \"pages/users.html\", data)\n}\n\nfunc deleteAccountHandler(w http.ResponseWriter, r *http.Request) {\n\tuser, ok := r.Context().Value(\"auth\").(User)\n\tif !ok || !user.IsAuth {\n\t\tsetFlash(w, flashCookie, \"Please login\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\treturn\n\t}\n\tif r.Method == http.MethodGet {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/delete-user.html\", nil)\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\temail := r.FormValue(\"email\")\n\t\tpassword := r.FormValue(\"password\")\n\t\temailFromContext := user.Email\n\n\t\tif email != emailFromContext {\n\t\t\tsetFlash(w, flashCookie, \"Invalid credentials\")\n\t\t\thttp.Redirect(w, r, \"/delete-account\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// check password with database password\n\t\tvar hashedPassword string\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\terr := dbAuth.QueryRowContext(ctx, \"SELECT password FROM users WHERE email = ?\", email).Scan(\u0026hashedPassword)\n\t\tif err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) != nil {\n\t\t\tsetFlash(w, flashCookie, \"Invalid credentials\")\n\t\t\thttp.Redirect(w, r, \"/delete-account\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\t_, err = dbAuth.ExecContext(ctx, \"DELETE FROM users WHERE email = ?\", email)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsetCookie(w, \"jwt\", \"\", time.Now().Add(-time.Hour))\n\t\tsetFlash(w, flashCookie, \"User deleted successfully\")\n\n\t\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n\t}\n}\n\nfunc confirmAccountHandler(w http.ResponseWriter, r *http.Request) {\n\ttokenFromUrl := r.URL.Query().Get(\"token\")\n\ttokenFromCookie, err := getCookie(w, r, tokenCookieValidate)\n\tif err != nil || tokenFromUrl == \"\" || tokenFromUrl != tokenFromCookie.Value {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/confirm-account.html\", nil)\n\t\treturn\n\t}\n\n\temail, err := verifyTokens(tokenFromUrl, tokenFromCookie.Value)\n\tif err != nil || email == \"\" {\n\t\tsetFlash(w, flashCookie, \"Invalid or expired token. Please sign up again to get a new email with a confirmation link.\")\n\t\thttp.Redirect(w, r, \"/signup\", http.StatusSeeOther)\n\t\treturn\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\t_, err = dbAuth.ExecContext(ctx, \"UPDATE users SET verified = ? WHERE email = ?\", true, email)\n\tif err != nil {\n\t\tlogToFileWithCaller(levelError, err.Error())\n\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trenderHTMLAuthFlashCSRF(w, r, \"pages/confirm-account.html\", nil)\n}\n\nfunc makeAdminHandler(w http.ResponseWriter, r *http.Request) {\n\tuser, ok := r.Context().Value(\"auth\").(User)\n\tif !ok || (!user.IsAuth \u0026\u0026 user.UserType == \"admin\") {\n\t\tsetFlash(w, flashCookie, \"Please login\")\n\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\treturn\n\t}\n\n\tif r.Method == http.MethodGet {\n\t\trenderHTMLAuthFlashCSRF(w, r, \"pages/make-admin.html\", nil)\n\t\treturn\n\t} else if r.Method == http.MethodPost {\n\t\temail := r.FormValue(\"email\")\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\t_, err := dbAuth.ExecContext(ctx, \"UPDATE users SET user_type = ? WHERE email = ?\", \"admin\", email)\n\t\tif err != nil {\n\t\t\tlogToFileWithCaller(levelError, err.Error())\n\t\t\thttp.Error(w, \"Please try later\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tsetFlash(w, flashCookie, fmt.Sprintf(\"User %s is now an admin\", email))\n\t\thttp.Redirect(w, r, \"/users\", http.StatusSeeOther)\n\t}\n}\n\n"
    ],
    "description": "",
    "prefix": "snippet boileprlate + auth system"
  },
  "snippet boilerplate": {
    "body": [
      "package main\n\nimport (\n\t\"bot/middlewares\"\n\t\"context\"\n\t_ \"embed\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/gorilla/websocket\"\n\t\"html/template\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n)\n\n//go:embed reload.html\nvar reloadHtmlFile []byte\n\n// app\nvar logger *log.Logger\nvar templs *template.Template\nvar pages = make(map[string]bool)\n\n// websocket\nvar upgrader = websocket.Upgrader{}\nvar connections = make(map[*websocket.Conn]bool)\nvar mu sync.Mutex\n\nfunc init() {\n\tsetupLog(false)\n\tparseTemplates()\n}\n\nfunc main() {\n\t// server\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/public/\", http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"public\"))))\n\tmux.HandleFunc(\"/favicon.ico\", func(w http.ResponseWriter, r *http.Request) { // avoid duplicate request\n\t\thttp.ServeFile(w, r, \"public/favicon.ico\")\n\t})\n\n\tmux.HandleFunc(\"/\", home)\n\tmux.HandleFunc(\"/blog/\", dynamic)\n\n\treloadByWebSocket(mux)\n\n\tserver := \u0026http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        middlewares.Recover(mux),\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   15 * time.Second,\n\t\tIdleTimeout:    60 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20, // 1MB\n\t}\n\n\tgo func() {\n\t\tlog.Println(\"Starting server on :8080\")\n\t\tif err := server.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t}\n\t}()\n\n\tgracefulShutdown(server)\n}\n\nfunc gracefulShutdown(server *http.Server) {\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, os.Interrupt, syscall.SIGTERM)\n\n\t\u003c-stop\n\tlog.Println(\"Shutting down server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tif err := server.Shutdown(ctx); err != nil {\n\t\tlog.Fatalf(\"Forced shutdown: %v\", err)\n\t}\n\tlog.Println(\"Server gracefully stopped.\")\n}\n\nfunc watchDirectory(directory string) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Close()\n\n\terr = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.IsDir() {\n\t\t\tif err := watcher.Add(path); err != nil {\n\t\t\t\tlog.Printf(\"Error watching directory: %s, %v\", path, err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Watching:\", path)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\teventCache := make(map[string]time.Time)\n\n\tfor {\n\t\tselect {\n\t\tcase event, ok := \u003c-watcher.Events:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif event.Op\u0026(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 \u0026\u0026 strings.HasSuffix(event.Name, \".html\") {\n\t\t\t\tnow := time.Now()\n\t\t\t\tif lastEventTime, exists := eventCache[\"reload\"]; exists \u0026\u0026 now.Sub(lastEventTime) \u003c 100*time.Millisecond {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\teventCache[\"reload\"] = now\n\t\t\t\tif err := parseTemplates(); err != nil {\n\t\t\t\t\tlog.Println(\"Failed to reload templates:\", err)\n\t\t\t\t}\n\t\t\t\tnotifyClients()\n\t\t\t}\n\t\t\tif event.Op\u0026fsnotify.Create == fsnotify.Create {\n\t\t\t\tfileInfo, err := os.Stat(event.Name)\n\t\t\t\tif err == nil \u0026\u0026 fileInfo.IsDir() {\n\t\t\t\t\twatcher.Add(event.Name)\n\t\t\t\t\tfmt.Println(\"Added new directory to watch:\", event.Name)\n\t\t\t\t}\n\t\t\t}\n\t\tcase err, ok := \u003c-watcher.Errors:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Println(\"Error watching files:\", err)\n\t\t}\n\t}\n}\n\nfunc reloadByWebSocket(mux *http.ServeMux) {\n\tgo watchDirectory(\"html\")\n\n\tmux.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader.CheckOrigin = func(r *http.Request) bool { return true }\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(\"WebSocket upgrade error:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tmu.Lock()\n\t\tconnections[conn] = true\n\t\tmu.Unlock()\n\n\t\tfmt.Println(\"New WebSocket connection\")\n\t})\n\n\tmux.HandleFunc(\"/reload\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tw.Write(reloadHtmlFile)\n\t})\n}\n\nfunc notifyClients() {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tfor conn := range connections {\n\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(\"reload\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Deleting connection:\", err)\n\t\t\tconn.Close()\n\t\t\tdelete(connections, conn)\n\t\t}\n\t}\n}\n\nfunc parseTemplates() error {\n\ttempls = template.New(\"\")\n\n\terr := filepath.WalkDir(\"html\", func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Ext(path) == \".html\" {\n\t\t\trelPath, err := filepath.Rel(\"html\", path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trelPath = filepath.ToSlash(relPath) // Ensure cross-platform compatibility\n\t\t\tif strings.HasPrefix(relPath, \"pages/\") {\n\t\t\t\tpages[relPath] = true\n\t\t\t}\n\t\t\tcontent, err := os.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = templs.New(relPath).Parse(string(content))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Println(\"Templates reloaded successfully.\")\n\treturn nil\n}\n\n// setupLog creates and returns a new *log.Logger instance and a cleanup function.\n// Logs are written to both app.log and stdout unless production is true.\nfunc setupLog(production bool) (cleanup func(), err error) {\n\tvar logFile *os.File\n\tlogFile, err = os.OpenFile(\"bot.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcleanup = func() {\n\t\tif cerr := logFile.Close(); cerr != nil {\n\t\t\tlog.Printf(\"Error closing log file: %v\", cerr)\n\t\t}\n\t}\n\n\tvar writer io.Writer\n\tif production {\n\t\twriter = logFile\n\t} else {\n\t\twriter = io.MultiWriter(os.Stdout, logFile)\n\t}\n\n\tlogger = log.New(writer, \"\", log.Ldate|log.Ltime|log.Lshortfile) // adds timestamp + file:line\n\treturn\n}\n\nfunc renderHTML(w http.ResponseWriter, page string, data map[string]interface{}) {\n\terr := templs.ExecuteTemplate(w, page, data)\n\tif err != nil {\n\t\tlog.Printf(\"Error executing template: %v\", err)\n\t\thttp.Error(w, \"Please try letter\", http.StatusInternalServerError)\n\t}\n}\n\nfunc dynamic(w http.ResponseWriter, r *http.Request) {\n\tpath := strings.TrimPrefix(r.URL.Path, \"/\")\n\tpath = filepath.ToSlash(path) // Ensure cross-platform compatibility\n\ttemplateFile := fmt.Sprintf(\"pages/%s.html\", path)\n\n\tif ok := pages[templateFile]; !ok {\n\t\tif strings.HasSuffix(path, \"/\") {\n\t\t\tpath += \"index\" // route is like /blog/tennis/\n\t\t} else {\n\t\t\tpath += \"/index\" // route is like /blog/tennis\n\t\t}\n\t\ttemplateFile = fmt.Sprintf(\"pages/%s.html\", path)\n\t}\n\n\trenderHTML(w, templateFile, nil)\n}\n\nfunc home(w http.ResponseWriter, r *http.Request) {\n\trenderHTML(w, \"pages/index.html\", nil)\n}\n"
    ],
    "description": "",
    "prefix": "snippet boilerplate"
  },
  "snippet boilerplate app": {
    "body": [
      "package main\n\nimport (\n\t\"database/sql\"\n\t_ \"embed\"\n\t\"flag\"\n\t\"fmt\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar remoteAuth RemoteAuth\nvar app App\n\ntype RemoteAuth struct {\n\tUsername  string\n\tPassword  string\n\tSession   string\n\tXSRFToken string\n}\n\ntype App struct {\n\tIsProduction     bool\n\tReloadFromServer bool\n\tCodestitchURL    string\n}\n\ntype Database struct {\n\tDB     *sql.DB\n\tDBName string\n}\n\ntype User struct {\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc init() {\n\tlog.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)\n\n\tremoteAuth.Username = os.Getenv(\"codestitchUsername\")\n\tif remoteAuth.Username == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichUsername is not set\")\n\t}\n\n\tremoteAuth.Password = os.Getenv(\"codestitchPassword\")\n\tif remoteAuth.Password == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichPassword is not set\")\n\t}\n\n\t// Retrieve session and XSRF tokens from environment variables\n\tremoteAuth.Session = os.Getenv(\"codestitch_session\")\n\tif remoteAuth.Session == \"\" {\n\t\tlog.Fatal(\"Environment variable codestitch_session is not set\")\n\t}\n\n\tremoteAuth.XSRFToken = os.Getenv(\"XSRF_TOKEN\")\n\tif remoteAuth.XSRFToken == \"\" {\n\t\tlog.Fatal(\"Environment variable XSRF_TOKEN is not set\")\n\t}\n\n\tapp.CodestitchURL = \"https://codestitch.app/app/dashboard/catalog/sections/3?perPage=180\u0026page=1\"\n\n\tflag.BoolVar(\u0026app.IsProduction, \"isProduction\", false, \"set production mode: -isProduction=true\")\n\tflag.BoolVar(\u0026app.ReloadFromServer, \"reloadFromServer\", false, \"set reloadFromServer mode: -reloadFromServer=true\")\n\tflag.Parse()\n}\n\nfunc (d *Database) Init() {\n\tvar err error\n\td.DB, err = sql.Open(\"sqlite3\", \"file:\"+d.DBName+\"?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to open database: \", err)\n\t}\n\n\t_, err = d.DB.Exec(`\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT UNIQUE NOT NULL,\n            password TEXT NOT NULL\n        );\n    `)\n\tif err != nil {\n\t\td.DB.Close()\n\t\tlog.Fatalln(\"Failed to create table: \", err)\n\t}\n\n\td.DB.SetMaxOpenConns(25)\n\td.DB.SetMaxIdleConns(25)\n\td.DB.SetConnMaxIdleTime(5 * time.Minute)\n\td.DB.SetConnMaxLifetime(2 * time.Hour)\n}\n\n// Close the database connection\nfunc (d *Database) Close() {\n\tif err := d.DB.Close(); err != nil {\n\t\tlog.Printf(\"Failed to close database: %v\", err)\n\t} else {\n\t\tfmt.Println(\"Closing database without errors\")\n\t}\n}\n\nfunc main() {\n\tdb := Database{DBName: \"codestitch.db\"}\n\tdb.Init()\n\tdefer db.Close()\n\t\n\t// write logic\n}\n\n// getHTMLPage returns the HTML content of a given URL\nfunc getHTMLPage(href string) []byte {\n\treq, err := http.NewRequest(\"GET\", href, nil)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\t// Manually set the Cookie header using the values retrieved from your browser.\n\t// Depending on the site's requirements, you might need to include additional cookies.\n\tcookieHeader := fmt.Sprintf(\"codestitch_session=%s; XSRF-TOKEN=%s\", remoteAuth.Session, remoteAuth.XSRFToken)\n\treq.Header.Set(\"Cookie\", cookieHeader)\n\n\t// Set a typical browser User-Agent header.\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124\")\n\n\t// Optionally, add Referer and Origin headers if needed.\n\treq.Header.Set(\"Referer\", \"https://codestitch.app/login\")\n\treq.Header.Set(\"Origin\", \"https://codestitch.app\")\n\n\tclient := \u0026http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tlog.Fatalln(\"HTTP request failed with status code\", resp.StatusCode)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn body\n}\n\n"
    ],
    "description": "",
    "prefix": "snippet boilerplate app"
  },
  "snippet boilerplate app gorm": {
    "body": [
      "package main\n\nimport (\n\t\"bytes\"\n\t_ \"embed\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/PuerkitoBio/goquery\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"gorm.io/driver/sqlite\"\n\t\"gorm.io/gorm\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar remoteAuth RemoteAuth\nvar app App\n\ntype RemoteAuth struct {\n\tUsername  string\n\tPassword  string\n\tSession   string\n\tXSRFToken string\n}\n\ntype App struct {\n\tIsProduction     bool\n\tReloadFromServer bool\n\tCodestitchURL    string\n}\n\ntype Page struct {\n\tID       uint `gorm:\"primaryKey\"`\n\tName     string\n\tURL      string\n\tPageHTML string\n}\n\ntype Component struct {\n\tID       uint `gorm:\"primaryKey\"`\n\tName     string\n\tURL      string\n\tPageHTML string\n\tCSS      string\n\tJS       string\n\tHTML     string\n\tGoCode   string\n}\n\ntype Category struct {\n\tID    uint `gorm:\"primaryKey\"`\n\tName  string\n\tPages []Page `gorm:\"many2many:category_pages;\"`\n}\n\ntype CodeStitches struct {\n\tCategories []Category\n\tComponents []Component\n}\n\ntype Database struct {\n\tDB     *gorm.DB\n\tDBName string\n}\n\nfunc init() {\n\tlog.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)\n\n\tremoteAuth.Username = os.Getenv(\"codestitchUsername\")\n\tif remoteAuth.Username == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichUsername is not set\")\n\t}\n\n\tremoteAuth.Password = os.Getenv(\"codestitchPassword\")\n\tif remoteAuth.Password == \"\" {\n\t\tlog.Fatal(\"Environment variable codestichPassword is not set\")\n\t}\n\n\t// Retrieve session and XSRF tokens from environment variables\n\tremoteAuth.Session = os.Getenv(\"codestitch_session\")\n\tif remoteAuth.Session == \"\" {\n\t\tlog.Fatal(\"Environment variable codestitch_session is not set\")\n\t}\n\n\tremoteAuth.XSRFToken = os.Getenv(\"XSRF_TOKEN\")\n\tif remoteAuth.XSRFToken == \"\" {\n\t\tlog.Fatal(\"Environment variable XSRF_TOKEN is not set\")\n\t}\n\n\tapp.CodestitchURL = \"https://codestitch.app/app/dashboard/catalog/sections/3?perPage=180\u0026page=1\"\n\n\tflag.BoolVar(\u0026app.IsProduction, \"isProduction\", false, \"set production mode: -isProduction=true\")\n\tflag.BoolVar(\u0026app.ReloadFromServer, \"reloadFromServer\", false, \"set reloadFromServer mode: -reloadFromServer=true\")\n\tflag.Parse()\n}\n\nfunc (d *Database) Connect() {\n\tvar err error\n\td.DB, err = gorm.Open(sqlite.Open(\"file:\"+d.DBName+\"?_cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\"), \u0026gorm.Config{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n\t}\n\n\t// Get underlying *sql.DB for further configuration\n\tsqlDB, err := d.DB.DB()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get SQL DB instance: %v\", err)\n\t}\n\n\t// Set database connection pooling options\n\tsqlDB.SetMaxOpenConns(10)           // Max 10 open connections\n\tsqlDB.SetMaxIdleConns(5)            // Max 5 idle connections\n\tsqlDB.SetConnMaxLifetime(time.Hour) // Recycle connections every hour\n\n\tfmt.Println(\"Connected to SQLite database:\", d.DBName)\n}\n\nfunc (d *Database) Close() {\n\tsqlDB, err := d.DB.DB()\n\tif err != nil {\n\t\tlog.Printf(\"Error getting SQL DB instance for closing: %v\", err)\n\t\treturn\n\t}\n\tsqlDB.Close()\n\tfmt.Println(\"Database connection closed.\")\n}\n\nfunc (d *Database) ExtractLinksFromHTML(htmlFile []byte) {\n\t/*\n\n\t\t\u003cul id=\"stitch-list\"\u003e\n\t\t    \u003cli class=\"dropdown\"\u003e\n\t\t        \u003cspan class=\"category category_toggle\"\u003eE-Commerce\u003c/span\u003e\n\t\t        \u003cul class=\"child_list\"\u003e\n\t\t            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/100\"\u003eAll \u003cspan class=\"cat-options\"\u003e(23)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/232\"\u003eCollections \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t        \u003c/ul\u003e\n\t\t    \u003c/li\u003e\n\t\t    \u003cli class=\"dropdown\"\u003e\n\t\t        \u003cspan class=\"category category_toggle\"\u003eButtons\u003c/span\u003e\n\t\t        \u003cul class=\"child_list\"\u003e\n\t\t            \u003cli\u003e\u003ca href=\"https://codestitch.app/app/dashboard/catalog/sections/22\"\u003eAll \u003cspan class=\"cat-options\"\u003e(11)\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\t\t        \u003c/ul\u003e\n\t\t    \u003c/li\u003e\n\t\t\u003c/ul\u003e\n\n\t*/\n\n\tdoc, err := goquery.NewDocumentFromReader(bytes.NewReader(htmlFile))\n\tif err != nil {\n\t\tlog.Fatalln(\"Error loading HTML:\", err)\n\t}\n\n\tdoc.Find(\"li.dropdown\").Each(func(i int, s *goquery.Selection) {\n\t\tname := s.Find(\"span.category_toggle\").Text()\n\t\tfmt.Println(\"Element:\", name)\n\n\t\t// Find sub-items\n\t\ts.Find(\"ul.child_list a\").Each(func(j int, a *goquery.Selection) {\n\t\t\thref, exists := a.Attr(\"href\")\n\t\t\tif exists {\n\t\t\t\tvalue := a.Find(\"span.cat-options\").Contents().Nodes[0].Data\n\t\t\t\tfmt.Printf(\"  - Link: %s | Value: %s\\n\", href, value)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc main() {\n\tdb := \u0026Database{DBName: \"codestitch.db\"}\n\tdb.Connect()\n\tdefer db.Close()\n\t\n\t// write logic\n\thtmlFile := getHTMLPage(app.CodestitchURL)\n}\n\n// getHTMLPage returns the HTML content of a given URL\nfunc getHTMLPage(href string) []byte {\n\treq, err := http.NewRequest(\"GET\", href, nil)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\t// Manually set the Cookie header using the values retrieved from your browser.\n\t// Depending on the site's requirements, you might need to include additional cookies.\n\tcookieHeader := fmt.Sprintf(\"codestitch_session=%s; XSRF-TOKEN=%s\", remoteAuth.Session, remoteAuth.XSRFToken)\n\treq.Header.Set(\"Cookie\", cookieHeader)\n\n\t// Set a typical browser User-Agent header.\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124\")\n\n\t// Optionally, add Referer and Origin headers if needed.\n\treq.Header.Set(\"Referer\", \"https://codestitch.app/login\")\n\treq.Header.Set(\"Origin\", \"https://codestitch.app\")\n\n\tclient := \u0026http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tlog.Fatalln(\"HTTP request failed with status code\", resp.StatusCode)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn body\n}\n\n"
    ],
    "description": "",
    "prefix": "snippet boilerplate app gorm"
  },
  "snippet email send": {
    "body": [
      "func emailSendLink(email, link string) error {\n\t// Create a new email - specify the SMTP host:port and auth (if needed)\n\tmail := mailyak.New(\"smtp.mail.me.com:587\", smtp.PlainAuth(\"\", smtpUser, smtpPass, \"smtp.mail.me.com\"))\n\n\tmail.To(email)\n\tmail.From(smtpUser)\n\tmail.FromName(\"Localhost\")\n\n\tmail.Subject(\"Password Reset\")\n\n\t// Or set the body using a string setter\n\tmail.Plain().Set(\"Click the link to reset your password: \" + link)\n\n\t// And you're done!\n\tif err := mail.Send(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// verifyUserEmail sends a verification email: verifyUserEmail(w, user, \"/urlPath\")\nfunc verifyUserEmail(w http.ResponseWriter, email, token, urlPath string) (err error) {\n\tresetLink := fmt.Sprintf(domain+urlPath+\"?token=%s\", token)\n\tif isProduction {\n\t\tgo func() {\n\t\t\terr = emailSendLink(email, resetLink)\n\t\t\tif err != nil {\n\t\t\t\tsetCookie(w, tokenCookieValidate, \"\", time.Now().Add(-time.Hour))\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tlogToFileWithCaller(levelInfo, resetLink)\n\t}\n\treturn err\n}\n"
    ],
    "description": "",
    "prefix": "snippet email send"
  },
  "snippet email verify": {
    "body": [
      "// verifyUserEmail sends a verification email: verifyUserEmail(w, user, \"/urlPath\")\nfunc verifyUserEmail(w http.ResponseWriter, email, urlPath string) error {\n\tresetToken, err := encryptToken(email, []byte(config.Config.SecretKey))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Send a password reset email\n\tresetLink := fmt.Sprintf(config.Config.Domain+urlPath+\"?token=%s\", resetToken)\n\tcookies.Set(w, \"tokenValidate\", resetToken, time.Now().Add(1*time.Hour)) // TODO: insert to verification_tokens\n\n\tif config.Config.IsProd {\n\t\tgo func() {\n\t\t\tif err = emailSendLink(email, resetLink); err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tcookies.Delete(w, \"tokenValidate\")\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tfmt.Println(resetLink)\n\t}\n\treturn err\n}\n\nfunc encryptToken(email string, secretKey []byte) (string, error) {\n\tplaintext := []byte(email + \"|\" + time.Now().Add(1*time.Hour).Format(time.RFC3339))\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonce := make([]byte, aesGCM.NonceSize())\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)\n\treturn base64.URLEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc decryptToken(token string, secretKey []byte) (string, error) {\n\tciphertext, err := base64.URLEncoding.DecodeString(token)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taesGCM, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnonceSize := aesGCM.NonceSize()\n\tif len(ciphertext) \u003c nonceSize {\n\t\treturn \"\", fmt.Errorf(\"ciphertext too short\")\n\t}\n\n\tnonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n\tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparts := strings.SplitN(string(plaintext), \"|\", 2)\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid token format\")\n\t}\n\n\texpiry, err := time.Parse(time.RFC3339, parts[1])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif time.Now().After(expiry) {\n\t\treturn \"\", fmt.Errorf(\"token has expired\")\n\t}\n\n\treturn parts[0], nil\n}\n\nfunc verifyTokens(token1, token2 string) (string, error) {\n\temail1, err := decryptToken(token1, []byte(config.Config.SecretKey))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\temail2, err := decryptToken(token2, []byte(config.Config.SecretKey))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif email1 != email2 {\n\t\treturn \"\", errors.New(\"tokens don't match\")\n\t}\n\treturn email1, nil\n}\n"
    ],
    "description": "",
    "prefix": "snippet email verify"
  },
  "snippet random key generator": {
    "body": [
      "func generateKey() []byte {\n\trandomBytes := make([]byte, 32) // 32 bytes, 256 bit\n\tnumBytesRead, err := rand.Read(randomBytes)\n\tif err != nil {\n\t\tlog.Fatal(\"Error generating random key.\", err)\n\t}\n\tif numBytesRead != 32 {\n\t\tlog.Fatal(\"Error generating 32 random bytes for key.\")\n\t}\n\treturn randomBytes\n}\n"
    ],
    "description": "",
    "prefix": "snippet random key generator"
  },
  "snippet random number generator": {
    "body": [
      "seed := time.Now().UnixNano()\nr := rand.New(rand.NewSource(seed))\nrandomNumber := r.Intn(100)\n"
    ],
    "description": "",
    "prefix": "snippet random number generator"
  },
  "snippet sentiment analysis": {
    "body": [
      "\"github.com/cdipaolo/sentiment\"\n\nmodel, err := sentiment.Restore()\nif err != nil {\n    panic(err)\n}\n\nvar analysis *sentiment.Analysis\nvar text string\n\n// Negative Example\ntext = \"Your mother is an awful lady\"\nanalysis = model.SentimentAnalysis(text, sentiment.English)\nif analysis.Score == 1 {\n    log.Printf(\"%s - Score of %d = Positive Sentiment\\n\", text, analysis.Score)\n} else {\n    log.Printf(\"%s - Score of %d = Negative Sentiment\\n\", text, analysis.Score)\n}\n\n// Positive Example\ntext = \"Your mother is a lovely lady\"\nanalysis = model.SentimentAnalysis(text, sentiment.English)\nif analysis.Score == 1 {\n    log.Printf(\"%s - Score of %d = Positive Sentiment\\n\", text, analysis.Score)\n} else {\n    log.Printf(\"%s - Score of %d = Negative Sentiment\\n\", text, analysis.Score)\n}\n"
    ],
    "description": "",
    "prefix": "snippet sentiment analysis"
  },
  "snippet turnstile": {
    "body": [
      "package security\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"pocketplate/app/filelog\"\n\t\"time\"\n)\n\nconst (\n\tapi_endpoint    = \"https://challenges.cloudflare.com/turnstile/v0/siteverify\"\n\tdefault_timeout = 15\n)\n\ntype turnstile struct {\n\tSecretKey string\n\tTimeout   time.Duration\n}\n\ntype response struct {\n\tSuccess     bool      `json:\"success\"`\n\tErrorCodes  []string  `json:\"error-codes\"`\n\tChallengeTs time.Time `json:\"challenge_ts\"`\n\tHostname    string    `json:\"hostname\"`\n}\n\nfunc (r *response) IsSuccess() bool {\n\treturn r.Success\n}\n\nfunc (r *response) HasErrors() bool {\n\treturn len(r.ErrorCodes) \u003e 0\n}\n\nfunc newTurnstile(secretKey string, timeout int) *turnstile {\n\treturn \u0026turnstile{\n\t\tSecretKey: secretKey,\n\t\tTimeout:   time.Duration(timeout) * time.Second,\n\t}\n}\n\nfunc (t *turnstile) verify(responseToken string, remoteIP string) (*response, error) {\n\tdata := url.Values{\n\t\t\"secret\":   {t.SecretKey},\n\t\t\"response\": {responseToken},\n\t}\n\tif remoteIP != \"\" {\n\t\tdata.Add(\"remoteip\", remoteIP)\n\t}\n\n\trequest, err := http.PostForm(api_endpoint, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer request.Body.Close()\n\n\tresponse := \u0026response{}\n\tif err := json.NewDecoder(request.Body).Decode(response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\nfunc ValidateTurnstile(w http.ResponseWriter, r *http.Request) (ok bool) {\n\t// TODO: move secret key to avoid leaks\n\tvalidator := newTurnstile(\"0x4AAAAAAAS-lrqDH1USP4oraJ_rHkgg46c\", default_timeout)\n\n\t// Get the CAPTCHA token from the 'cf-turnstile-response' form value\n\tcaptchaToken := r.FormValue(\"cf-turnstile-response\")\n\n\t// Get the user's IP address\n\tuserIP := getRealIP(r)\n\n\t// Captcha token received from form value cf-turnstile-response\n\t// Remote IP isn't required, if you wouldn't pass IP then insert \"\"\n\tresponse, err := validator.verify(captchaToken, userIP)\n\tif err != nil {\n\t\tfilelog.Log.Error(err)\n\t\treturn false\n\t}\n\n\tif response.HasErrors() {\n\t\tvar errorCodes string\n\t\tfor _, v := range response.ErrorCodes {\n\t\t\terrorCodes += v + \" \"\n\t\t}\n\t\tfilelog.Log.Error(fmt.Errorf(\"errorCodes: %s\", errorCodes))\n\t}\n\n\tif !response.IsSuccess() {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// getRealIP retrieves the real IP address from the request.\nfunc getRealIP(r *http.Request) string {\n\t// Check for headers that might contain the real IP address\n\tip := r.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = r.Header.Get(\"X-Real-IP\")\n\t}\n\tif ip == \"\" {\n\t\tip = r.RemoteAddr\n\t}\n\treturn ip\n}\n"
    ],
    "description": "",
    "prefix": "snippet turnstile"
  },
  "snippet turnstile verify": {
    "body": [
      "if ok := captcha.ValidateTurnstile(w, r); !ok {\n    http.Error(w, \"CAPTCHA failed. Try again.\", http.StatusForbidden)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "snippet turnstile verify"
  },
  "snippet validate password": {
    "body": [
      "func checkPasswordStrength(password string) bool {\n\tif !isProduction {\n\t\treturn true\n\t}\n\tif len(password) \u003c 12 {\n\t\treturn false\n\t}\n\tvar hasUpper, hasLower, hasNumber, hasSpecial bool\n\tfor _, r := range password {\n\t\tswitch {\n\t\tcase unicode.IsUpper(r):\n\t\t\thasUpper = true\n\t\tcase unicode.IsLower(r):\n\t\t\thasLower = true\n\t\tcase unicode.IsNumber(r):\n\t\t\thasNumber = true\n\t\tcase unicode.IsPunct(r) || unicode.IsSymbol(r):\n\t\t\thasSpecial = true\n\t\t}\n\t}\n\treturn hasUpper \u0026\u0026 hasLower \u0026\u0026 hasNumber \u0026\u0026 hasSpecial\n}\n"
    ],
    "description": "",
    "prefix": "snippet validate password"
  },
  "snippet word count": {
    "body": [
      "// WordCount function counts the number of occurrences of each word in the given string.\nfunc WordCount(s string) map[string]int {\n    // Create a map to store the count of each word.\n    wordCount := make(map[string]int)\n\n    // Split the string into words. We consider a word to be a sequence of letters and digits.\n    fields := strings.FieldsFunc(s, func(c rune) bool {\n        return !unicode.IsLetter(c) \u0026\u0026 !unicode.IsDigit(c)\n    })\n\n    // Increment the count for each word in the map.\n    for _, word := range fields {\n        wordCount[word]++\n    }\n\n    // Return the map with word counts.\n    return wordCount\n}\n"
    ],
    "description": "",
    "prefix": "snippet word count"
  },
  "snippets server local and production": {
    "body": [
      "\"golang.org/x/crypto/acme/autocert\"\n\nctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)\ndefer stop()\n\nif *isProd {\n    slog.Info(\"Starting server with HTTPS\", \"domain\", *domain)\n    certManager := \u0026autocert.Manager{\n        Prompt:     autocert.AcceptTOS,\n        HostPolicy: autocert.HostWhitelist(*domain),\n        Cache:      autocert.DirCache(\"certs\"),\n    }\n\n    go func() {\n        httpChallengeServer := \u0026http.Server{\n            Addr:         \":80\",\n            Handler:      certManager.HTTPHandler(nil),\n            ReadTimeout:  5 * time.Second,\n            WriteTimeout: 5 * time.Second,\n            IdleTimeout:  120 * time.Second,\n        }\n        slog.Info(\"Starting HTTP challenge server on :80\")\n        if err := httpChallengeServer.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n            slog.Error(\"HTTP challenge server ListenAndServe error\", \"error\", err)\n        }\n    }()\n\n    httpsServer := \u0026http.Server{\n        Addr:         \":443\",\n        Handler:      finalHandler,\n        TLSConfig:    certManager.TLSConfig(),\n        ReadTimeout:  5 * time.Second,\n        WriteTimeout: 10 * time.Second,\n        IdleTimeout:  120 * time.Second,\n    }\n\n    go func() {\n        slog.Info(\"Starting HTTPS server on :443\")\n        if err := httpsServer.ListenAndServeTLS(\"\", \"\"); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n            slog.Error(\"HTTPS server ListenAndServeTLS error\", \"error\", err)\n            os.Exit(1)\n        }\n    }()\n\n    \u003c-ctx.Done()\n    stop()\n\n    slog.Info(\"Shutdown signal received. Shutting down HTTPS server...\")\n    shutdownCtx, cancelShutdown := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancelShutdown()\n\n    if err := httpsServer.Shutdown(shutdownCtx); err != nil {\n        slog.Error(\"HTTPS server shutdown failed\", \"error\", err)\n    }\n    slog.Info(\"HTTPS server gracefully stopped.\")\n\n} else {\n    slog.Info(\"Starting server on HTTP\", \"address\", \"http://127.0.0.1:8080\")\n    httpServer := \u0026http.Server{\n        Addr:         \":8080\",\n        Handler:      finalHandler,\n        ReadTimeout:  5 * time.Second,\n        WriteTimeout: 10 * time.Second,\n        IdleTimeout:  120 * time.Second,\n    }\n\n    go func() {\n        if err := httpServer.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n            slog.Error(\"HTTP server ListenAndServe error\", \"error\", err)\n            os.Exit(1)\n        }\n    }()\n\n    \u003c-ctx.Done()\n    stop()\n\n    slog.Info(\"Shutdown signal received. Shutting down HTTP server...\")\n    shutdownCtx, cancelShutdown := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancelShutdown()\n\n    if err := httpServer.Shutdown(shutdownCtx); err != nil {\n        slog.Error(\"HTTP server shutdown failed\", \"error\", err)\n    }\n    slog.Info(\"HTTP server gracefully stopped.\")\n}\nslog.Info(\"Application exiting.\")\n"
    ],
    "description": "",
    "prefix": "snippets server local and production"
  },
  "sqlite auth": {
    "body": [
      "_ \"github.com/mattn/go-sqlite3\"\n\nvar dbAuth *sql.DB\n\ntype User struct {\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc initAuthDB() {\n\tvar err error\n\tdbAuth, err = sql.Open(\"sqlite3\", \"file:auth.db?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\n\t_, err = dbAuth.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\temail TEXT UNIQUE NOT NULL,\n\t\t\tpassword TEXT NOT NULL\n\t\t);\n\t`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t\n\tdbAuth.SetMaxOpenConns(25)\n\tdbAuth.SetMaxIdleConns(25)\n\tdbAuth.SetConnMaxIdleTime(5 * time.Minute)\n\tdbAuth.SetConnMaxLifetime(2 * time.Hour)\n}\n\nfunc closeAuthDB() {\n\terr := dbAuth.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Closing database without errors\")\n}\n\ninitAuthDB()\ndefer closeAuthDB()\n"
    ],
    "description": "",
    "prefix": "sqlite auth"
  },
  "sqlite auth compare two password with bcrypt": {
    "body": [
      "// check password with database password\nvar hashedPassword string\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\nerr := dbAuth.QueryRowContext(ctx, \"SELECT password FROM users WHERE email = ?\", email).Scan(\u0026hashedPassword)\nif err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) != nil {\n    setFlash(w, flashCookie, \"Invalid credentials\")\n    http.Redirect(w, r, \"/delete-account\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth compare two password with bcrypt"
  },
  "sqlite auth delete": {
    "body": [
      "ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n_, err = dbAuth.ExecContext(ctx, \"DELETE FROM users WHERE email = ?\", email)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth delete"
  },
  "sqlite auth exec (INSERT)": {
    "body": [
      "_, err = dbAuth.Exec(\"INSERT INTO users (email, password) VALUES (?, ?)\", user.Email, string(hashedPassword))\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth exec (INSERT)"
  },
  "sqlite auth exec (UPDATE)": {
    "body": [
      "_, err = dbAuth.Exec(\"UPDATE users SET password = ? WHERE email = ?\", string(hashedPassword), email)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth exec (UPDATE)"
  },
  "sqlite auth exec (VERIFY)": {
    "body": [
      "email := r.FormValue(\"email\")\nvar exists bool\nerr := dbAuth.QueryRow(\"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", email).Scan(\u0026exists)\nif err != nil || !exists {\n    setFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n    http.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth exec (VERIFY)"
  },
  "sqlite auth exec (create table)": {
    "body": [
      "_, err = dbAuth.Exec(`\n    CREATE TABLE IF NOT EXISTS users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        email TEXT UNIQUE NOT NULL,\n        password TEXT NOT NULL\n    );\n`)\n"
    ],
    "description": "",
    "prefix": "sqlite auth exec (create table)"
  },
  "sqlite auth init": {
    "body": [
      "func initAuthDB() {\n\tvar err error\n\tdbAuth, err = sql.Open(\"sqlite3\", \"file:auth.db?cache=shared\u0026mode=rwc\u0026_journal_mode=WAL\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\n\t// Configure connection pool\n\tdbAuth.SetMaxOpenConns(25)\n\tdbAuth.SetMaxIdleConns(25)\n\tdbAuth.SetConnMaxLifetime(5 * time.Minute)\n\n\t// TODO: add verify_tokens table to verify email\n\t_, err = dbAuth.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\temail TEXT UNIQUE NOT NULL,\n\t\t\tpassword TEXT NOT NULL,\n\t\t\tuser_type TEXT NOT NULL DEFAULT 'user', -- Can be 'admin', 'user', etc\n\t\t\tverified BOOLEAN NOT NULL DEFAULT 0,\n\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\t\t\tupdated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t);\n\t`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc closeAuthDB() {\n\terr := dbAuth.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Closing database without errors\")\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth init"
  },
  "sqlite auth insert": {
    "body": [
      "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n_, err = dbAuth.ExecContext(ctx, \"INSERT INTO users (email, password) VALUES (?, ?)\", user.Email, string(hashedPassword))\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth insert"
  },
  "sqlite auth query row (example get row by email)": {
    "body": [
      "var hashedPassword string\nerr := dbAuth.QueryRow(\"SELECT password FROM users WHERE email = ?\", user.Email).Scan(\u0026hashedPassword)\nif err != nil || bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password)) != nil {\n    setFlash(w, flashCookie, \"Invalid credentials\")\n    http.Redirect(w, r, \"/login\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth query row (example get row by email)"
  },
  "sqlite auth select (select password and bcrypt compare)": {
    "body": [
      "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\nerr := dbAuth.QueryRowContext(ctx, \"SELECT password, user_type, verified FROM users WHERE email = ?\", user.Email).\n    Scan(\u0026dbUser.Password, \u0026dbUser.UserType, \u0026dbUser.Verified)\nif err != nil || bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(user.Password)) != nil {\n    setFlash(w, flashCookie, \"Invalid credentials\")\n    http.Redirect(w, r, \"/login\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth select (select password and bcrypt compare)"
  },
  "sqlite auth select all": {
    "body": [
      "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\nrows, err := dbAuth.QueryContext(ctx, \"SELECT id, email FROM users\")\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\ndefer rows.Close()\n\nvar users []User\nfor rows.Next() {\n    var user User\n    if err := rows.Scan(\u0026user.Id, \u0026user.Email); err != nil {\n        logToFileWithCaller(levelError, err.Error())\n        continue\n    }\n    users = append(users, user)\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth select all"
  },
  "sqlite auth select check if exist": {
    "body": [
      "var exists bool\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\nerr := dbAuth.QueryRowContext(ctx, \"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", email).Scan(\u0026exists)\nif err != nil || !exists {\n    setFlash(w, flashCookie, \"If the email exists, instructions to reset the password have been sent.\")\n    http.Redirect(w, r, \"/change-password\", http.StatusSeeOther)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth select check if exist"
  },
  "sqlite auth transaction": {
    "body": [
      "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\ntx, err := dbAuth.BeginTx(ctx, nil)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n\nvar exists bool\nerr = tx.QueryRowContext(ctx, \"SELECT COUNT(*) \u003e 0 FROM users WHERE email = ?\", user.Email).Scan(\u0026exists)\nif err != nil {\n    tx.Rollback()\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n\nif exists {\n    err = tx.QueryRowContext(ctx, \"SELECT verified FROM users WHERE email = ?\", user.Email).Scan(\u0026user.Verified)\n    if err != nil {\n        tx.Rollback()\n        logToFileWithCaller(levelError, err.Error())\n        http.Error(w, \"Please try later\", http.StatusInternalServerError)\n        return\n    }\n    if user.Verified {\n        tx.Rollback()\n        setFlash(w, flashCookie, \"An account with the provided email address already exists.\")\n        http.Redirect(w, r, \"/login\", http.StatusSeeOther)\n        return\n    }\n}\n\nif !exists {\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n    if err != nil {\n        tx.Rollback()\n        logToFileWithCaller(levelError, err.Error())\n        http.Error(w, \"Please try later\", http.StatusInternalServerError)\n        return\n    }\n\n    _, err = tx.ExecContext(ctx, \"INSERT INTO users (email, password) VALUES (?, ?)\", user.Email, string(hashedPassword))\n    if err != nil {\n        tx.Rollback()\n        logToFileWithCaller(levelError, err.Error())\n        http.Error(w, \"Please try later\", http.StatusInternalServerError)\n        return\n    }\n}\n\nif err = verifyUserEmail(w, user.Email, \"/confirm-account\"); err != nil {\n    tx.Rollback()\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n\nerr = tx.Commit()\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth transaction"
  },
  "sqlite auth update": {
    "body": [
      "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n_, err = dbAuth.ExecContext(ctx, \"UPDATE users SET password = ? WHERE email = ?\", string(hashedPassword), email)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try later\", http.StatusInternalServerError)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "sqlite auth update"
  },
  "sqlite delete table content and reset index": {
    "body": [
      "_, err := db.Exec(\"DELETE FROM rackets\")\nif err != nil {\n    log.Fatal(\"Error deleting existing racket data:\", err)\n}\n\n// Reset the auto-increment value\n_, err = db.Exec(\"DELETE FROM sqlite_sequence WHERE name='rackets'\")\nif err != nil {\n    log.Fatal(\"Error resetting auto-increment value:\", err)\n}\n"
    ],
    "description": "",
    "prefix": "sqlite delete table content and reset index"
  },
  "storm init (bolt)": {
    "body": [
      "db, err := storm.Open(\"my.db\") // Check for errors when opening\nif err != nil {\n    log.Fatalf(\"Failed to open database: %v\", err)\n}\ndefer db.Close()\n\nif err := db.Init(\u0026User{}); err != nil {\n    panic(err)\n}\n"
    ],
    "description": "",
    "prefix": "storm init (bolt)"
  },
  "string to float": {
    "body": [
      "func parseStrNumToFloat(qtyStr string) (float64, error) {\n\tqty, _ := decimal.NewFromString(qtyStr)\n\tif qty.IsZero() {\n\t\treturn 0, fmt.Errorf(\"invalid money/price\")\n\t}\n\t\n\treturn qty.InexactFloat64(), nil\n}\n"
    ],
    "description": "",
    "prefix": "string to float"
  },
  "strings builder": {
    "body": [
      "var sb strings.Builder\nsb.WriteString(\"{{define \\\"\" + filepath.Base(filePath) + \"\\\"}}\")\n"
    ],
    "description": "",
    "prefix": "strings builder"
  },
  "struct building from json": {
    "body": [
      "type IssuesSearchResult struct {\n\tTotalCount int `json:\"total_count\"`\n\tItems      []*Issue\n}\n\ntype Issue struct {\n\tNumber    int\n\tHTMLURL   string `json:\"html_url\"`\n\tTitle     string\n\tState     string\n\tUser      *User\n\tCreatedAt time.Time `json:\"created_at\"`\n\tBody      string    // in Markdown format\n}\n\ntype User struct {\n\tLogin   string\n\tHTMLURL string `json:\"html_url\"`\n}\n\n/*\n{\n\t\"total_count\": 123,\n\t\"items\":[\n\t\t{\n\t\t\t\"number\": 1,\n\t\t\t\"html_url\": \"https://golang.com\",\n\t\t\t\"title\": \"Go\",\n\t\t\t\"user\": {\n\t\t\t\t\"login\": \"baubabu\",\n\t\t\t\t\"html_url\": \"https://google.com\",\n\t\t\t\t... can be more\n\t\t\t},\n\t\t\t\"state\": \"open\",\n\t\t\t\"created_at\": \"021-03-04T13:10:42Z\",\n\t\t\t\"body\": \"lorem ipsum...\",\n\t\t\t... can be more\n\t\t},\n\t\t... can be more\n\t]\n}\n*/\n"
    ],
    "description": "",
    "prefix": "struct building from json"
  },
  "template csrf": {
    "body": [
      "{{ .csrfField }}\n"
    ],
    "description": "",
    "prefix": "template csrf"
  },
  "template html and": {
    "body": [
      "{{if and .User .User.Admin}}\n  You are an admin user!\n{{else}}\n  Access denied!\n{{end}}\n"
    ],
    "description": "",
    "prefix": "template html and"
  },
  "template html dot change": {
    "body": [
      "\u003cdiv\u003eThe dot is {{ . }}\u003c/div\u003e\n\u003cdiv\u003e\n{{ with \"world\"}}\n  Now the dot is set to {{ . }}\n{{ end }}\n\u003c/div\u003e\n\u003cdiv\u003eThe dot is {{ . }} again\u003c/div\u003e\n"
    ],
    "description": "",
    "prefix": "template html dot change"
  },
  "template html if": {
    "body": [
      "{{ if . }}\n  Number is greater than 5!\n{{ else }}\n  Number is 5 or less!\n{{ end }}\n"
    ],
    "description": "",
    "prefix": "template html if"
  },
  "template html range": {
    "body": [
      "\u003cul\u003e\n{{ range . }}\n  \u003cli\u003e{{ . }}\u003c/li\u003e\n{{ end}}\n\u003c/ul\u003e\n"
    ],
    "description": "",
    "prefix": "template html range"
  },
  "template html variable": {
    "body": [
      "{{$number := .}}\n\u003ch1\u003e It is day number {{$number}} of the month \u003c/h1\u003e\n"
    ],
    "description": "",
    "prefix": "template html variable"
  },
  "template inline html with function": {
    "body": [
      "const templ = `Hello {{.Name}} it's {{.T | daysAgo}}`\n\nfunc daysAgo(t time.Time) string {\n\tclock, min, sec := t.Clock()\n\treturn fmt.Sprintf(\"%d:%d:%d\\n\", clock, min, sec)\n}\n\nvar report = template.Must(template.New(\"issuelist\").\n\tFuncs(template.FuncMap{\"daysAgo\": daysAgo}).\n\tParse(templ))\n\t\ndata := struct {\n    Name string\n    T    time.Time\n}{\n    Name: \"Andrei\",\n    T:    time.Now(),\n}\nlog.Fatalln(report.Execute(os.Stdout, data))\n"
    ],
    "description": "",
    "prefix": "template inline html with function"
  },
  "template parse all files and render page (generate html)": {
    "body": [
      "var (\n\ttemplates     *template.Template\n\ttemplatesLock sync.RWMutex\n\ttemplateDir   = \"app/src\"\n)\n\n/* Initial load of templates */\nif err := loadTemplates(templateDir); err != nil {\n    log.Fatal(\"Failed to load templates:\", err)\n}\n\n/* index functionality */\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    RenderTemplate(w, \"index.html\", map[string]interface{}{})\n})\n\t\n// Load all templates from the directory dynamically\nfunc loadTemplates(goTemplatesDir string) error {\n\tfiles := []string{}\n\n\t// Walk through the directory and collect all .html files\n\terr := filepath.WalkDir(goTemplatesDir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !d.IsDir() \u0026\u0026 filepath.Ext(path) == \".html\" {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse all template files dynamically\n\ttmpl, err := template.ParseFiles(files...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Safely update the global template reference\n\ttemplatesLock.Lock()\n\ttemplates = tmpl\n\ttemplatesLock.Unlock()\n\n\tlog.Println(\"Templates reloaded successfully.\")\n\treturn nil\n}\t\n\n// RenderTemplate safely renders the given template with provided data\nfunc RenderTemplate(w http.ResponseWriter, tmplName string, data map[string]interface{}) {\n\ttemplatesLock.RLock()\n\tdefer templatesLock.RUnlock()\n\n\terr := templates.ExecuteTemplate(w, tmplName, data)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"Template execution error: %v\", err), http.StatusInternalServerError)\n\t\tlog.Printf(\"Template execution error: %v\", err)\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "template parse all files and render page (generate html)"
  },
  "template render inline html": {
    "body": [
      "tmpl := `\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003eAuthorization Example\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\n    \u003ca href=\"/signup\"\u003eSignup\u003c/a\u003e\n    \u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\n    \u003ch1\u003eAuthorization Example\u003c/h1\u003e\n    {{if .FlashMsg}}\n            \u003cp style=\"color: green;\"\u003e{{.FlashMsg}}\u003c/p\u003e\n        {{end}}\n    {{if .UserEmail}}\n        \u003cp\u003eWelcome, {{.UserEmail}}!\u003c/p\u003e\n    {{else}}\n        \u003cp\u003eWelcome, Guest!\u003c/p\u003e\n    {{end}}\n\u003c/body\u003e\n\u003c/html\u003e`\n\ndata := map[string]interface{}{\n    \"UserEmail\": userEmail,\n    \"FlashMsg\":  flashMsg,\n}\n\nerr := RenderTemplateInline(w, tmpl, data)\nif err != nil {\n    logToFileWithCaller(levelError, err.Error())\n    http.Error(w, \"Please try letter\", http.StatusInternalServerError)\n}\n\nfunc RenderTemplateInline(w http.ResponseWriter, tmpl string, data map[string]interface{}) error {\n\ttempParsed, err := template.New(\"\").Parse(tmpl)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tempParsed.Execute(w, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
    ],
    "description": "",
    "prefix": "template render inline html"
  },
  "termianl pretty print": {
    "body": [
      "func printToTerminal() {\n\tconst format = \"%v\\t%v\\t%v\\t%v\\t%v\\t\\n\"\n\ttw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0)\n\tfmt.Fprintf(tw, format, \"Title\", \"Artist\", \"Album\", \"Year\", \"Length\")\n\tfmt.Fprintf(tw, format, \"-----\", \"------\", \"-----\", \"----\", \"------\")\n\tfmt.Fprintf(tw, format, \"Song\", \"Andrei\", \"Life\", \"1987\", \"10min\")\n\ttw.Flush() // calculate column widths and print table\n}\n"
    ],
    "description": "",
    "prefix": "termianl pretty print"
  },
  "terminal ask question": {
    "body": [
      "// ssl := doYouWant(\"ssl\")\nfunc doYouWant(option string) (yes bool, err error) {\n\tanswer := \"\"\n\n\t// ask question\n\tfmt.Printf(\"Activate %s? (y/N) \", option)\n\n\t// get answer\n\t_, err = fmt.Fscanln(os.Stdin, \u0026answer)\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"unexpected newline\") {\n\t\t\treturn false, nil\n\t\t} else {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tif answer != \"\" {\n\t\tif strings.ToLower(answer) == \"y\" {\n\t\t\tyes = true\n\t\t}\n\t}\n\n\treturn\n}\n"
    ],
    "description": "",
    "prefix": "terminal ask question"
  },
  "terminal exec command": {
    "body": [
      "command := \"ls\"\nc := exec.Command(\"sh\", \"-c\", command)\no, err := c.Output()\nif err != nil {\n    return nil, err\n}\n"
    ],
    "description": "",
    "prefix": "terminal exec command"
  },
  "terminal exec command with syscall": {
    "body": [
      "command := \"/bin/ls\"\nenv := os.Environ()\nsyscall.Exec(command, []string{\"ls\", \"-a\", \"-x\"}, env)\n"
    ],
    "description": "",
    "prefix": "terminal exec command with syscall"
  },
  "terminal flags": {
    "body": [
      "strPtr := flag.String(\"name\", \"Shiju\", \"a string\")\nnumbPtr := flag.Int(\"num\", 25, \"an int\")\nboolPtr := flag.Bool(\"enable\", false, \"a bool\")\nvar num int\nflag.IntVar(\u0026num, \"num\", 30, \"an int\")\t\n// Parse parses flag definitions from the argument list.\nflag.Parse()\n// Get the values for pointers\nfmt.Println(\"name:\", *strPtr)\nfmt.Println(\"num:\", *numbPtr)\nfmt.Println(\"enable:\", *boolPtr)\n// Get the value from a variable\nfmt.Println(\"num:\", num)\n// Args returns the non-flag command-line arguments.\nfmt.Println(\"arguments:\", flag.Args())\n"
    ],
    "description": "",
    "prefix": "terminal flags"
  },
  "terminal read byte": {
    "body": [
      "os.Stdin.Read(make([]byte, 1))\n"
    ],
    "description": "",
    "prefix": "terminal read byte"
  },
  "terminal read with reader (bufio)": {
    "body": [
      "reader := bufio.NewReader(os.Stdin)\nfor {\n  fmt.Printf(\"Enter some text: \")\n  data, err := reader.ReadString('\\n')\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Println(data)\n}\n"
    ],
    "description": "",
    "prefix": "terminal read with reader (bufio)"
  },
  "terminal read with scanner": {
    "body": [
      "seen := make(map[string]bool) // a set of strings\ninput := bufio.NewScanner(os.Stdin)\nfor input.Scan() {\n    line := input.Text()\n    if !seen[line] {\n        seen[line] = true\n        fmt.Println(line)\n    }\n}\n\nif err := input.Err(); err != nil {\n    fmt.Fprintf(os.Stderr, \"dedup: %v\\n\", err)\n    os.Exit(1)\n}\n"
    ],
    "description": "",
    "prefix": "terminal read with scanner"
  },
  "test boilerplate": {
    "body": [
      "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/asdine/storm/v3\"\n)\n\nvar db *storm.DB // Package-level variable for the DB\n\n// TestMain is executed by the testing package before any tests or benchmarks\n// in this package are run.\nfunc TestMain(m *testing.M) {\n\t// dbPath := \"/dev/shm/my_in_memory_storm.db\" // Option for RAM disk on Linux\n\tdbPath := \"my_test.db\" // Using a local file for the test database\n\n\t// Best effort to remove any pre-existing test database file to ensure a clean state.\n\t// This is helpful if a previous test run was interrupted.\n\t// We ignore the error here as the file might not exist.\n\t_ = os.Remove(dbPath)\n\n\tvar err error\n\tdb, err = storm.Open(dbPath)\n\tif err != nil {\n\t\t// Use log.Printf or fmt.Printf for errors where you want to control the exit yourself.\n\t\tlog.Printf(\"CRITICAL: Failed to open test database %s: %v\", dbPath, err)\n\t\t// No db instance to close if Open failed.\n\t\t// The file might or might not have been created by storm.Open before erroring.\n\t\t// For simplicity, we exit directly. If storm.Open guarantees file creation on error,\n\t\t// an os.Remove(dbPath) could be attempted here.\n\t\tos.Exit(1)\n\t}\n\n\t// If storm.Open succeeded, db is valid.\n\t// We will explicitly close it and remove the file in the teardown phase.\n\n\t// Initialize schema\n\tif err := db.Init(\u0026User{}); err != nil {\n\t\tlog.Printf(\"CRITICAL: Failed to initialize User schema for test database %s: %v\", dbPath, err)\n\t\t// Attempt to clean up since DB was opened.\n\t\t_ = db.Close()        // Best effort to close the opened database.\n\t\t_ = os.Remove(dbPath) // Best effort to remove the (partially) created db file.\n\t\tos.Exit(1)\n\t}\n\n\t// If all setup is successful, run the tests and benchmarks.\n\texitCode := m.Run()\n\n\t// Teardown phase: This runs after all tests/benchmarks in m.Run() complete.\n\t// It's crucial to attempt cleanup regardless of test outcomes.\n\tif err := db.Close(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to close test database %s: %v\", dbPath, err)\n\t}\n\tif err := os.Remove(dbPath); err != nil {\n\t\t// This might fail if db.Close() didn't release a lock, or due to permissions, etc.\n\t\tlog.Printf(\"Warning: Failed to remove test database file %s: %v\", dbPath, err)\n\t}\n\n\tos.Exit(exitCode) // Exit with the status code from m.Run()\n}\n\n// Your User struct definition would need to be accessible here.\n// (Assuming User struct is defined as in previous contexts or in main.go of package main)\n// type User struct {\n// \tID uint `storm:\"id,increment\"`\n// \t// ... other fields\n// }\n\nfunc BenchmarkAll(b *testing.B) {\n\tvar users []User\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tif err := db.All(\u0026users); err != nil {\n\t\t\tb.Fatalf(\"db.All() failed: %v\", err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAllIndex(b *testing.B) {\n\tvar users []User\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\t// Assuming \"ID\" is an indexed field in your User struct.\n\t\t// If User struct has `storm:\"id,increment\"`, \"ID\" is implicitly indexed.\n\t\tif err := db.AllByIndex(\"ID\", \u0026users); err != nil {\n\t\t\tb.Fatalf(\"db.AllByIndex(\\\"ID\\\", \u0026users) failed: %v\", err)\n\t\t}\n\t}\n}\n\n"
    ],
    "description": "",
    "prefix": "test boilerplate"
  },
  "time": {
    "body": [
      "t := time.Now()\nfmt.Println(t.Format(time.RFC3339)) // 2025-02-04T17:10:27+02:00\nfmt.Println(t.Format(\"3:04:01\")) // 5:10:02\nfmt.Println(t.Format(\"3:04PM\")) // 5:10PM\nfmt.Println(t.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Feb  4 17:10:27 2025\nfmt.Println(t.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2025-02-04T17:10:27.366005+02:00\n"
    ],
    "description": "",
    "prefix": "time"
  },
  "time format": {
    "body": [
      "then.Format(\"02 January 2006\")\n"
    ],
    "description": "",
    "prefix": "time format"
  },
  "time how to use": {
    "body": [
      "now := time.Now()\nfmt.Println(now) // 2025-02-04 17:12:20.723865 +0200 EET m=+0.001601701\n\nro, err := time.LoadLocation(\"Europe/Bucharest\")\nif err != nil {\n    log.Fatalln(err)\n}\n\nthen := time.Date(2009, 11, 17, 20, 34, 58, 651387237, ro)\nfmt.Println(then) // 2009-11-17 20:34:58.651387237 +0200 EET\n\nfmt.Println(then.Format(\"02 January 2006\")) // 17 November 2009\n\nfmt.Println(then.Year()) // 2009\nfmt.Println(then.Month()) // November\nfmt.Println(then.Day()) // 17\nfmt.Println(then.Hour()) // 20\nfmt.Println(then.Minute()) // 34\nfmt.Println(then.Second()) // 58\nfmt.Println(then.Nanosecond()) // 651387237\nfmt.Println(then.Location()) // 651387237\n\nfmt.Println(then.Weekday()) // Tuesday\n\nfmt.Println(then.Before(now)) // true\nfmt.Println(then.After(now)) // false\nfmt.Println(then.Equal(now)) // false\n\ndiff := now.Sub(then)\nfmt.Println(diff) // 133388h37m22.072477763s\n\nfmt.Println(diff.Hours()) // 133388.6227979105\nfmt.Println(diff.Minutes()) // 8.00331736787463e+06\nfmt.Println(diff.Seconds()) // 4.8019904207247776e+08\nfmt.Println(diff.Nanoseconds()) // 480199042072477763\n\nfmt.Println(then.Add(diff)) // 2025-02-04 17:12:20.723865 +0200 EET\nfmt.Println(then.Add(-diff)) // 1994-08-31 00:57:36.578909474 +0300 EEST\n"
    ],
    "description": "",
    "prefix": "time how to use"
  },
  "url extract path": {
    "body": [
      "r.RequestURI\n"
    ],
    "description": "",
    "prefix": "url extract path"
  },
  "url get query parameter": {
    "body": [
      "r.URL.Query().Get(\"token\")\n"
    ],
    "description": "",
    "prefix": "url get query parameter"
  },
  "url join": {
    "body": [
      "func joinURL(base, relative string) (string, error) {\n\tbaseURL, err := url.Parse(base)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error parsing base URL: %v\", err)\n\t}\n\n\trelativePath := strings.TrimSpace(relative)\n\trelativeURL, err := url.Parse(relativePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error parsing relative URL: %v\", err)\n\t}\n\n\tfinalURL := baseURL.ResolveReference(relativeURL)\n\treturn finalURL.String(), nil\n}\n"
    ],
    "description": "",
    "prefix": "url join"
  },
  "url parameter for no cache": {
    "body": [
      "dynamicURL := \"/content?\" + time.Now().UnixNano()\n"
    ],
    "description": "",
    "prefix": "url parameter for no cache"
  },
  "wails app": {
    "body": [
      "type App struct {\n\tCtx         context.Context\n\tCurrentFile string\n\tContent     string\n\tKey         []byte\n}\n\nfunc NewApp() *App {\n\treturn \u0026App{\n\t\tKey: []byte(\"forbfwjbfwljibfvfoieubvieufewwdw\"),\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "wails app"
  },
  "wails import func": {
    "body": [
      "import { OpenFile, SaveContent } from '../wailsjs/go/main/App';\n"
    ],
    "description": "",
    "prefix": "wails import func"
  },
  "wails onshutdown": {
    "body": [
      "OnShutdown: func(ctx context.Context) {\n    if app.CurrentFile != \"\" {\n        app.RunEncrypt()\n    }\n},\n"
    ],
    "description": "",
    "prefix": "wails onshutdown"
  },
  "wails openfile and save": {
    "body": [
      "import './style.css';\nimport './app.css';\n\nimport logo from './assets/images/logo-universal.png';\nimport { OpenFile, SaveContent } from '../wailsjs/go/main/App';\n\ndocument.querySelector('#app').innerHTML = `\n  \u003cimg id=\"logo\" class=\"logo\"\u003e\n  \u003cdiv class=\"result\" id=\"status\"\u003eChoose a file to begin editing:\u003c/div\u003e\n  \u003cdiv class=\"input-box\"\u003e\n    \u003cbutton class=\"btn\" id=\"openFileBtn\"\u003eChoose File\u003c/button\u003e\n  \u003c/div\u003e\n  \u003ctextarea id=\"content\" rows=\"20\" class=\"editor\" placeholder=\"File content will appear here...\"\u003e\u003c/textarea\u003e\n  \u003cdiv class=\"input-box\"\u003e\n    \u003cbutton class=\"btn\" id=\"saveFileBtn\"\u003eSave Changes\u003c/button\u003e\n  \u003c/div\u003e\n`;\n\ndocument.getElementById('logo').src = logo;\n\nconst status = document.getElementById('status');\nconst content = document.getElementById('content');\nconst openBtn = document.getElementById('openFileBtn');\nconst saveBtn = document.getElementById('saveFileBtn');\n\nopenBtn.addEventListener('click', async () =\u003e {\n    try {\n        const result = await OpenFile();\n        if (result !== null \u0026\u0026 result !== undefined) {\n            content.value = result;\n            status.innerText = 'File loaded successfully.';\n        } else {\n            status.innerText = 'No file selected.';\n        }\n    } catch (err) {\n        console.error(err);\n        status.innerText = 'Error loading file.';\n    }\n});\n\nsaveBtn.addEventListener('click', async () =\u003e {\n    try {\n        await SaveContent(content.value);\n        status.innerText = 'File saved!';\n    } catch (err) {\n        console.error(err);\n        status.innerText = 'Failed to save file.';\n    }\n});\n\n"
    ],
    "description": "",
    "prefix": "wails openfile and save"
  },
  "wails runencrypt": {
    "body": [
      "func (a *App) RunEncrypt() {\n\tif a.CurrentFile == \"\" || a.Content == \"\" {\n\t\treturn\n\t}\n\tencrypted, err := encryptData(a.Content, a.Key)\n\tif err != nil {\n\t\truntime.LogError(a.Ctx, err.Error())\n\t\treturn\n\t}\n\t_ = os.WriteFile(a.CurrentFile, []byte(encrypted), 0644)\n}\n"
    ],
    "description": "",
    "prefix": "wails runencrypt"
  },
  "wails runtime open file": {
    "body": [
      "func (a *App) OpenFile() (string, error) {\n\tfile, err := runtime.OpenFileDialog(a.Ctx, runtime.OpenDialogOptions{\n\t\tTitle: \"Choose a file to edit\",\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif file == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\ta.CurrentFile = file\n\tdata, err := os.ReadFile(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tdecrypted, err := decryptData(string(data), a.Key)\n\tif err != nil {\n\t\ta.Content = string(data)\n\t} else {\n\t\ta.Content = decrypted\n\t}\n\n\treturn a.Content, nil\n}\n"
    ],
    "description": "",
    "prefix": "wails runtime open file"
  },
  "wails save file content": {
    "body": [
      "func (a *App) SaveContent(content string) error {\n\ta.Content = content\n\treturn os.WriteFile(a.CurrentFile, []byte(content), 0644)\n}\n"
    ],
    "description": "",
    "prefix": "wails save file content"
  },
  "websocket watch for files change inside folder recursively": {
    "body": [
      "//go:embed reload.html\nvar reloadHtmlFile []byte\n\nvar (\n\tupgrader    = websocket.Upgrader{}\n\tconnections = make(map[*websocket.Conn]bool)\n\tmu          sync.Mutex\n\ttemplateDir = \"app/src\"\n)\n\n/* ws */\ngo watchDirectory(templateDir)\nhttp. HandleFunc(\"/\", func(w http. ResponseWriter, r *http. Request) {\n    w.Write([]byte(\"Hello World!\"))\n})\n\nhttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n    upgrader.CheckOrigin = func(r *http.Request) bool { return true }\n    conn, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Println(\"WebSocket upgrade error:\", err)\n        return\n    }\n\n    mu.Lock()\n    connections[conn] = true\n    mu.Unlock()\n\n    fmt.Println(\"New WebSocket connection\")\n})\n\n/* index functionality */\nhttp.HandleFunc(\"/reload\", func(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/html\")\n    w.Write(reloadHtmlFile)\n})\n\n// Watch for changes in the directory and if there is a change loadTemplates() and notifyClients()\nfunc watchDirectory(directory string) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Close()\n\n\t// Function to recursively add directories to the watcher\n\terr = filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.IsDir() {\n\t\t\terr = watcher.Add(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error watching directory: %s, %v\", path, err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Watching:\", path)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\teventCache := make(map[string]time.Time)\n\t\n\tfor {\n\t\tselect {\n\t\tcase event, ok := \u003c-watcher.Events:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif event.Op\u0026(fsnotify.Write|fsnotify.Create|fsnotify.Remove|fsnotify.Rename) != 0 \u0026\u0026 strings.HasSuffix(event.Name, \".html\") {\n\t\t\t\tnow := time.Now()\n\t\t\t\tif lastEventTime, exists := eventCache[\"reload\"]; exists \u0026\u0026 now.Sub(lastEventTime) \u003c 100*time.Millisecond {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\teventCache[\"reload\"] = now\n\t\t\t\tif err := templates.Load(); err != nil {\n\t\t\t\t\tlog.Println(\"Failed to reload templates:\", err)\n\t\t\t\t}\n\t\t\t\tws.NotifyClients()\n\t\t\t}\n\t\t\t// Handle newly created directories\n\t\t\tif event.Op\u0026fsnotify.Create == fsnotify.Create {\n\t\t\t\tfileInfo, err := os.Stat(event.Name)\n\t\t\t\tif err == nil \u0026\u0026 fileInfo.IsDir() {\n\t\t\t\t\twatcher.Add(event.Name)\n\t\t\t\t\tfmt.Println(\"Added new directory to watch:\", event.Name)\n\t\t\t\t}\n\t\t\t}\n\t\tcase err, ok := \u003c-watcher.Errors:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Println(\"Error watching files:\", err)\n\t\t}\n\t}\n}\n\n// Notify all connected WebSocket clients\nfunc notifyClients() {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tfor conn := range connections {\n\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(\"reload\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error sending message:\", err)\n\t\t\tconn.Close()\n\t\t\tdelete(connections, conn)\n\t\t}\n\t}\n}\n"
    ],
    "description": "",
    "prefix": "websocket watch for files change inside folder recursively"
  },
  "wr": {
    "body": [
      "func $START(w http.ResponseWriter, r *http.Request) {\n\t$END$\n}\n"
    ],
    "description": "",
    "prefix": "wr"
  },
  "writer header etag": {
    "body": [
      "// Generate ETag for dynamic content\netag := generateETag(content)\nw.Header().Set(\"ETag\", etag)\n\n// Compare with the ETag in the request\nif match := r.Header.Get(\"If-None-Match\"); match != \"\" \u0026\u0026 match == etag {\n    w.WriteHeader(http.StatusNotModified)\n    return\n}\n"
    ],
    "description": "",
    "prefix": "writer header etag"
  },
  "writer header no cahce": {
    "body": [
      "w.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\nw.Header().Set(\"Pragma\", \"no-cache\")\nw.Header().Set(\"Expires\", \"0\")\n"
    ],
    "description": "",
    "prefix": "writer header no cahce"
  },
  "writer header set html": {
    "body": [
      "w.Header().Set(\"Content-Type\", \"text/html\")\n"
    ],
    "description": "",
    "prefix": "writer header set html"
  },
  "writer header set redirect": {
    "body": [
      "w.Header().Set(\"Location\", \"http://google.com\")\nw.WriteHeader(302)\n"
    ],
    "description": "",
    "prefix": "writer header set redirect"
  },
  "writer serve favicon": {
    "body": [
      "func handleFavicon(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, \"static/favicon.ico\")\n}\n"
    ],
    "description": "",
    "prefix": "writer serve favicon"
  },
  "writer serve favicon from embedded": {
    "body": [
      "mux.HandleFunc(\"/favicon.ico\", func(w http.ResponseWriter, r *http.Request) {\nfile, readErr := f.ReadFile(\"assets/favicon.ico\")\nif readErr != nil {\n    slog.Warn(\"Failed to read favicon.ico\", \"error\", readErr, \"path\", r.URL.Path)\n    http.NotFound(w, r)\n    return\n}\nw.Header().Set(\"Content-Type\", \"image/x-icon\")\nw.Write(file)\n})\n"
    ],
    "description": "",
    "prefix": "writer serve favicon from embedded"
  },
  "writer serve file": {
    "body": [
      "w.Header().Set(\"Vary\", \"Accept-Encoding\")\nw.Header().Set(\"Cache-Control\", \"public, max-age=7776000\")\nhttp.ServeFile(w, r, \"manifest.json\")\n"
    ],
    "description": "",
    "prefix": "writer serve file"
  },
  "writer write json": {
    "body": [
      "w.Header().Set(\"Content-Type\", \"application/json\")\npost := \u0026Post{\n    User:    \"Sau Sheong\",\n    Threads: []string{\"first\", \"second\", \"third\"},\n}\njson, _ := json.Marshal(post)\nw.Write(json)\n"
    ],
    "description": "",
    "prefix": "writer write json"
  }
}